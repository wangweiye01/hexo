{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/1.jpg","path":"images/1.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1577152857560},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1577152857560},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1577152857560},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1577152857560},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1577152857560},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1577152857570},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1577152857570},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1577152857570},{"_id":"themes/next/README.cn.md","hash":"02713071ef9e260b3fe77f4403942189d55a00e9","modified":1577152857570},{"_id":"themes/next/README.md","hash":"529d53dfa97678f8ce4c95620b26e61154162a29","modified":1577152857570},{"_id":"themes/next/_config.yml","hash":"efadfa340c18b775bc37b3915fb47a845184167f","modified":1577152857570},{"_id":"themes/next/bower.json","hash":"6d6ae7531cf3fedc97c58cdad664f5793eb3cc88","modified":1577152857570},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1577152857570},{"_id":"themes/next/package.json","hash":"93a74dbc0fe3a1208a02e9cec3c15c2375339cc1","modified":1577152857990},{"_id":"source/_posts/CentOS.md","hash":"507670b3b194610da02184eb8adaab43c24382e0","modified":1577152857330},{"_id":"source/_posts/access-log.md","hash":"1e8ee1213102150087c76902a9c162b623cc6b41","modified":1577152857330},{"_id":"source/_posts/access-token.md","hash":"50da66fe62a75341ae098d097b7646fbc8a31b27","modified":1577152857330},{"_id":"source/_posts/activemq.md","hash":"85ad544f6af1ada65a898da357102a6eb46bcc5b","modified":1577152857340},{"_id":"source/_posts/blockchain.md","hash":"0dc10213409f0a6d7b5f5f2e0d7f954f898cdbc1","modified":1577152857340},{"_id":"source/_posts/cache-db.md","hash":"bf66e25dd739e9a63740365c17adb943dd9ab0b1","modified":1577152857340},{"_id":"source/_posts/defent.md","hash":"62c4c9161d0ebb171ed530430b7f670bc6e69a6c","modified":1577152857340},{"_id":"source/_posts/delay-queue.md","hash":"990493b18c65997bd95e363ec493701d329d95eb","modified":1577152857340},{"_id":"source/_posts/distribute-lock.md","hash":"07677a919d70a6490d49bcff693b1fcf765f4eb9","modified":1577152857340},{"_id":"source/_posts/docker.md","hash":"bf6ca07486b765c4ede26d8e78297a33aae16acc","modified":1577152857340},{"_id":"source/_posts/floyd.md","hash":"10ee0c319dfd9b5097df7f11885a04c0c64b39fe","modified":1585039183470},{"_id":"source/_posts/git-remote.md","hash":"c4f0c39e118450e896afedfd82498fab6156a83a","modified":1577152857350},{"_id":"source/_posts/hello-world.md","hash":"7360d8ef93dc6f83cb013dce795171e173b3562e","modified":1577152857350},{"_id":"source/_posts/jasypt.md","hash":"0beab655ec6ac80b2d17b1aca97a2948c6937d36","modified":1577152857350},{"_id":"source/_posts/java-pack-unpack.md","hash":"bb2b58ac22c8a23bd29b94b324cb49bcf39b5fc6","modified":1577152857350},{"_id":"source/_posts/java-thread.md","hash":"65a469b94f609a385f2d30b8d7a98667684933f3","modified":1577152857350},{"_id":"source/_posts/java.md","hash":"4d3e0f3ef72ebe64e9ba3eade105df6ab7d34b34","modified":1577152857360},{"_id":"source/_posts/jenkins.md","hash":"f5ee84c51c9f7ad480b809478d298aa0aaec5ac5","modified":1577152857360},{"_id":"source/_posts/linux-safe.md","hash":"ab41bd3b9336bfe5baae0e542fc896428280de92","modified":1577152857360},{"_id":"source/_posts/mac-git.md","hash":"2a517ef626773677305c91bd22bf17bfa36ee31a","modified":1577152857360},{"_id":"source/_posts/master-slave.md","hash":"c41e9522c769c03c1f26e7cdae18e550861e36b1","modified":1577152857440},{"_id":"source/_posts/maven.md","hash":"d6b028d8fab6c2af704cf7ce25c7b263ac414b0c","modified":1577152857440},{"_id":"source/_posts/mybatis.md","hash":"8cc7fad76a1f352ed114979860b416ca037ea3ab","modified":1577152857440},{"_id":"source/_posts/mysql-back.md","hash":"d23238dda8ccaa7f073ca388c261f8c6d62ca40b","modified":1577152857440},{"_id":"source/_posts/mysql-linux.md","hash":"7fbed91eee4767493356d2a6347337ca88d56908","modified":1577152857450},{"_id":"source/_posts/mysql-out.md","hash":"c7d086186cfa42e6f66f71c6e5f071e45f081e7f","modified":1577152857450},{"_id":"source/_posts/nginx-cores.md","hash":"9a6893783b95049686b91a1b02942b46695dcbb8","modified":1577152857450},{"_id":"source/_posts/nginx-strategy.md","hash":"86fe5475b98280454d1786a645f3d531802c06e2","modified":1577152857450},{"_id":"source/_posts/nohup.md","hash":"7d7a3dc0a74ce074bacdb93ba248fd40bb7252ec","modified":1577152857450},{"_id":"source/_posts/observer.md","hash":"b9a12d1a19cc86226d3a80ee6ca7a962b436497d","modified":1577152857450},{"_id":"source/_posts/pattern-template.md","hash":"5ceacd068b80cf2ed692f6ba96b9ef033fe269cd","modified":1577152857450},{"_id":"source/_posts/promise-to-refreshtoken.md","hash":"cc9c6de312a8ad3369e8f23a63674cf468e61c74","modified":1577153699890},{"_id":"source/_posts/ratelimit.md","hash":"e1f5fc4e6b9272547ff607f5878899a4a7dbabe7","modified":1593745731740},{"_id":"source/_posts/round.md","hash":"a35ac472452e6e247e20793c3c1b1f885eeb7d8f","modified":1577152857450},{"_id":"source/_posts/scan-notify.md","hash":"05fe603f3c66b1fc1a3abf6291dc5b01488ce76c","modified":1602295921870},{"_id":"source/_posts/sequence.md","hash":"eb82a4586cc805d62566adc09d3947203eaa2f3f","modified":1577152857450},{"_id":"source/_posts/shadowsocks.md","hash":"ac543cd3c09b1cb88fa28acf984867111bd8fd42","modified":1577152857460},{"_id":"source/_posts/singleton.md","hash":"71a1ee72002277836d0213c60f93b653c39328fe","modified":1577152857460},{"_id":"source/_posts/snow-flake.md","hash":"41957c15f941ac661d5318361bfa8da29bc167d2","modified":1577152857460},{"_id":"source/_posts/socket.md","hash":"b36769c6c704ed2e77adefb41292c79b4d356415","modified":1577152857460},{"_id":"source/_posts/spring-boot-active.md","hash":"e0eefdaa43918923b81d823430299c848d8ffa03","modified":1577152857460},{"_id":"source/_posts/spring-boot-tomcat.md","hash":"8c768f2d754db8f07f8743da5fcf4f134afd7a61","modified":1577152857460},{"_id":"source/_posts/spring-cloud-eureka.md","hash":"adcf5338e234935e7b94e2c21b993cd19974b468","modified":1577152857460},{"_id":"source/_posts/spring-cloud10.md","hash":"1c327b8a508a2141787ce77513a6be6047009481","modified":1577152857460},{"_id":"source/_posts/spring-cloud2.md","hash":"50bf21131f94064e2e78a1a23dec9d69bec82ec6","modified":1577152857460},{"_id":"source/_posts/spring-cloud3.md","hash":"072f0307ebd556fd74784729bc4ff61a3eb4cf0c","modified":1577152857460},{"_id":"source/_posts/spring-cloud4.md","hash":"1afead7fdd2465563f1f48159e4d3e76b8c9cffe","modified":1577152857460},{"_id":"source/_posts/spring-cloud5.md","hash":"36856564e30ce85bc501f71e2a3d3188a95f33f7","modified":1577152857460},{"_id":"source/_posts/spring-cloud6.md","hash":"56b90c2cb55f79038ef4a590ae5b6063925d3d2c","modified":1577152857470},{"_id":"source/_posts/spring-cloud7.md","hash":"837d84515eb776ff4703d53d6b0d044bbf7bc243","modified":1577152857470},{"_id":"source/_posts/spring-cloud8.md","hash":"066e81023f0cf6b75fdd0d814d6ee9ee1533a96a","modified":1577152857470},{"_id":"source/_posts/spring-cloud9.md","hash":"fe7a17540045b89cb14fcaa0c5dc54cb7de39cb5","modified":1577152857470},{"_id":"source/_posts/ssh-broken.md","hash":"7a3fb3621ccc85888644c8801ef3f1e87e7c71bf","modified":1577152857470},{"_id":"source/_posts/ssh-no-pass.md","hash":"45818f282488a5c4b6ee5d5677b8a151cc6bd8a8","modified":1577152857470},{"_id":"source/_posts/ssh.md","hash":"00da3630d8f8a2aafdba55109058b6e272f324dd","modified":1577152857470},{"_id":"source/_posts/throttle.md","hash":"ef60f3b714e489eeb51568e001c56ff63d9f4f4e","modified":1577152857470},{"_id":"source/_posts/ubuntu_firefox.md","hash":"b8eda6edb04759efe5a3247ce662a6376073d5b4","modified":1577152857470},{"_id":"source/_posts/websocket.md","hash":"278e4db6d00465efa8ac4ca02218f7a1842efbd7","modified":1577152857480},{"_id":"source/categories/index.md","hash":"2401c8197faa03a41038f5d9fda5152fd76a8662","modified":1577152857480},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1577152857570},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1577152857570},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1577152857580},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1577152857580},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1577152857580},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1577152857580},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1577152857580},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1577152857580},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1577152857580},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1577152857580},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1577152857580},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1577152857590},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1577152857590},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1577152857590},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1577152857590},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1577152857590},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1577152857990},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1577152857990},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1577152857990},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1577152857990},{"_id":"themes/next/scripts/merge-configs.js","hash":"cb617ddf692f56e6b6129564d52e302f50b28243","modified":1577152857990},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1577152858000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1577152857990},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1577152857990},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1577152857990},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1577152859810},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1577152859810},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1577152859810},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577152858650},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1577152857590},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1577152857590},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1577152857590},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1577152857590},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1577152857600},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1577152857600},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9efc455894921a66bbc074055d3b39c8a34a48a4","modified":1577152857600},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1577152857700},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1577152857700},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1577152857700},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1577152857700},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1577152857710},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1577152857710},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1577152857710},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1577152857710},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1577152857720},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1577152857720},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1577152857720},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1577152857970},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1577152857980},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1577152857970},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1577152857980},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1577152857980},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1577152857980},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1577152857980},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1577152858000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1577152858000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1577152858000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1577152858000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1577152858000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1577152858150},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1577152858150},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1577152858150},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1577152858150},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1577152858650},{"_id":"themes/next/source/images/1.jpg","hash":"fad9b4e8e2c4ffa3faca4cc5e05410ccf7b1b3e1","modified":1577152858650},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1577152858650},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1577152858650},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1577152858650},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1577152858650},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1577152858650},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1577152858650},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1577152858650},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1577152858660},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1577152858980},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1577152858660},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1577152858980},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1577152858980},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1577152858980},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1577152858980},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1577152858980},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1577152858980},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1577152858980},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1577152858980},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577152857720},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577152857720},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577152858620},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577152858620},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577152858620},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577152858640},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577152858640},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1577152857710},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1577152857710},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1577152857710},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1577152857710},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1577152857710},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1577152857720},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1577152857720},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1577152857720},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1577152857710},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1577152857720},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1577152857720},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1577152857720},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1577152857730},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1577152857730},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1577152857730},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1577152857730},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1577152857730},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1577152857730},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1577152857730},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1577152857730},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1577152857730},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1577152857730},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1577152857740},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1577152857740},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1577152857740},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1577152857960},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1577152857960},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1577152857960},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1577152857970},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1577152857970},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1577152857970},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1577152857970},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1577152857970},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1577152857970},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1577152857980},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1577152857980},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1577152857990},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1577152857990},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1577152858620},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1577152858620},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1577152858620},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1577152858620},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1577152858640},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1577152858640},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1577152858640},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1577152858640},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1577152858990},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1577152858990},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1577152858990},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1577152858990},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1577152858990},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1577152858990},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1577152858990},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1577152858990},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1577152858990},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1577152859000},{"_id":"themes/next/source/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1577152859000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1577152859010},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1577152859230},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1577152859230},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1577152859240},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1577152859240},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1577152859250},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1577152859250},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1577152859260},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1577152859260},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1577152859260},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1577152859260},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1577152859260},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1577152859260},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1577152859260},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1577152859540},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1577152859540},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1577152859540},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1577152859540},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1577152859540},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1577152859540},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1577152859550},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1577152859550},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1577152859550},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1577152859550},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1577152859550},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1577152859550},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1577152859550},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1577152859550},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1577152859550},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1577152859560},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1577152859560},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1577152859670},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1577152859670},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1577152859670},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1577152859670},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1577152859670},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1577152859670},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1577152859680},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1577152859680},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1577152859680},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1577152859680},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1577152859700},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1577152859700},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1577152859810},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1577152859800},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1577152859810},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1577152859540},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1577152857980},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1577152857980},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1577152858160},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1577152858160},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1577152858160},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1577152858160},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1577152858160},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1577152858180},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1577152858420},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1577152858450},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1577152858450},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1577152858450},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1577152858450},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1577152858450},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1577152858450},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1577152858620},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1577152858620},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1577152858630},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1577152858630},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1577152858630},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1577152858630},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1577152858630},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1577152858630},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1577152858630},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1577152858630},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1577152858630},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1577152858630},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1577152858630},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1577152858640},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1577152858640},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1577152858640},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1577152858640},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1577152858640},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"bcf52192942c0afc410c74a0fb458e7936ddc3d5","modified":1577152858640},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1577152858640},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1577152858990},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1577152859010},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1577152859010},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1577152859240},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1577152859240},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1577152859240},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1577152859240},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1577152859240},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1577152859240},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1577152859250},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1577152859250},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1577152859260},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1577152859260},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1577152859260},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1577152859270},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1577152859270},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1577152859690},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1577152859700},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1577152859010},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1577152859250},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1577152859540},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1577152859710},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1577152858160},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1577152858170},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1577152858170},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1577152858170},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1577152858170},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1577152858170},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1577152858160},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1577152858160},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1577152858160},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1577152858160},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1577152858170},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1577152858170},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1577152858170},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1577152858170},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1577152858180},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1577152858180},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1577152858180},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1577152858180},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1577152858180},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1577152858180},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1577152858180},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1577152858180},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1577152858180},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1577152858190},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1577152858190},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1577152858190},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1577152858190},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1577152858190},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1577152858190},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1577152858410},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1577152858420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1577152858420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1577152858420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1577152858420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1577152858420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1577152858420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1577152858420},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1577152858420},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1577152858420},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1577152858430},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1577152858430},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1577152858430},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1577152858430},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1577152858430},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1577152858430},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1577152858430},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1577152858430},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1577152858440},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1577152858440},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1577152858440},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1577152858440},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1577152858440},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1577152858440},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1577152858440},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1577152858440},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1577152858440},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1577152858450},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1577152858450},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1577152858630},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1577152858630},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1577152858640},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1577152859000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1577152859000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1577152859000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1577152859000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1577152859000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1577152859010},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1577152859240},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1577152859240},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1577152859250},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1577152859520},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1577152859250},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1577152859530},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1577152859250},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1577152859250},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1577152859270},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1577152859530},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1577152859030},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1577152859690},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1577152859530},{"_id":"public/categories/index.html","hash":"4dec5366390689ebf11d86f91a57f779ee7ea1fc","modified":1593746179020},{"_id":"public/2017/12/14/mybatis/index.html","hash":"c95a4c5f306a53eeb505f70a8f0bc3f22995ea19","modified":1593746179021},{"_id":"public/2017/12/05/round/index.html","hash":"4df4f810d8d7b39ea37459ab01f5fea929e86acb","modified":1593746179021},{"_id":"public/2017/11/29/nohup/index.html","hash":"5fc310b61ac988b6000f252109b5b4ca712166ca","modified":1593746179022},{"_id":"public/archives/2017/page/3/index.html","hash":"3ec9658419c8b8383b450a97c75b6f97ab79ceb6","modified":1593746179022},{"_id":"public/archives/2017/01/index.html","hash":"621c1409cb9865f37723fde7d5d78f35f1838255","modified":1593746179022},{"_id":"public/archives/2017/12/page/2/index.html","hash":"1b468f65c43105cb3126edf7045ea57a9ca674f9","modified":1593746179022},{"_id":"public/archives/2018/02/index.html","hash":"9dc86b71b4a23dd4b9c8b5df57f3b9aac294a2c6","modified":1593746179022},{"_id":"public/archives/2018/03/index.html","hash":"b379171469c0bb0514848e54ad5ec17230377972","modified":1593746179023},{"_id":"public/archives/2018/06/index.html","hash":"3fc0f9401dafc177388045e8b54a71d8debc4b9d","modified":1593746179023},{"_id":"public/archives/2018/09/index.html","hash":"7283d3d7bee0a9a2b675d58e9b3be1e5bcce44bc","modified":1593746179023},{"_id":"public/archives/2018/12/index.html","hash":"01b06cdc81e456a3baeddb6668087794e67a5505","modified":1593746179024},{"_id":"public/archives/2019/index.html","hash":"896a9f58043be37e4e5708d93d587bc3552254b6","modified":1593746179024},{"_id":"public/archives/2019/02/index.html","hash":"9e574b79381fac565e819f5ea2e0f4e6bc2795b7","modified":1593746179024},{"_id":"public/archives/2019/10/index.html","hash":"8eb59618d09cc02ac3b0a3408ada8cd0ed0357bb","modified":1593746179024},{"_id":"public/archives/2019/12/index.html","hash":"c7ddb0ae49ed2c1749889a3bb515b1cf34ca95d8","modified":1593746179024},{"_id":"public/archives/2020/index.html","hash":"8cb725deab7fe44597a0ed1831379aaa1b8dc89f","modified":1593746179024},{"_id":"public/archives/2020/03/index.html","hash":"239f7e5853c7f932853f2f4d06b14957b85ae6d2","modified":1593746179024},{"_id":"public/categories/设计模式/index.html","hash":"90293d67859e3e79b5308a24e49f182ec01961da","modified":1593746179024},{"_id":"public/tags/前端/index.html","hash":"6eb101867787043e1510bc6d817c71ff80016574","modified":1593746179025},{"_id":"public/2020/07/03/ratelimit/index.html","hash":"5d6471519db76059ce1c62d95a036f059a2fd73a","modified":1593746179025},{"_id":"public/2020/03/24/floyd/index.html","hash":"060b41852c96f30bdcde8eaeb2a9ab482477bfd1","modified":1593746179025},{"_id":"public/2019/12/24/hello-world/index.html","hash":"40ef6704ab142904703efcb66c6973f03e654a5f","modified":1593746179025},{"_id":"public/2019/12/24/promise-to-refreshtoken/index.html","hash":"4f9360668fcd8d2aa992d68b5e11add46c603a56","modified":1593746179025},{"_id":"public/2019/10/19/throttle/index.html","hash":"bfb47066b13bfb0e4417f7dc9bc2c71c79d4ec94","modified":1593746179025},{"_id":"public/2019/02/13/distribute-lock/index.html","hash":"34660f725863862c0cd2c0a0389d7166906502d3","modified":1593746179025},{"_id":"public/2018/12/25/java-pack-unpack/index.html","hash":"a53c4199ce4d4db3ee269aa6e06177e221b4766c","modified":1593746179025},{"_id":"public/2018/09/18/jasypt/index.html","hash":"144eb06d43ab3e4730030ed66fba4d0cfc1b3bf6","modified":1593746179025},{"_id":"public/2018/06/16/pattern-template/index.html","hash":"a4a939e928b9a524ec561b33918165e5fada40bb","modified":1593746179025},{"_id":"public/2018/06/11/singleton/index.html","hash":"389e27b470e638415c53c26afbe29c2bbf690ef5","modified":1593746179026},{"_id":"public/2018/06/08/observer/index.html","hash":"7959adbe589f335abf7fd0767483d976bc4c281e","modified":1593746179026},{"_id":"public/2018/04/13/docker/index.html","hash":"193fd8e82d2d05984c4274889784eff9e4b7cbf6","modified":1593746179026},{"_id":"public/2018/04/13/access-log/index.html","hash":"9080bebd54c64724d7eb57157a00a6cdcc5d7477","modified":1593746179026},{"_id":"public/2018/04/12/spring-boot-tomcat/index.html","hash":"27776fae20622d0297d19dbd3d42cdd5fd20e8cb","modified":1593746179026},{"_id":"public/2018/04/11/spring-cloud10/index.html","hash":"1ddba23af1f62d3205573e259b24d6638dc43df7","modified":1593746179027},{"_id":"public/2018/04/11/spring-cloud8/index.html","hash":"971075851333c69785c13f37f291224bdf6f3436","modified":1593746179027},{"_id":"public/2018/04/11/spring-cloud9/index.html","hash":"a00d24e98cdfe5a3c8045cf9fb319b5f4b3f80db","modified":1593746179027},{"_id":"public/2018/04/11/spring-cloud7/index.html","hash":"2cd820e8effad93bd60a412857b42ca50abf1200","modified":1593746179027},{"_id":"public/2018/04/10/nginx-cores/index.html","hash":"eb74026c0247945c4651118c94bc8f8797a2cfd4","modified":1593746179027},{"_id":"public/2018/03/26/maven/index.html","hash":"5716a616e2cf6e716eb438edbecc84e6cd439582","modified":1593746179027},{"_id":"public/2018/03/05/scan-notify/index.html","hash":"73650f62600394e33c520addd4ca32080a044a90","modified":1602295988203},{"_id":"public/2018/03/01/websocket/index.html","hash":"70e77b729df0c47a74d0471bd511e4d516116248","modified":1593746179027},{"_id":"public/2018/02/02/git-remote/index.html","hash":"461c51d71a997026ff54d17a974bcd9cdf404652","modified":1593746179027},{"_id":"public/2018/02/02/delay-queue/index.html","hash":"e86c52e1c9ad86f48ed94747c0e26934e693196d","modified":1593746179028},{"_id":"public/2018/01/30/snow-flake/index.html","hash":"cfb49b453a3035f9615e64424fe393ccc55d8a25","modified":1593746179028},{"_id":"public/2018/01/26/master-slave/index.html","hash":"5c3b03aec6213542afc2e6dcc5d4997508105d52","modified":1593746179028},{"_id":"public/2018/01/23/java-thread/index.html","hash":"bccf855c12b2db9966a8c55ab9c090bf37d7f34b","modified":1593746179028},{"_id":"public/2018/01/20/java/index.html","hash":"49d00c6d055031437fe5774da722d018b6aaa4b4","modified":1593746179028},{"_id":"public/2018/01/19/blockchain/index.html","hash":"805c51dd9dcbdd0aececd600f3522faeb0e2ee48","modified":1593746179028},{"_id":"public/2018/01/10/spring-cloud6/index.html","hash":"62275f0d0df1c60b07670ad561cc53511f92e264","modified":1593746179029},{"_id":"public/2018/01/09/spring-cloud5/index.html","hash":"3b843287fdae16edaf64ee288208c76232f27f6e","modified":1593746179029},{"_id":"public/2018/01/08/spring-cloud4/index.html","hash":"fd8815c0130cb1b1c6a0d93fa968f2d08b0514cb","modified":1593746179029},{"_id":"public/2018/01/08/spring-cloud3/index.html","hash":"99db48003d218d1053e21f2b7ab9a5ea1185a21e","modified":1593746179029},{"_id":"public/2018/01/08/spring-cloud2/index.html","hash":"fe2aa3c532d46edc8d77eef6723b3c3e5e95e969","modified":1593746179029},{"_id":"public/2017/12/21/mysql-out/index.html","hash":"bd5ae2d65b943d676e3fdedc3e49ee2d26094602","modified":1593746179029},{"_id":"public/2017/12/20/linux-safe/index.html","hash":"6af074b96de041a25fbf656c553cdd15f76a2d14","modified":1593746179029},{"_id":"public/2017/12/20/ssh-broken/index.html","hash":"d189203ff4b558a13dcc5726ae095ca3f98cd5a2","modified":1593746179030},{"_id":"public/2017/12/18/ssh-no-pass/index.html","hash":"ffd409f9b2dec458e7c26603faee271386be414a","modified":1593746179030},{"_id":"public/2017/12/15/jenkins/index.html","hash":"750e2ec01574b185933b8e86bcc5a2cab9bf1b95","modified":1593746179030},{"_id":"public/2017/12/14/spring-cloud-eureka/index.html","hash":"920316c72528dfbda094de4562ce733d6463e667","modified":1593746179030},{"_id":"public/2017/12/13/mysql-back/index.html","hash":"57745605b0f5536a756a931f7c773c66761de3c0","modified":1593746179030},{"_id":"public/2017/12/08/mysql-linux/index.html","hash":"3cd13a43e92b994ee8a6343c8751bf4d02fe40fa","modified":1593746179030},{"_id":"public/2017/12/07/mac-git/index.html","hash":"71e1536ae32fd7ae16646bf506c3a03722d85ca3","modified":1593746179030},{"_id":"public/2017/12/04/sequence/index.html","hash":"ad3d37fd6953570fe2fb63657b491e80c048af9f","modified":1593746179031},{"_id":"public/2017/12/03/socket/index.html","hash":"85d98aee63be0a8dd211bd052e07dbb7b290305b","modified":1593746179031},{"_id":"public/2017/12/01/spring-boot-active/index.html","hash":"64e78ca3c5d26d555712ad8ebf746f621c1a5239","modified":1593746179031},{"_id":"public/2017/11/30/cache-db/index.html","hash":"9bdc98951d841b60f3dfba4020761dda38e83df3","modified":1593746179031},{"_id":"public/2017/11/29/activemq/index.html","hash":"901f7538434e502f9e9556c5233149feffe21e4f","modified":1593746179031},{"_id":"public/2017/11/29/defent/index.html","hash":"77889b82191b1ee403f476d3d49194b10eb7eb08","modified":1593746179031},{"_id":"public/2017/11/29/nginx-strategy/index.html","hash":"fa2f8b586a82d8363657b1b2df70f25edd41c517","modified":1593746179031},{"_id":"public/2017/11/28/CentOS/index.html","hash":"8d962c6b274fb384937c26126610d4f8fd9125f2","modified":1593746179031},{"_id":"public/2017/11/28/ubuntu_firefox/index.html","hash":"b38bd9daeea34d1d6fbe2624518a69689879453c","modified":1593746179031},{"_id":"public/2017/11/28/shadowsocks/index.html","hash":"2c40da41913243503b6c352bef0a32cf51f87417","modified":1593746179032},{"_id":"public/2017/11/27/ssh/index.html","hash":"91fa9ae20bd727fd71ae015b61df28b04aa78ce1","modified":1593746179032},{"_id":"public/2017/01/22/access-token/index.html","hash":"d18eb327ccdfcc01e08a37c50a9c1d9b8cb869e9","modified":1593746179032},{"_id":"public/archives/page/2/index.html","hash":"b71913cb930a5c50f97f77e250edc597671126f9","modified":1593746179032},{"_id":"public/archives/page/3/index.html","hash":"934032e80288a92e4fe388cb32d6f7963b4d3459","modified":1593746179032},{"_id":"public/archives/page/4/index.html","hash":"277d47fdf3c44ac05085890c515244db06c909a4","modified":1593746179032},{"_id":"public/archives/page/5/index.html","hash":"17f030425b52ec000dea8deefd1964bd6a7f0f77","modified":1593746179032},{"_id":"public/archives/2017/page/2/index.html","hash":"bfe4b400275248dff809f5cbe0f985897a47a8c8","modified":1593746179032},{"_id":"public/archives/index.html","hash":"89cd8f1176a330abeb4592d43fba806a2ef5f65e","modified":1593746179032},{"_id":"public/archives/page/6/index.html","hash":"a8f00e2d7a243856b55ff758d01a812cd47b21f6","modified":1593746179032},{"_id":"public/archives/2017/index.html","hash":"6346d06c4c84521bb7b595132957ab97983c1bde","modified":1593746179033},{"_id":"public/archives/2017/11/index.html","hash":"27c38a5b9d7295ad751d5f2394d6429fa9baa404","modified":1593746179033},{"_id":"public/archives/2017/12/index.html","hash":"2741ab088c2b6ef1eb32c774a2b6864deaccbfa5","modified":1593746179033},{"_id":"public/archives/2018/index.html","hash":"7135f295973be30f4c3c4586e72c9a25a84a9887","modified":1593746179033},{"_id":"public/archives/2018/page/2/index.html","hash":"13f372f484540abf56a74595c9b2ff4e1416bd32","modified":1593746179033},{"_id":"public/archives/2018/page/3/index.html","hash":"43b699241dd31eabb78b2d4b68e22e2c3b9e20d7","modified":1593746179033},{"_id":"public/archives/2018/01/index.html","hash":"bf864ac7f53be4a1e99951228e1f18ce5d4d264d","modified":1593746179033},{"_id":"public/archives/2018/04/index.html","hash":"313fc8b66edf6d2e2326d261707e19b087038492","modified":1593746179033},{"_id":"public/categories/微服务/index.html","hash":"596cac2fe2d1543e09797cd00007ae7a8e9d6990","modified":1593746179034},{"_id":"public/index.html","hash":"d0737ec29251bf7874176c1127d140b29979e2ce","modified":1602295988204},{"_id":"public/page/2/index.html","hash":"a1a41004b6e527c336ca1139918151af04b59ff4","modified":1593746179034},{"_id":"public/page/3/index.html","hash":"8469a9795eac6b42de5615c0593ee08c465bcd05","modified":1593746179034},{"_id":"public/page/4/index.html","hash":"17648a0372167efe5c84f00d21547b614e42ddc9","modified":1593746179035},{"_id":"public/page/5/index.html","hash":"075392cd9d470dac3e2a35696e2931d0ab635c59","modified":1593746179035},{"_id":"public/page/6/index.html","hash":"3a1021bed75ebccf316f1fd5762dbf2cf197e269","modified":1593746179035},{"_id":"public/archives/2020/07/index.html","hash":"4e7f3ffd0ff570343f0133ca8108fc88b163e25c","modified":1593746179041}],"Category":[{"name":"设计模式","_id":"ckc5n3jwg000t0j9k89extb4f"},{"name":"微服务","_id":"ckc5n3jx700180j9k7g1xw1ht"}],"Data":[],"Page":[{"title":"Category","date":"2018-04-11T08:32:35.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: Category\ndate: 2018-04-11 16:32:35\ntype: \"categories\"\n---\n","updated":"2019-12-24T02:00:57.480Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckc5n3jv700010j9klwlrqm1g","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"CentOS7安装好服务,外网不能访问","date":"2017-11-28T08:00:00.000Z","_content":"# 问题:CentOS安装nginx后,通过外网不能访问\n\n# 怀疑:nginx使用80端口,被防火墙拦截\n\n# 解决办法\n\n## 编辑防火墙配置文件\n\n```\nvim /etc/firewalld/zones/public.xml\n```\n\n## 增加80端口的开放\n\n```\n<port protocol=\"tcp\" port=\"80\"/>\n```\n\n## 重启防火墙\n\n```\nsystemctl restart firewalld.service\n```\n","source":"_posts/CentOS.md","raw":"---\ntitle: CentOS7安装好服务,外网不能访问\ndate: 2017-11-28 16:00:00\ntags:\n---\n# 问题:CentOS安装nginx后,通过外网不能访问\n\n# 怀疑:nginx使用80端口,被防火墙拦截\n\n# 解决办法\n\n## 编辑防火墙配置文件\n\n```\nvim /etc/firewalld/zones/public.xml\n```\n\n## 增加80端口的开放\n\n```\n<port protocol=\"tcp\" port=\"80\"/>\n```\n\n## 重启防火墙\n\n```\nsystemctl restart firewalld.service\n```\n","slug":"CentOS","published":1,"updated":"2019-12-24T02:00:57.330Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3juy00000j9k3usdfs50","content":"<h1 id=\"问题-CentOS安装nginx后-通过外网不能访问\"><a href=\"#问题-CentOS安装nginx后-通过外网不能访问\" class=\"headerlink\" title=\"问题:CentOS安装nginx后,通过外网不能访问\"></a>问题:CentOS安装nginx后,通过外网不能访问</h1><h1 id=\"怀疑-nginx使用80端口-被防火墙拦截\"><a href=\"#怀疑-nginx使用80端口-被防火墙拦截\" class=\"headerlink\" title=\"怀疑:nginx使用80端口,被防火墙拦截\"></a>怀疑:nginx使用80端口,被防火墙拦截</h1><h1 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h1><h2 id=\"编辑防火墙配置文件\"><a href=\"#编辑防火墙配置文件\" class=\"headerlink\" title=\"编辑防火墙配置文件\"></a>编辑防火墙配置文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/firewalld/zones/public.xml</span><br></pre></td></tr></table></figure>\n<h2 id=\"增加80端口的开放\"><a href=\"#增加80端口的开放\" class=\"headerlink\" title=\"增加80端口的开放\"></a>增加80端口的开放</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;port protocol=&quot;tcp&quot; port=&quot;80&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重启防火墙\"><a href=\"#重启防火墙\" class=\"headerlink\" title=\"重启防火墙\"></a>重启防火墙</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题-CentOS安装nginx后-通过外网不能访问\"><a href=\"#问题-CentOS安装nginx后-通过外网不能访问\" class=\"headerlink\" title=\"问题:CentOS安装nginx后,通过外网不能访问\"></a>问题:CentOS安装nginx后,通过外网不能访问</h1><h1 id=\"怀疑-nginx使用80端口-被防火墙拦截\"><a href=\"#怀疑-nginx使用80端口-被防火墙拦截\" class=\"headerlink\" title=\"怀疑:nginx使用80端口,被防火墙拦截\"></a>怀疑:nginx使用80端口,被防火墙拦截</h1><h1 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h1><h2 id=\"编辑防火墙配置文件\"><a href=\"#编辑防火墙配置文件\" class=\"headerlink\" title=\"编辑防火墙配置文件\"></a>编辑防火墙配置文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/firewalld/zones/public.xml</span><br></pre></td></tr></table></figure>\n<h2 id=\"增加80端口的开放\"><a href=\"#增加80端口的开放\" class=\"headerlink\" title=\"增加80端口的开放\"></a>增加80端口的开放</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;port protocol=&quot;tcp&quot; port=&quot;80&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重启防火墙\"><a href=\"#重启防火墙\" class=\"headerlink\" title=\"重启防火墙\"></a>重启防火墙</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure>\n"},{"title":"Spring Boot配置access log","date":"2018-04-13T02:49:14.000Z","top":80,"_content":"\n> Spring Boot集成logback可以解决大部分日志需求，但是缺少访问日志，这在生产环境也是一种隐患。配合Tomcat Access Log可以完美解决这个问题\n\n# 配置\n\n在Spring boot中使用了内嵌的tomcat，可以通过`server.tomcat.accesslog`配置tomcat 的access日志\n\n默认日志如下:\n\n```\nserver.tomcat.accesslog.buffered=true # 缓存日志定期刷新输出（建议设置为true，否则当有请求立即打印日志对服务的响应会有影响）\nserver.tomcat.accesslog.directory=logs # 日志文件路径，可以是相对于tomcat的路径也可是绝对路径 \nserver.tomcat.accesslog.enabled=false # 是否开启访问日志\nserver.tomcat.accesslog.file-date-format=.yyyy-MM-dd # 放在日志文件名中的日期格式 \nserver.tomcat.accesslog.pattern=common # 日志格式，在下面详解 \nserver.tomcat.accesslog.prefix=access_log # 日志文件名前缀\nserver.tomcat.accesslog.rename-on-rotate=false # 推迟在文件名中加入日期标记，直到日志分割时 \nserver.tomcat.accesslog.request-attributes-enabled=false # 为请求使用的IP地址，主机名，协议和端口设置请求属性 \nserver.tomcat.accesslog.rotate=true # 是否启用访问日志分割\nserver.tomcat.accesslog.suffix=.log # 日志名后缀\n```\n\n## pattern的配置：\n\n- `%a` - 远程ip地址，注意不一定是原始ip地址，中间可能经过nginx等的转发 \n\n- `%A` - 本地ip\n\n- `%b` - 发送的字节数，不包括HTTP标头，或者如果没有字节发送则使用' - '\n\n- `%B` - 发送的字节数，不包括HTTP标头\n\n- `%h` - 远程主机名（或IP地址，如果连接器的enableLookups为false）\n\n- `%H` - 请求协议\n\n- `%l` - Remote logical username from identd (always returns '-')\n\n- `%m` - 请求方法（GET，POST)\n\n- `%p` - 接受请求的本地端口\n\n- `%q` - 查询字符串（如果存在则用'?'作为前缀，否则为空字符串）\n\n- `%r` - HTTP请求的第一行（包括请求方法，请求的URI）\n\n- `%s` - HTTP的响应代码，如：200,404\n\n- `%S` - User session ID\n\n- `%t` - 日期和时间，Common Log Format格式\n\n- `%u` - 被认证的远程用户\n\n- `%U` - Requested URL path\n\n- `%v` - Local server name\n\n- `%D` - Time taken to process the request, in millis\n\n- `%T` - Time taken to process the request, in seconds\n\n- `%I` - 当前请求的线程名，可以和打印的log对比查找问题\n\nAccess log 也支持将cookie、header、session或者其他在ServletRequest中的对象信息打印到日志中，其配置遵循Apache配置的格式（{xxx}指值的名称）：\n\n- `%{xxx}i`  for incoming headers，request header信息\n- `%{xxx}o`  for outgoing response headers，response header信息\n- `%{xxx}c`  for a specific cookie\n- `%{xxx}r`  xxx is an attribute in the ServletRequest\n- `%{xxx}s`  xxx is an attribute in the HttpSession\n- `%{xxx}t`  xxx is an enhanced SimpleDateFormat pattern (see Configuration Reference document for details on supported time patterns)\n\n# 内置模板\n\n`server.tomcat.accesslog.pattern`中内置了两个日志格式模板，分别是common和combined\n\n- `common`: `%h %l %u %t \"%r\" %s %b`\n\n- `combined`: `%h %l %u %t \"%r\" %s %b \"%{Referer}i\" \"%{User-Agent}i\"`\n\n\n参考[Tomcat access log配置](http://www.cnblogs.com/chrischennx)\n","source":"_posts/access-log.md","raw":"---\ntitle: Spring Boot配置access log \ndate: 2018-04-13 10:49:14\ntags:\ntop: 80\n---\n\n> Spring Boot集成logback可以解决大部分日志需求，但是缺少访问日志，这在生产环境也是一种隐患。配合Tomcat Access Log可以完美解决这个问题\n\n# 配置\n\n在Spring boot中使用了内嵌的tomcat，可以通过`server.tomcat.accesslog`配置tomcat 的access日志\n\n默认日志如下:\n\n```\nserver.tomcat.accesslog.buffered=true # 缓存日志定期刷新输出（建议设置为true，否则当有请求立即打印日志对服务的响应会有影响）\nserver.tomcat.accesslog.directory=logs # 日志文件路径，可以是相对于tomcat的路径也可是绝对路径 \nserver.tomcat.accesslog.enabled=false # 是否开启访问日志\nserver.tomcat.accesslog.file-date-format=.yyyy-MM-dd # 放在日志文件名中的日期格式 \nserver.tomcat.accesslog.pattern=common # 日志格式，在下面详解 \nserver.tomcat.accesslog.prefix=access_log # 日志文件名前缀\nserver.tomcat.accesslog.rename-on-rotate=false # 推迟在文件名中加入日期标记，直到日志分割时 \nserver.tomcat.accesslog.request-attributes-enabled=false # 为请求使用的IP地址，主机名，协议和端口设置请求属性 \nserver.tomcat.accesslog.rotate=true # 是否启用访问日志分割\nserver.tomcat.accesslog.suffix=.log # 日志名后缀\n```\n\n## pattern的配置：\n\n- `%a` - 远程ip地址，注意不一定是原始ip地址，中间可能经过nginx等的转发 \n\n- `%A` - 本地ip\n\n- `%b` - 发送的字节数，不包括HTTP标头，或者如果没有字节发送则使用' - '\n\n- `%B` - 发送的字节数，不包括HTTP标头\n\n- `%h` - 远程主机名（或IP地址，如果连接器的enableLookups为false）\n\n- `%H` - 请求协议\n\n- `%l` - Remote logical username from identd (always returns '-')\n\n- `%m` - 请求方法（GET，POST)\n\n- `%p` - 接受请求的本地端口\n\n- `%q` - 查询字符串（如果存在则用'?'作为前缀，否则为空字符串）\n\n- `%r` - HTTP请求的第一行（包括请求方法，请求的URI）\n\n- `%s` - HTTP的响应代码，如：200,404\n\n- `%S` - User session ID\n\n- `%t` - 日期和时间，Common Log Format格式\n\n- `%u` - 被认证的远程用户\n\n- `%U` - Requested URL path\n\n- `%v` - Local server name\n\n- `%D` - Time taken to process the request, in millis\n\n- `%T` - Time taken to process the request, in seconds\n\n- `%I` - 当前请求的线程名，可以和打印的log对比查找问题\n\nAccess log 也支持将cookie、header、session或者其他在ServletRequest中的对象信息打印到日志中，其配置遵循Apache配置的格式（{xxx}指值的名称）：\n\n- `%{xxx}i`  for incoming headers，request header信息\n- `%{xxx}o`  for outgoing response headers，response header信息\n- `%{xxx}c`  for a specific cookie\n- `%{xxx}r`  xxx is an attribute in the ServletRequest\n- `%{xxx}s`  xxx is an attribute in the HttpSession\n- `%{xxx}t`  xxx is an enhanced SimpleDateFormat pattern (see Configuration Reference document for details on supported time patterns)\n\n# 内置模板\n\n`server.tomcat.accesslog.pattern`中内置了两个日志格式模板，分别是common和combined\n\n- `common`: `%h %l %u %t \"%r\" %s %b`\n\n- `combined`: `%h %l %u %t \"%r\" %s %b \"%{Referer}i\" \"%{User-Agent}i\"`\n\n\n参考[Tomcat access log配置](http://www.cnblogs.com/chrischennx)\n","slug":"access-log","published":1,"updated":"2019-12-24T02:00:57.330Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jv800020j9k3aebi87o","content":"<blockquote>\n<p>Spring Boot集成logback可以解决大部分日志需求，但是缺少访问日志，这在生产环境也是一种隐患。配合Tomcat Access Log可以完美解决这个问题</p>\n</blockquote>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>在Spring boot中使用了内嵌的tomcat，可以通过<code>server.tomcat.accesslog</code>配置tomcat 的access日志</p>\n<p>默认日志如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.tomcat.accesslog.buffered=true # 缓存日志定期刷新输出（建议设置为true，否则当有请求立即打印日志对服务的响应会有影响）</span><br><span class=\"line\">server.tomcat.accesslog.directory=logs # 日志文件路径，可以是相对于tomcat的路径也可是绝对路径 </span><br><span class=\"line\">server.tomcat.accesslog.enabled=false # 是否开启访问日志</span><br><span class=\"line\">server.tomcat.accesslog.file-date-format=.yyyy-MM-dd # 放在日志文件名中的日期格式 </span><br><span class=\"line\">server.tomcat.accesslog.pattern=common # 日志格式，在下面详解 </span><br><span class=\"line\">server.tomcat.accesslog.prefix=access_log # 日志文件名前缀</span><br><span class=\"line\">server.tomcat.accesslog.rename-on-rotate=false # 推迟在文件名中加入日期标记，直到日志分割时 </span><br><span class=\"line\">server.tomcat.accesslog.request-attributes-enabled=false # 为请求使用的IP地址，主机名，协议和端口设置请求属性 </span><br><span class=\"line\">server.tomcat.accesslog.rotate=true # 是否启用访问日志分割</span><br><span class=\"line\">server.tomcat.accesslog.suffix=.log # 日志名后缀</span><br></pre></td></tr></table></figure>\n<h2 id=\"pattern的配置：\"><a href=\"#pattern的配置：\" class=\"headerlink\" title=\"pattern的配置：\"></a>pattern的配置：</h2><ul>\n<li><p><code>%a</code> - 远程ip地址，注意不一定是原始ip地址，中间可能经过nginx等的转发 </p>\n</li>\n<li><p><code>%A</code> - 本地ip</p>\n</li>\n<li><p><code>%b</code> - 发送的字节数，不包括HTTP标头，或者如果没有字节发送则使用’ - ‘</p>\n</li>\n<li><p><code>%B</code> - 发送的字节数，不包括HTTP标头</p>\n</li>\n<li><p><code>%h</code> - 远程主机名（或IP地址，如果连接器的enableLookups为false）</p>\n</li>\n<li><p><code>%H</code> - 请求协议</p>\n</li>\n<li><p><code>%l</code> - Remote logical username from identd (always returns ‘-‘)</p>\n</li>\n<li><p><code>%m</code> - 请求方法（GET，POST)</p>\n</li>\n<li><p><code>%p</code> - 接受请求的本地端口</p>\n</li>\n<li><p><code>%q</code> - 查询字符串（如果存在则用’?’作为前缀，否则为空字符串）</p>\n</li>\n<li><p><code>%r</code> - HTTP请求的第一行（包括请求方法，请求的URI）</p>\n</li>\n<li><p><code>%s</code> - HTTP的响应代码，如：200,404</p>\n</li>\n<li><p><code>%S</code> - User session ID</p>\n</li>\n<li><p><code>%t</code> - 日期和时间，Common Log Format格式</p>\n</li>\n<li><p><code>%u</code> - 被认证的远程用户</p>\n</li>\n<li><p><code>%U</code> - Requested URL path</p>\n</li>\n<li><p><code>%v</code> - Local server name</p>\n</li>\n<li><p><code>%D</code> - Time taken to process the request, in millis</p>\n</li>\n<li><p><code>%T</code> - Time taken to process the request, in seconds</p>\n</li>\n<li><p><code>%I</code> - 当前请求的线程名，可以和打印的log对比查找问题</p>\n</li>\n</ul>\n<p>Access log 也支持将cookie、header、session或者其他在ServletRequest中的对象信息打印到日志中，其配置遵循Apache配置的格式（{xxx}指值的名称）：</p>\n<ul>\n<li><code>%{xxx}i</code>  for incoming headers，request header信息</li>\n<li><code>%{xxx}o</code>  for outgoing response headers，response header信息</li>\n<li><code>%{xxx}c</code>  for a specific cookie</li>\n<li><code>%{xxx}r</code>  xxx is an attribute in the ServletRequest</li>\n<li><code>%{xxx}s</code>  xxx is an attribute in the HttpSession</li>\n<li><code>%{xxx}t</code>  xxx is an enhanced SimpleDateFormat pattern (see Configuration Reference document for details on supported time patterns)</li>\n</ul>\n<h1 id=\"内置模板\"><a href=\"#内置模板\" class=\"headerlink\" title=\"内置模板\"></a>内置模板</h1><p><code>server.tomcat.accesslog.pattern</code>中内置了两个日志格式模板，分别是common和combined</p>\n<ul>\n<li><p><code>common</code>: <code>%h %l %u %t &quot;%r&quot; %s %b</code></p>\n</li>\n<li><p><code>combined</code>: <code>%h %l %u %t &quot;%r&quot; %s %b &quot;%{Referer}i&quot; &quot;%{User-Agent}i&quot;</code></p>\n</li>\n</ul>\n<p>参考<a href=\"http://www.cnblogs.com/chrischennx\" target=\"_blank\" rel=\"noopener\">Tomcat access log配置</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Spring Boot集成logback可以解决大部分日志需求，但是缺少访问日志，这在生产环境也是一种隐患。配合Tomcat Access Log可以完美解决这个问题</p>\n</blockquote>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>在Spring boot中使用了内嵌的tomcat，可以通过<code>server.tomcat.accesslog</code>配置tomcat 的access日志</p>\n<p>默认日志如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.tomcat.accesslog.buffered=true # 缓存日志定期刷新输出（建议设置为true，否则当有请求立即打印日志对服务的响应会有影响）</span><br><span class=\"line\">server.tomcat.accesslog.directory=logs # 日志文件路径，可以是相对于tomcat的路径也可是绝对路径 </span><br><span class=\"line\">server.tomcat.accesslog.enabled=false # 是否开启访问日志</span><br><span class=\"line\">server.tomcat.accesslog.file-date-format=.yyyy-MM-dd # 放在日志文件名中的日期格式 </span><br><span class=\"line\">server.tomcat.accesslog.pattern=common # 日志格式，在下面详解 </span><br><span class=\"line\">server.tomcat.accesslog.prefix=access_log # 日志文件名前缀</span><br><span class=\"line\">server.tomcat.accesslog.rename-on-rotate=false # 推迟在文件名中加入日期标记，直到日志分割时 </span><br><span class=\"line\">server.tomcat.accesslog.request-attributes-enabled=false # 为请求使用的IP地址，主机名，协议和端口设置请求属性 </span><br><span class=\"line\">server.tomcat.accesslog.rotate=true # 是否启用访问日志分割</span><br><span class=\"line\">server.tomcat.accesslog.suffix=.log # 日志名后缀</span><br></pre></td></tr></table></figure>\n<h2 id=\"pattern的配置：\"><a href=\"#pattern的配置：\" class=\"headerlink\" title=\"pattern的配置：\"></a>pattern的配置：</h2><ul>\n<li><p><code>%a</code> - 远程ip地址，注意不一定是原始ip地址，中间可能经过nginx等的转发 </p>\n</li>\n<li><p><code>%A</code> - 本地ip</p>\n</li>\n<li><p><code>%b</code> - 发送的字节数，不包括HTTP标头，或者如果没有字节发送则使用’ - ‘</p>\n</li>\n<li><p><code>%B</code> - 发送的字节数，不包括HTTP标头</p>\n</li>\n<li><p><code>%h</code> - 远程主机名（或IP地址，如果连接器的enableLookups为false）</p>\n</li>\n<li><p><code>%H</code> - 请求协议</p>\n</li>\n<li><p><code>%l</code> - Remote logical username from identd (always returns ‘-‘)</p>\n</li>\n<li><p><code>%m</code> - 请求方法（GET，POST)</p>\n</li>\n<li><p><code>%p</code> - 接受请求的本地端口</p>\n</li>\n<li><p><code>%q</code> - 查询字符串（如果存在则用’?’作为前缀，否则为空字符串）</p>\n</li>\n<li><p><code>%r</code> - HTTP请求的第一行（包括请求方法，请求的URI）</p>\n</li>\n<li><p><code>%s</code> - HTTP的响应代码，如：200,404</p>\n</li>\n<li><p><code>%S</code> - User session ID</p>\n</li>\n<li><p><code>%t</code> - 日期和时间，Common Log Format格式</p>\n</li>\n<li><p><code>%u</code> - 被认证的远程用户</p>\n</li>\n<li><p><code>%U</code> - Requested URL path</p>\n</li>\n<li><p><code>%v</code> - Local server name</p>\n</li>\n<li><p><code>%D</code> - Time taken to process the request, in millis</p>\n</li>\n<li><p><code>%T</code> - Time taken to process the request, in seconds</p>\n</li>\n<li><p><code>%I</code> - 当前请求的线程名，可以和打印的log对比查找问题</p>\n</li>\n</ul>\n<p>Access log 也支持将cookie、header、session或者其他在ServletRequest中的对象信息打印到日志中，其配置遵循Apache配置的格式（{xxx}指值的名称）：</p>\n<ul>\n<li><code>%{xxx}i</code>  for incoming headers，request header信息</li>\n<li><code>%{xxx}o</code>  for outgoing response headers，response header信息</li>\n<li><code>%{xxx}c</code>  for a specific cookie</li>\n<li><code>%{xxx}r</code>  xxx is an attribute in the ServletRequest</li>\n<li><code>%{xxx}s</code>  xxx is an attribute in the HttpSession</li>\n<li><code>%{xxx}t</code>  xxx is an enhanced SimpleDateFormat pattern (see Configuration Reference document for details on supported time patterns)</li>\n</ul>\n<h1 id=\"内置模板\"><a href=\"#内置模板\" class=\"headerlink\" title=\"内置模板\"></a>内置模板</h1><p><code>server.tomcat.accesslog.pattern</code>中内置了两个日志格式模板，分别是common和combined</p>\n<ul>\n<li><p><code>common</code>: <code>%h %l %u %t &quot;%r&quot; %s %b</code></p>\n</li>\n<li><p><code>combined</code>: <code>%h %l %u %t &quot;%r&quot; %s %b &quot;%{Referer}i&quot; &quot;%{User-Agent}i&quot;</code></p>\n</li>\n</ul>\n<p>参考<a href=\"http://www.cnblogs.com/chrischennx\" target=\"_blank\" rel=\"noopener\">Tomcat access log配置</a></p>\n"},{"title":"access_token高并发情况下被覆盖","date":"2017-01-22T03:25:20.000Z","_content":"![pic](http://www.wailian.work/images/2018/01/23/4f3eddad613cb4031652bfcd36a4e6500881bbe75c05c-ceNJBC_fw658.jpg)\n\n# 问题描述\n\n最近搞微信公众平台接口时，我们获得access_token的处理方式是：先在缓存中查找，如果找到，返回；否则，调用微信接口获得，放入缓存（有时效），然后返回；\n\n此处的逻辑并不严谨\n\n如果有两个线程  **同时**  获得access_token，而且此时恰好access_token在缓存中因为过期而删除了，那么两个线程都会调用微信接口请求access_token，这时就会出现第二次请求的结果把第一次的结果覆盖掉的情况。\n\n最初实现方法：\n\n```\npublic JSONObject getAccessToken(String appid, String appsecret) {\n    String reqestUrl = ACCESS_TOKEN_URL.replace(\"APPID\", appid).replace(\"APPSECRET\", appsecret);\n\n    RedisUtils<String> redisUtils = new RedisUtils<>(redisTemplate);\n\n    String accessToken = redisUtils.get(ACCESS_TOKEN_CACHE_KEY);\n\n    if (StrUtil.isNotEmpty(accessToken)) {\n        return JSONObject.parseObject(accessToken);\n    }\n\n    JSONObject resultJSON = JSONObject.parseObject(HttpUtil.get(reqestUrl));\n\n    if (StrUtil.isNotEmpty(resultJSON.getString(\"errcode\"))) {\n        log.info(resultJSON.getString(\"errmsg\"));\n        return null;\n    }\n\n    redisUtils.set(ACCESS_TOKEN_CACHE_KEY, resultJSON.toJSONString(), 7000L);\n\n    return resultJSON;\n}\n```\n\n# 解决方法\n\n把请求微信接口的方法加入同步代码块中\n\n```\npublic JSONObject getAccessToken(String appid, String appsecret) {\n    String reqestUrl = ACCESS_TOKEN_URL.replace(\"APPID\", appid).replace(\"APPSECRET\", appsecret);\n\n    RedisUtils<String> redisUtils = new RedisUtils<>(redisTemplate);\n\n    String accessToken = redisUtils.get(ACCESS_TOKEN_CACHE_KEY);\n\n    if (StrUtil.isNotEmpty(accessToken)) {\n        return JSONObject.parseObject(accessToken);\n    }\n\n    // 防止高并发情况下，access_token覆盖的问题\n    synchronized (appid) {\n        // 再次验证缓存中的数据\n        String accessToken2 = redisUtils.get(ACCESS_TOKEN_CACHE_KEY);\n        if (StrUtil.isNotEmpty(accessToken2)) {\n            log.info(\"multi thread hits!\");\n            return JSONObject.parseObject(accessToken2);\n        }\n\n        JSONObject resultJSON = JSONObject.parseObject(HttpUtil.get(reqestUrl));\n\n        if (StrUtil.isNotEmpty(resultJSON.getString(\"errcode\"))) {\n            log.info(resultJSON.getString(\"errmsg\"));\n            return null;\n        }\n\n        redisUtils.set(ACCESS_TOKEN_CACHE_KEY, resultJSON.toJSONString(), 7000L);\n\n        return resultJSON;\n    }\n}\n```\n","source":"_posts/access-token.md","raw":"---\ntitle: access_token高并发情况下被覆盖\ndate: 2017-01-22 11:25:20\ntags:\n---\n![pic](http://www.wailian.work/images/2018/01/23/4f3eddad613cb4031652bfcd36a4e6500881bbe75c05c-ceNJBC_fw658.jpg)\n\n# 问题描述\n\n最近搞微信公众平台接口时，我们获得access_token的处理方式是：先在缓存中查找，如果找到，返回；否则，调用微信接口获得，放入缓存（有时效），然后返回；\n\n此处的逻辑并不严谨\n\n如果有两个线程  **同时**  获得access_token，而且此时恰好access_token在缓存中因为过期而删除了，那么两个线程都会调用微信接口请求access_token，这时就会出现第二次请求的结果把第一次的结果覆盖掉的情况。\n\n最初实现方法：\n\n```\npublic JSONObject getAccessToken(String appid, String appsecret) {\n    String reqestUrl = ACCESS_TOKEN_URL.replace(\"APPID\", appid).replace(\"APPSECRET\", appsecret);\n\n    RedisUtils<String> redisUtils = new RedisUtils<>(redisTemplate);\n\n    String accessToken = redisUtils.get(ACCESS_TOKEN_CACHE_KEY);\n\n    if (StrUtil.isNotEmpty(accessToken)) {\n        return JSONObject.parseObject(accessToken);\n    }\n\n    JSONObject resultJSON = JSONObject.parseObject(HttpUtil.get(reqestUrl));\n\n    if (StrUtil.isNotEmpty(resultJSON.getString(\"errcode\"))) {\n        log.info(resultJSON.getString(\"errmsg\"));\n        return null;\n    }\n\n    redisUtils.set(ACCESS_TOKEN_CACHE_KEY, resultJSON.toJSONString(), 7000L);\n\n    return resultJSON;\n}\n```\n\n# 解决方法\n\n把请求微信接口的方法加入同步代码块中\n\n```\npublic JSONObject getAccessToken(String appid, String appsecret) {\n    String reqestUrl = ACCESS_TOKEN_URL.replace(\"APPID\", appid).replace(\"APPSECRET\", appsecret);\n\n    RedisUtils<String> redisUtils = new RedisUtils<>(redisTemplate);\n\n    String accessToken = redisUtils.get(ACCESS_TOKEN_CACHE_KEY);\n\n    if (StrUtil.isNotEmpty(accessToken)) {\n        return JSONObject.parseObject(accessToken);\n    }\n\n    // 防止高并发情况下，access_token覆盖的问题\n    synchronized (appid) {\n        // 再次验证缓存中的数据\n        String accessToken2 = redisUtils.get(ACCESS_TOKEN_CACHE_KEY);\n        if (StrUtil.isNotEmpty(accessToken2)) {\n            log.info(\"multi thread hits!\");\n            return JSONObject.parseObject(accessToken2);\n        }\n\n        JSONObject resultJSON = JSONObject.parseObject(HttpUtil.get(reqestUrl));\n\n        if (StrUtil.isNotEmpty(resultJSON.getString(\"errcode\"))) {\n            log.info(resultJSON.getString(\"errmsg\"));\n            return null;\n        }\n\n        redisUtils.set(ACCESS_TOKEN_CACHE_KEY, resultJSON.toJSONString(), 7000L);\n\n        return resultJSON;\n    }\n}\n```\n","slug":"access-token","published":1,"updated":"2019-12-24T02:00:57.330Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jvc00030j9kw4mkwa24","content":"<p><img src=\"http://www.wailian.work/images/2018/01/23/4f3eddad613cb4031652bfcd36a4e6500881bbe75c05c-ceNJBC_fw658.jpg\" alt=\"pic\"></p>\n<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>最近搞微信公众平台接口时，我们获得access_token的处理方式是：先在缓存中查找，如果找到，返回；否则，调用微信接口获得，放入缓存（有时效），然后返回；</p>\n<p>此处的逻辑并不严谨</p>\n<p>如果有两个线程  <strong>同时</strong>  获得access_token，而且此时恰好access_token在缓存中因为过期而删除了，那么两个线程都会调用微信接口请求access_token，这时就会出现第二次请求的结果把第一次的结果覆盖掉的情况。</p>\n<p>最初实现方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public JSONObject getAccessToken(String appid, String appsecret) &#123;</span><br><span class=\"line\">    String reqestUrl = ACCESS_TOKEN_URL.replace(&quot;APPID&quot;, appid).replace(&quot;APPSECRET&quot;, appsecret);</span><br><span class=\"line\"></span><br><span class=\"line\">    RedisUtils&lt;String&gt; redisUtils = new RedisUtils&lt;&gt;(redisTemplate);</span><br><span class=\"line\"></span><br><span class=\"line\">    String accessToken = redisUtils.get(ACCESS_TOKEN_CACHE_KEY);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (StrUtil.isNotEmpty(accessToken)) &#123;</span><br><span class=\"line\">        return JSONObject.parseObject(accessToken);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    JSONObject resultJSON = JSONObject.parseObject(HttpUtil.get(reqestUrl));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (StrUtil.isNotEmpty(resultJSON.getString(&quot;errcode&quot;))) &#123;</span><br><span class=\"line\">        log.info(resultJSON.getString(&quot;errmsg&quot;));</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    redisUtils.set(ACCESS_TOKEN_CACHE_KEY, resultJSON.toJSONString(), 7000L);</span><br><span class=\"line\"></span><br><span class=\"line\">    return resultJSON;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>把请求微信接口的方法加入同步代码块中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public JSONObject getAccessToken(String appid, String appsecret) &#123;</span><br><span class=\"line\">    String reqestUrl = ACCESS_TOKEN_URL.replace(&quot;APPID&quot;, appid).replace(&quot;APPSECRET&quot;, appsecret);</span><br><span class=\"line\"></span><br><span class=\"line\">    RedisUtils&lt;String&gt; redisUtils = new RedisUtils&lt;&gt;(redisTemplate);</span><br><span class=\"line\"></span><br><span class=\"line\">    String accessToken = redisUtils.get(ACCESS_TOKEN_CACHE_KEY);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (StrUtil.isNotEmpty(accessToken)) &#123;</span><br><span class=\"line\">        return JSONObject.parseObject(accessToken);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 防止高并发情况下，access_token覆盖的问题</span><br><span class=\"line\">    synchronized (appid) &#123;</span><br><span class=\"line\">        // 再次验证缓存中的数据</span><br><span class=\"line\">        String accessToken2 = redisUtils.get(ACCESS_TOKEN_CACHE_KEY);</span><br><span class=\"line\">        if (StrUtil.isNotEmpty(accessToken2)) &#123;</span><br><span class=\"line\">            log.info(&quot;multi thread hits!&quot;);</span><br><span class=\"line\">            return JSONObject.parseObject(accessToken2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        JSONObject resultJSON = JSONObject.parseObject(HttpUtil.get(reqestUrl));</span><br><span class=\"line\"></span><br><span class=\"line\">        if (StrUtil.isNotEmpty(resultJSON.getString(&quot;errcode&quot;))) &#123;</span><br><span class=\"line\">            log.info(resultJSON.getString(&quot;errmsg&quot;));</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        redisUtils.set(ACCESS_TOKEN_CACHE_KEY, resultJSON.toJSONString(), 7000L);</span><br><span class=\"line\"></span><br><span class=\"line\">        return resultJSON;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/01/23/4f3eddad613cb4031652bfcd36a4e6500881bbe75c05c-ceNJBC_fw658.jpg\" alt=\"pic\"></p>\n<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>最近搞微信公众平台接口时，我们获得access_token的处理方式是：先在缓存中查找，如果找到，返回；否则，调用微信接口获得，放入缓存（有时效），然后返回；</p>\n<p>此处的逻辑并不严谨</p>\n<p>如果有两个线程  <strong>同时</strong>  获得access_token，而且此时恰好access_token在缓存中因为过期而删除了，那么两个线程都会调用微信接口请求access_token，这时就会出现第二次请求的结果把第一次的结果覆盖掉的情况。</p>\n<p>最初实现方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public JSONObject getAccessToken(String appid, String appsecret) &#123;</span><br><span class=\"line\">    String reqestUrl = ACCESS_TOKEN_URL.replace(&quot;APPID&quot;, appid).replace(&quot;APPSECRET&quot;, appsecret);</span><br><span class=\"line\"></span><br><span class=\"line\">    RedisUtils&lt;String&gt; redisUtils = new RedisUtils&lt;&gt;(redisTemplate);</span><br><span class=\"line\"></span><br><span class=\"line\">    String accessToken = redisUtils.get(ACCESS_TOKEN_CACHE_KEY);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (StrUtil.isNotEmpty(accessToken)) &#123;</span><br><span class=\"line\">        return JSONObject.parseObject(accessToken);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    JSONObject resultJSON = JSONObject.parseObject(HttpUtil.get(reqestUrl));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (StrUtil.isNotEmpty(resultJSON.getString(&quot;errcode&quot;))) &#123;</span><br><span class=\"line\">        log.info(resultJSON.getString(&quot;errmsg&quot;));</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    redisUtils.set(ACCESS_TOKEN_CACHE_KEY, resultJSON.toJSONString(), 7000L);</span><br><span class=\"line\"></span><br><span class=\"line\">    return resultJSON;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>把请求微信接口的方法加入同步代码块中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public JSONObject getAccessToken(String appid, String appsecret) &#123;</span><br><span class=\"line\">    String reqestUrl = ACCESS_TOKEN_URL.replace(&quot;APPID&quot;, appid).replace(&quot;APPSECRET&quot;, appsecret);</span><br><span class=\"line\"></span><br><span class=\"line\">    RedisUtils&lt;String&gt; redisUtils = new RedisUtils&lt;&gt;(redisTemplate);</span><br><span class=\"line\"></span><br><span class=\"line\">    String accessToken = redisUtils.get(ACCESS_TOKEN_CACHE_KEY);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (StrUtil.isNotEmpty(accessToken)) &#123;</span><br><span class=\"line\">        return JSONObject.parseObject(accessToken);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 防止高并发情况下，access_token覆盖的问题</span><br><span class=\"line\">    synchronized (appid) &#123;</span><br><span class=\"line\">        // 再次验证缓存中的数据</span><br><span class=\"line\">        String accessToken2 = redisUtils.get(ACCESS_TOKEN_CACHE_KEY);</span><br><span class=\"line\">        if (StrUtil.isNotEmpty(accessToken2)) &#123;</span><br><span class=\"line\">            log.info(&quot;multi thread hits!&quot;);</span><br><span class=\"line\">            return JSONObject.parseObject(accessToken2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        JSONObject resultJSON = JSONObject.parseObject(HttpUtil.get(reqestUrl));</span><br><span class=\"line\"></span><br><span class=\"line\">        if (StrUtil.isNotEmpty(resultJSON.getString(&quot;errcode&quot;))) &#123;</span><br><span class=\"line\">            log.info(resultJSON.getString(&quot;errmsg&quot;));</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        redisUtils.set(ACCESS_TOKEN_CACHE_KEY, resultJSON.toJSONString(), 7000L);</span><br><span class=\"line\"></span><br><span class=\"line\">        return resultJSON;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Spring Boot整合activemq","date":"2017-11-29T04:34:03.000Z","_content":"# activemq安装\n\n## 下载\n\n[点击下载](http://activemq.apache.org/)\n\n## 解压启动\n\n```\ntar -zxvf apache-activemq-5.14.0-bin.tar.gz\n```\n进去bin目录 cd apache-activemq-5.14.0/bin 启动 ./activemq start\n\n## 打开web管理页面\n\n访问http://IP:8161/admin\n\n启动后，activeMQ会占用两个端口，一个是负责接收发送消息的tcp端口:61616，一个是基于web负责用户界面化管理的端口:8161。这两个端口可以在conf下面的xml中找到。http服务器使用了jetty\n\n# 项目集成activemq\n\n## 配置文件设置application.properties\n\n```\nspring.activemq.broker-url=tcp://localhost:61616 \nspring.activemq.user=admin \nspring.activemq.password=admin \nspring.activemq.pool.enabled=false\n```\n\n## 生产者\n```\n@Service\npublic class Producer {\n    @Resource\n    private JmsMessagingTemplate jmsMessagingTemplate;\n\n    public void sendMsg(String destName, String message) {\n        Destination destination = new ActiveMQQueue(destName);\n        jmsMessagingTemplate.convertAndSend(destination, message);\n    }\n}\n\n```\n\n## 消费者\n\n```\n@Service\npublic class Consumer {\n    @JmsListener(destination = \"test.queue\")\n    public void receiveMsg(String text) {\n        System.out.println(\">>>>->>>收到消息:\" + text);\n    }\n}\n```\n\n## 发布者\n\n```\n@Service\npublic class Publisher {\n    @Resource\n    private JmsMessagingTemplate jmsMessagingTemplate;\n\n    public void publish(String destName, String message) {\n        Destination destination = new ActiveMQTopic(destName);\n\n        jmsMessagingTemplate.convertAndSend(destination, message);\n    }\n}\n```\n\n## 订阅者\n\n```\n@Service\npublic class Subscriber {\n    @JmsListener(destination = \"test.topic\", containerFactory = \"myJmsContainerFactory\")\n    public void subscribe(String text) {\n        System.out.println(\"===<<<<收到订阅消息:\" + text);\n    }\n\n    @Bean\n    JmsListenerContainerFactory myJmsContainerFactory(ConnectionFactory connectionFactory) {\n        SimpleJmsListenerContainerFactory factory = new SimpleJmsListenerContainerFactory();\n        factory.setConnectionFactory(connectionFactory);\n        factory.setPubSubDomain(true);\n        return factory;\n    }\n}\n```\n\n在pub/sub模式中，对消息的监听需要对containerFactory的配置\n\n> 代码参考[github地址](https://github.com/wangweiye01/activemq)\n","source":"_posts/activemq.md","raw":"---\ntitle: Spring Boot整合activemq\ndate: 2017-11-29 12:34:03\ntags:\n---\n# activemq安装\n\n## 下载\n\n[点击下载](http://activemq.apache.org/)\n\n## 解压启动\n\n```\ntar -zxvf apache-activemq-5.14.0-bin.tar.gz\n```\n进去bin目录 cd apache-activemq-5.14.0/bin 启动 ./activemq start\n\n## 打开web管理页面\n\n访问http://IP:8161/admin\n\n启动后，activeMQ会占用两个端口，一个是负责接收发送消息的tcp端口:61616，一个是基于web负责用户界面化管理的端口:8161。这两个端口可以在conf下面的xml中找到。http服务器使用了jetty\n\n# 项目集成activemq\n\n## 配置文件设置application.properties\n\n```\nspring.activemq.broker-url=tcp://localhost:61616 \nspring.activemq.user=admin \nspring.activemq.password=admin \nspring.activemq.pool.enabled=false\n```\n\n## 生产者\n```\n@Service\npublic class Producer {\n    @Resource\n    private JmsMessagingTemplate jmsMessagingTemplate;\n\n    public void sendMsg(String destName, String message) {\n        Destination destination = new ActiveMQQueue(destName);\n        jmsMessagingTemplate.convertAndSend(destination, message);\n    }\n}\n\n```\n\n## 消费者\n\n```\n@Service\npublic class Consumer {\n    @JmsListener(destination = \"test.queue\")\n    public void receiveMsg(String text) {\n        System.out.println(\">>>>->>>收到消息:\" + text);\n    }\n}\n```\n\n## 发布者\n\n```\n@Service\npublic class Publisher {\n    @Resource\n    private JmsMessagingTemplate jmsMessagingTemplate;\n\n    public void publish(String destName, String message) {\n        Destination destination = new ActiveMQTopic(destName);\n\n        jmsMessagingTemplate.convertAndSend(destination, message);\n    }\n}\n```\n\n## 订阅者\n\n```\n@Service\npublic class Subscriber {\n    @JmsListener(destination = \"test.topic\", containerFactory = \"myJmsContainerFactory\")\n    public void subscribe(String text) {\n        System.out.println(\"===<<<<收到订阅消息:\" + text);\n    }\n\n    @Bean\n    JmsListenerContainerFactory myJmsContainerFactory(ConnectionFactory connectionFactory) {\n        SimpleJmsListenerContainerFactory factory = new SimpleJmsListenerContainerFactory();\n        factory.setConnectionFactory(connectionFactory);\n        factory.setPubSubDomain(true);\n        return factory;\n    }\n}\n```\n\n在pub/sub模式中，对消息的监听需要对containerFactory的配置\n\n> 代码参考[github地址](https://github.com/wangweiye01/activemq)\n","slug":"activemq","published":1,"updated":"2019-12-24T02:00:57.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jvd00040j9kiqq6twc1","content":"<h1 id=\"activemq安装\"><a href=\"#activemq安装\" class=\"headerlink\" title=\"activemq安装\"></a>activemq安装</h1><h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p><a href=\"http://activemq.apache.org/\" target=\"_blank\" rel=\"noopener\">点击下载</a></p>\n<h2 id=\"解压启动\"><a href=\"#解压启动\" class=\"headerlink\" title=\"解压启动\"></a>解压启动</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf apache-activemq-5.14.0-bin.tar.gz</span><br></pre></td></tr></table></figure>\n<p>进去bin目录 cd apache-activemq-5.14.0/bin 启动 ./activemq start</p>\n<h2 id=\"打开web管理页面\"><a href=\"#打开web管理页面\" class=\"headerlink\" title=\"打开web管理页面\"></a>打开web管理页面</h2><p>访问<a href=\"http://IP:8161/admin\" target=\"_blank\" rel=\"noopener\">http://IP:8161/admin</a></p>\n<p>启动后，activeMQ会占用两个端口，一个是负责接收发送消息的tcp端口:61616，一个是基于web负责用户界面化管理的端口:8161。这两个端口可以在conf下面的xml中找到。http服务器使用了jetty</p>\n<h1 id=\"项目集成activemq\"><a href=\"#项目集成activemq\" class=\"headerlink\" title=\"项目集成activemq\"></a>项目集成activemq</h1><h2 id=\"配置文件设置application-properties\"><a href=\"#配置文件设置application-properties\" class=\"headerlink\" title=\"配置文件设置application.properties\"></a>配置文件设置application.properties</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.activemq.broker-url=tcp://localhost:61616 </span><br><span class=\"line\">spring.activemq.user=admin </span><br><span class=\"line\">spring.activemq.password=admin </span><br><span class=\"line\">spring.activemq.pool.enabled=false</span><br></pre></td></tr></table></figure>\n<h2 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class Producer &#123;</span><br><span class=\"line\">    @Resource</span><br><span class=\"line\">    private JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void sendMsg(String destName, String message) &#123;</span><br><span class=\"line\">        Destination destination = new ActiveMQQueue(destName);</span><br><span class=\"line\">        jmsMessagingTemplate.convertAndSend(destination, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class Consumer &#123;</span><br><span class=\"line\">    @JmsListener(destination = &quot;test.queue&quot;)</span><br><span class=\"line\">    public void receiveMsg(String text) &#123;</span><br><span class=\"line\">        System.out.println(&quot;&gt;&gt;&gt;&gt;-&gt;&gt;&gt;收到消息:&quot; + text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"发布者\"><a href=\"#发布者\" class=\"headerlink\" title=\"发布者\"></a>发布者</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class Publisher &#123;</span><br><span class=\"line\">    @Resource</span><br><span class=\"line\">    private JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void publish(String destName, String message) &#123;</span><br><span class=\"line\">        Destination destination = new ActiveMQTopic(destName);</span><br><span class=\"line\"></span><br><span class=\"line\">        jmsMessagingTemplate.convertAndSend(destination, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"订阅者\"><a href=\"#订阅者\" class=\"headerlink\" title=\"订阅者\"></a>订阅者</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class Subscriber &#123;</span><br><span class=\"line\">    @JmsListener(destination = &quot;test.topic&quot;, containerFactory = &quot;myJmsContainerFactory&quot;)</span><br><span class=\"line\">    public void subscribe(String text) &#123;</span><br><span class=\"line\">        System.out.println(&quot;===&lt;&lt;&lt;&lt;收到订阅消息:&quot; + text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    JmsListenerContainerFactory myJmsContainerFactory(ConnectionFactory connectionFactory) &#123;</span><br><span class=\"line\">        SimpleJmsListenerContainerFactory factory = new SimpleJmsListenerContainerFactory();</span><br><span class=\"line\">        factory.setConnectionFactory(connectionFactory);</span><br><span class=\"line\">        factory.setPubSubDomain(true);</span><br><span class=\"line\">        return factory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在pub/sub模式中，对消息的监听需要对containerFactory的配置</p>\n<blockquote>\n<p>代码参考<a href=\"https://github.com/wangweiye01/activemq\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"activemq安装\"><a href=\"#activemq安装\" class=\"headerlink\" title=\"activemq安装\"></a>activemq安装</h1><h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p><a href=\"http://activemq.apache.org/\" target=\"_blank\" rel=\"noopener\">点击下载</a></p>\n<h2 id=\"解压启动\"><a href=\"#解压启动\" class=\"headerlink\" title=\"解压启动\"></a>解压启动</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf apache-activemq-5.14.0-bin.tar.gz</span><br></pre></td></tr></table></figure>\n<p>进去bin目录 cd apache-activemq-5.14.0/bin 启动 ./activemq start</p>\n<h2 id=\"打开web管理页面\"><a href=\"#打开web管理页面\" class=\"headerlink\" title=\"打开web管理页面\"></a>打开web管理页面</h2><p>访问<a href=\"http://IP:8161/admin\" target=\"_blank\" rel=\"noopener\">http://IP:8161/admin</a></p>\n<p>启动后，activeMQ会占用两个端口，一个是负责接收发送消息的tcp端口:61616，一个是基于web负责用户界面化管理的端口:8161。这两个端口可以在conf下面的xml中找到。http服务器使用了jetty</p>\n<h1 id=\"项目集成activemq\"><a href=\"#项目集成activemq\" class=\"headerlink\" title=\"项目集成activemq\"></a>项目集成activemq</h1><h2 id=\"配置文件设置application-properties\"><a href=\"#配置文件设置application-properties\" class=\"headerlink\" title=\"配置文件设置application.properties\"></a>配置文件设置application.properties</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.activemq.broker-url=tcp://localhost:61616 </span><br><span class=\"line\">spring.activemq.user=admin </span><br><span class=\"line\">spring.activemq.password=admin </span><br><span class=\"line\">spring.activemq.pool.enabled=false</span><br></pre></td></tr></table></figure>\n<h2 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class Producer &#123;</span><br><span class=\"line\">    @Resource</span><br><span class=\"line\">    private JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void sendMsg(String destName, String message) &#123;</span><br><span class=\"line\">        Destination destination = new ActiveMQQueue(destName);</span><br><span class=\"line\">        jmsMessagingTemplate.convertAndSend(destination, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class Consumer &#123;</span><br><span class=\"line\">    @JmsListener(destination = &quot;test.queue&quot;)</span><br><span class=\"line\">    public void receiveMsg(String text) &#123;</span><br><span class=\"line\">        System.out.println(&quot;&gt;&gt;&gt;&gt;-&gt;&gt;&gt;收到消息:&quot; + text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"发布者\"><a href=\"#发布者\" class=\"headerlink\" title=\"发布者\"></a>发布者</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class Publisher &#123;</span><br><span class=\"line\">    @Resource</span><br><span class=\"line\">    private JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void publish(String destName, String message) &#123;</span><br><span class=\"line\">        Destination destination = new ActiveMQTopic(destName);</span><br><span class=\"line\"></span><br><span class=\"line\">        jmsMessagingTemplate.convertAndSend(destination, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"订阅者\"><a href=\"#订阅者\" class=\"headerlink\" title=\"订阅者\"></a>订阅者</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class Subscriber &#123;</span><br><span class=\"line\">    @JmsListener(destination = &quot;test.topic&quot;, containerFactory = &quot;myJmsContainerFactory&quot;)</span><br><span class=\"line\">    public void subscribe(String text) &#123;</span><br><span class=\"line\">        System.out.println(&quot;===&lt;&lt;&lt;&lt;收到订阅消息:&quot; + text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    JmsListenerContainerFactory myJmsContainerFactory(ConnectionFactory connectionFactory) &#123;</span><br><span class=\"line\">        SimpleJmsListenerContainerFactory factory = new SimpleJmsListenerContainerFactory();</span><br><span class=\"line\">        factory.setConnectionFactory(connectionFactory);</span><br><span class=\"line\">        factory.setPubSubDomain(true);</span><br><span class=\"line\">        return factory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在pub/sub模式中，对消息的监听需要对containerFactory的配置</p>\n<blockquote>\n<p>代码参考<a href=\"https://github.com/wangweiye01/activemq\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n</blockquote>\n"},{"title":"如何保持数据库和缓存的一致性","date":"2017-11-30T14:45:06.000Z","_content":"# 更新缓存策略\n\n- 失效：应用程序从cache取数据，没有得到，则从数据库取数据，然后将数据放入cache \n- 命中：应用从cache取数据，若取到则返回 \n- 更新：把数据更新到数据库，然后使cache失效\n\n借用网上两张图 \n![](http://img.blog.csdn.net/20170726111231331?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![](http://img.blog.csdn.net/20170726111304065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n# 有没有其他策略?\n\n读操作容易理解，现在讨论一下写的操作\n\n## 如果先使cache失效，后更新数据库，是否可行\n\n这么做引发的问题是，如果A,B两个线程同时要更新数据，并且A,B已经都做完了删除缓存这一步，接下来，A先更新了数据库，C线程读取数据，由于缓存没有，则查数据库，并把A更新的数据，写入了缓存，最后B更新数据库。那么缓存和数据库的值就不一致了。\n\n## 如果先把数据库更新，然后把cache更新（不是失效），是否可行\n\n这么做引发的问题是，如果A,B两个线程同时做数据更新，A先更新了数据库，B后更新数据库，则此时数据库里存的是B的数据。而更新缓存的时候，是B先更新了缓存，而A后更新了缓存，则缓存里是A的数据。这样缓存和数据库的数据也不一致。\n\n## 如果更新数据时，更新数据库成功，而失效cache时失败怎么解决？\n\n- 对删除缓存进行重试，数据的一致性要求越高，我越是重试得快。 \n- 定期全量更新，简单地说，就是我定期把缓存全部清掉，然后再全量加载。 \n- 给所有的缓存一个失效期。（绝招，任何不一致，都可以靠失效期解决，失效期越短，数据一致性越高。但是失效期越短，查数据库就会越频繁。因此失效期应该根据业务来定）\n\n**不要缓存那些对数据一致性要求很高的数据**\n","source":"_posts/cache-db.md","raw":"---\ntitle: 如何保持数据库和缓存的一致性\ndate: 2017-11-30 22:45:06\ntags:\n---\n# 更新缓存策略\n\n- 失效：应用程序从cache取数据，没有得到，则从数据库取数据，然后将数据放入cache \n- 命中：应用从cache取数据，若取到则返回 \n- 更新：把数据更新到数据库，然后使cache失效\n\n借用网上两张图 \n![](http://img.blog.csdn.net/20170726111231331?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![](http://img.blog.csdn.net/20170726111304065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n# 有没有其他策略?\n\n读操作容易理解，现在讨论一下写的操作\n\n## 如果先使cache失效，后更新数据库，是否可行\n\n这么做引发的问题是，如果A,B两个线程同时要更新数据，并且A,B已经都做完了删除缓存这一步，接下来，A先更新了数据库，C线程读取数据，由于缓存没有，则查数据库，并把A更新的数据，写入了缓存，最后B更新数据库。那么缓存和数据库的值就不一致了。\n\n## 如果先把数据库更新，然后把cache更新（不是失效），是否可行\n\n这么做引发的问题是，如果A,B两个线程同时做数据更新，A先更新了数据库，B后更新数据库，则此时数据库里存的是B的数据。而更新缓存的时候，是B先更新了缓存，而A后更新了缓存，则缓存里是A的数据。这样缓存和数据库的数据也不一致。\n\n## 如果更新数据时，更新数据库成功，而失效cache时失败怎么解决？\n\n- 对删除缓存进行重试，数据的一致性要求越高，我越是重试得快。 \n- 定期全量更新，简单地说，就是我定期把缓存全部清掉，然后再全量加载。 \n- 给所有的缓存一个失效期。（绝招，任何不一致，都可以靠失效期解决，失效期越短，数据一致性越高。但是失效期越短，查数据库就会越频繁。因此失效期应该根据业务来定）\n\n**不要缓存那些对数据一致性要求很高的数据**\n","slug":"cache-db","published":1,"updated":"2019-12-24T02:00:57.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jvf00050j9kvt31e09o","content":"<h1 id=\"更新缓存策略\"><a href=\"#更新缓存策略\" class=\"headerlink\" title=\"更新缓存策略\"></a>更新缓存策略</h1><ul>\n<li>失效：应用程序从cache取数据，没有得到，则从数据库取数据，然后将数据放入cache </li>\n<li>命中：应用从cache取数据，若取到则返回 </li>\n<li>更新：把数据更新到数据库，然后使cache失效</li>\n</ul>\n<p>借用网上两张图<br><img src=\"http://img.blog.csdn.net/20170726111231331?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170726111304065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<h1 id=\"有没有其他策略\"><a href=\"#有没有其他策略\" class=\"headerlink\" title=\"有没有其他策略?\"></a>有没有其他策略?</h1><p>读操作容易理解，现在讨论一下写的操作</p>\n<h2 id=\"如果先使cache失效，后更新数据库，是否可行\"><a href=\"#如果先使cache失效，后更新数据库，是否可行\" class=\"headerlink\" title=\"如果先使cache失效，后更新数据库，是否可行\"></a>如果先使cache失效，后更新数据库，是否可行</h2><p>这么做引发的问题是，如果A,B两个线程同时要更新数据，并且A,B已经都做完了删除缓存这一步，接下来，A先更新了数据库，C线程读取数据，由于缓存没有，则查数据库，并把A更新的数据，写入了缓存，最后B更新数据库。那么缓存和数据库的值就不一致了。</p>\n<h2 id=\"如果先把数据库更新，然后把cache更新（不是失效），是否可行\"><a href=\"#如果先把数据库更新，然后把cache更新（不是失效），是否可行\" class=\"headerlink\" title=\"如果先把数据库更新，然后把cache更新（不是失效），是否可行\"></a>如果先把数据库更新，然后把cache更新（不是失效），是否可行</h2><p>这么做引发的问题是，如果A,B两个线程同时做数据更新，A先更新了数据库，B后更新数据库，则此时数据库里存的是B的数据。而更新缓存的时候，是B先更新了缓存，而A后更新了缓存，则缓存里是A的数据。这样缓存和数据库的数据也不一致。</p>\n<h2 id=\"如果更新数据时，更新数据库成功，而失效cache时失败怎么解决？\"><a href=\"#如果更新数据时，更新数据库成功，而失效cache时失败怎么解决？\" class=\"headerlink\" title=\"如果更新数据时，更新数据库成功，而失效cache时失败怎么解决？\"></a>如果更新数据时，更新数据库成功，而失效cache时失败怎么解决？</h2><ul>\n<li>对删除缓存进行重试，数据的一致性要求越高，我越是重试得快。 </li>\n<li>定期全量更新，简单地说，就是我定期把缓存全部清掉，然后再全量加载。 </li>\n<li>给所有的缓存一个失效期。（绝招，任何不一致，都可以靠失效期解决，失效期越短，数据一致性越高。但是失效期越短，查数据库就会越频繁。因此失效期应该根据业务来定）</li>\n</ul>\n<p><strong>不要缓存那些对数据一致性要求很高的数据</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"更新缓存策略\"><a href=\"#更新缓存策略\" class=\"headerlink\" title=\"更新缓存策略\"></a>更新缓存策略</h1><ul>\n<li>失效：应用程序从cache取数据，没有得到，则从数据库取数据，然后将数据放入cache </li>\n<li>命中：应用从cache取数据，若取到则返回 </li>\n<li>更新：把数据更新到数据库，然后使cache失效</li>\n</ul>\n<p>借用网上两张图<br><img src=\"http://img.blog.csdn.net/20170726111231331?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170726111304065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<h1 id=\"有没有其他策略\"><a href=\"#有没有其他策略\" class=\"headerlink\" title=\"有没有其他策略?\"></a>有没有其他策略?</h1><p>读操作容易理解，现在讨论一下写的操作</p>\n<h2 id=\"如果先使cache失效，后更新数据库，是否可行\"><a href=\"#如果先使cache失效，后更新数据库，是否可行\" class=\"headerlink\" title=\"如果先使cache失效，后更新数据库，是否可行\"></a>如果先使cache失效，后更新数据库，是否可行</h2><p>这么做引发的问题是，如果A,B两个线程同时要更新数据，并且A,B已经都做完了删除缓存这一步，接下来，A先更新了数据库，C线程读取数据，由于缓存没有，则查数据库，并把A更新的数据，写入了缓存，最后B更新数据库。那么缓存和数据库的值就不一致了。</p>\n<h2 id=\"如果先把数据库更新，然后把cache更新（不是失效），是否可行\"><a href=\"#如果先把数据库更新，然后把cache更新（不是失效），是否可行\" class=\"headerlink\" title=\"如果先把数据库更新，然后把cache更新（不是失效），是否可行\"></a>如果先把数据库更新，然后把cache更新（不是失效），是否可行</h2><p>这么做引发的问题是，如果A,B两个线程同时做数据更新，A先更新了数据库，B后更新数据库，则此时数据库里存的是B的数据。而更新缓存的时候，是B先更新了缓存，而A后更新了缓存，则缓存里是A的数据。这样缓存和数据库的数据也不一致。</p>\n<h2 id=\"如果更新数据时，更新数据库成功，而失效cache时失败怎么解决？\"><a href=\"#如果更新数据时，更新数据库成功，而失效cache时失败怎么解决？\" class=\"headerlink\" title=\"如果更新数据时，更新数据库成功，而失效cache时失败怎么解决？\"></a>如果更新数据时，更新数据库成功，而失效cache时失败怎么解决？</h2><ul>\n<li>对删除缓存进行重试，数据的一致性要求越高，我越是重试得快。 </li>\n<li>定期全量更新，简单地说，就是我定期把缓存全部清掉，然后再全量加载。 </li>\n<li>给所有的缓存一个失效期。（绝招，任何不一致，都可以靠失效期解决，失效期越短，数据一致性越高。但是失效期越短，查数据库就会越频繁。因此失效期应该根据业务来定）</li>\n</ul>\n<p><strong>不要缓存那些对数据一致性要求很高的数据</strong></p>\n"},{"title":"常见网络攻击及处理办法","date":"2017-11-29T03:35:30.000Z","_content":"\n# 跨站请求伪造(CSRF)\n\n## 原理\n\n危害是攻击者可以盗用你的身份，以你的名义发送恶意请求。比如可以盗取你的账号，以你的身份发送邮件，购买商品等\n\n## 例子\n\n在某个论坛管理页面，管理员可以在list.php页面执行删除帖子操作，根据URL判断删除帖子的id，像这样的一个URL\n\n```\nhttp://localhost/list.php?action=delete&id=12\n```\n\n当恶意用户想管理员发送包含CSFR的邮件，骗取管理员访问 http://test.com/csrf.php 在这个恶意网页中只要包含这样的html语句就可以利用让管理员在不知\n情的情况下删除帖子了\n```\n<img alt=\"\" src=\"http://localhost/list.php?action=delete&id=12\"/>\n```\n\n## 使用post修改信息就安全了么？\n\n```\n<?php\n$action=$_POST['action'];\n$id=$_POST['id'];\ndelete($action,$id);\n?>\n```\n同样可以攻击\n```\n<!DOCTYPE html>\n<html>\n　　<body>\n　　　　<iframe display=\"none\">\n　　　　　　<form method=\"post\" action=\"http://localhost/list.php\">\n　　　　　　　　<input type=\"hidden\" name=\"action\" value=\"delete\">\n　　　　　　　 <input type=\"hidden\" name=\"id\" value=\"12\">\n<input id=\"csfr\" type=\"submit\"/>\n　　　　　　</form>\n　　　　</iframe>\n\n<script type=\"text/javascript\">\n　　　　 document.getElementById('csfr').submit();\n　　　　</script>\n　　</body>\n</html>\n```\n\n## 如何防范\n\n1. 使用post，不使用get修改信息\n2. 验证码，所有表单的提交需要验证码，但是貌似用起来很麻烦，所以一些关键的操作可以\n3. 在表单中预先植入一些加密信息，验证请求是此表单发送\n\n# 跨站脚本攻击(XSS)\n\n## 原理\n\n跨站脚本攻击(Cross Site Script为了区别于CSS简称为XSS)指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的htm\nl代码会被执行，从而达到恶意用户的特殊目的\n\n## 例子\n\n我们有个页面用于允许用户发表留言，然后在页面底部显示留言列表\n```\n<!DOCTYPE html>\n<html>\n<head>\n<?php include('/components/headerinclude.php');?></head>\n<style type=\"text/css\">\n.comment-title{\n    font-size:14px;\nmargin: 6px 0px 2px 4px;\n}\n\n.comment-body{\n    font-size: 14px;\ncolor:#ccc;\n      font-style: italic;\n      border-bottom: dashed 1px #ccc;\nmargin: 4px;\n}\n</style>\n<script type=\"text/javascript\" src=\"/js/cookies.js\"></script>\n<body>\n<form method=\"post\" action=\"list.php\">\n<div style=\"margin:20px;\">\n<div style=\"font-size:16px;font-weight:bold;\">Your Comment</div>\n<div style=\"padding:6px;\">\nNick Name:\n<br/>\n<input name=\"name\" type=\"text\" style=\"width:300px;\"/>\n</div>\n<div style=\"padding:6px;\">\nComment:\n<br/>\n<textarea name=\"comment\" style=\"height:100px; width:300px;\"></textarea>\n</div>\n<div style=\"padding-left:230px;\">\n<input type=\"submit\" value=\"POST\" style=\"padding:4px 0px; width:80px;\"/>\n</div>\n<div style=\"border-bottom:solid 1px #fff;margin-top:10px;\">\n<div style=\"font-size:16px;font-weight:bold;\">Comments</div>\n</div>\n<?php \nrequire('/components/comments.php'); \nif(!empty($_POST['name'])){\n    addElement($_POST['name'],$_POST['comment']);\n}\nrenderComments();\n?>\n</div>\n</form>\n</body>\n</html>\n```\naddElement()方法用于添加新的留言，而renderComments()方法用于展留言列表，网页看起来是这样的\n![](http://img.blog.csdn.net/20171008105555518?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n因为我们完全信任了用户输入，但有些别有用心的用户会像这样的输入\n![](http://img.blog.csdn.net/20171008104916455?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n这样无论是谁访问这个页面的时候控制台都会输出“Hey you are a fool fish!”，如果这只是个恶意的小玩笑，有些人做的事情就不可爱了，有些用户会利用\n这个漏洞窃取用户信息、诱骗人打开恶意网站或者下载恶意程序等\n\n## 如何防范\n\n上面演示的是一个非常简单的XSS攻击，还有很多隐蔽的方式，但是其核心都是利用了脚本注入，因此我们解决办法其实很简单，不信赖用户输入，对特殊字符如”<”,”>”转义，就可以从根本上防止这一问题，当然很多解决方案都对XSS做了特定限制，如上面这中做法在ASP.NET中不幸不同，微软validateRequest对表单提交自动做了XSS验证。但防不胜防，总有些聪明的恶意用户会到我们的网站搞破坏，对自己站点不放心可以看看这个[XSS跨站测试代码大全](http://www.cnblogs.com/dsky/archive/2012/04/06/2434768.html)试试站点是否安全。\n\n","source":"_posts/defent.md","raw":"---\ntitle: 常见网络攻击及处理办法\ndate: 2017-11-29 11:35:30\ntags:\n---\n\n# 跨站请求伪造(CSRF)\n\n## 原理\n\n危害是攻击者可以盗用你的身份，以你的名义发送恶意请求。比如可以盗取你的账号，以你的身份发送邮件，购买商品等\n\n## 例子\n\n在某个论坛管理页面，管理员可以在list.php页面执行删除帖子操作，根据URL判断删除帖子的id，像这样的一个URL\n\n```\nhttp://localhost/list.php?action=delete&id=12\n```\n\n当恶意用户想管理员发送包含CSFR的邮件，骗取管理员访问 http://test.com/csrf.php 在这个恶意网页中只要包含这样的html语句就可以利用让管理员在不知\n情的情况下删除帖子了\n```\n<img alt=\"\" src=\"http://localhost/list.php?action=delete&id=12\"/>\n```\n\n## 使用post修改信息就安全了么？\n\n```\n<?php\n$action=$_POST['action'];\n$id=$_POST['id'];\ndelete($action,$id);\n?>\n```\n同样可以攻击\n```\n<!DOCTYPE html>\n<html>\n　　<body>\n　　　　<iframe display=\"none\">\n　　　　　　<form method=\"post\" action=\"http://localhost/list.php\">\n　　　　　　　　<input type=\"hidden\" name=\"action\" value=\"delete\">\n　　　　　　　 <input type=\"hidden\" name=\"id\" value=\"12\">\n<input id=\"csfr\" type=\"submit\"/>\n　　　　　　</form>\n　　　　</iframe>\n\n<script type=\"text/javascript\">\n　　　　 document.getElementById('csfr').submit();\n　　　　</script>\n　　</body>\n</html>\n```\n\n## 如何防范\n\n1. 使用post，不使用get修改信息\n2. 验证码，所有表单的提交需要验证码，但是貌似用起来很麻烦，所以一些关键的操作可以\n3. 在表单中预先植入一些加密信息，验证请求是此表单发送\n\n# 跨站脚本攻击(XSS)\n\n## 原理\n\n跨站脚本攻击(Cross Site Script为了区别于CSS简称为XSS)指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的htm\nl代码会被执行，从而达到恶意用户的特殊目的\n\n## 例子\n\n我们有个页面用于允许用户发表留言，然后在页面底部显示留言列表\n```\n<!DOCTYPE html>\n<html>\n<head>\n<?php include('/components/headerinclude.php');?></head>\n<style type=\"text/css\">\n.comment-title{\n    font-size:14px;\nmargin: 6px 0px 2px 4px;\n}\n\n.comment-body{\n    font-size: 14px;\ncolor:#ccc;\n      font-style: italic;\n      border-bottom: dashed 1px #ccc;\nmargin: 4px;\n}\n</style>\n<script type=\"text/javascript\" src=\"/js/cookies.js\"></script>\n<body>\n<form method=\"post\" action=\"list.php\">\n<div style=\"margin:20px;\">\n<div style=\"font-size:16px;font-weight:bold;\">Your Comment</div>\n<div style=\"padding:6px;\">\nNick Name:\n<br/>\n<input name=\"name\" type=\"text\" style=\"width:300px;\"/>\n</div>\n<div style=\"padding:6px;\">\nComment:\n<br/>\n<textarea name=\"comment\" style=\"height:100px; width:300px;\"></textarea>\n</div>\n<div style=\"padding-left:230px;\">\n<input type=\"submit\" value=\"POST\" style=\"padding:4px 0px; width:80px;\"/>\n</div>\n<div style=\"border-bottom:solid 1px #fff;margin-top:10px;\">\n<div style=\"font-size:16px;font-weight:bold;\">Comments</div>\n</div>\n<?php \nrequire('/components/comments.php'); \nif(!empty($_POST['name'])){\n    addElement($_POST['name'],$_POST['comment']);\n}\nrenderComments();\n?>\n</div>\n</form>\n</body>\n</html>\n```\naddElement()方法用于添加新的留言，而renderComments()方法用于展留言列表，网页看起来是这样的\n![](http://img.blog.csdn.net/20171008105555518?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n因为我们完全信任了用户输入，但有些别有用心的用户会像这样的输入\n![](http://img.blog.csdn.net/20171008104916455?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n这样无论是谁访问这个页面的时候控制台都会输出“Hey you are a fool fish!”，如果这只是个恶意的小玩笑，有些人做的事情就不可爱了，有些用户会利用\n这个漏洞窃取用户信息、诱骗人打开恶意网站或者下载恶意程序等\n\n## 如何防范\n\n上面演示的是一个非常简单的XSS攻击，还有很多隐蔽的方式，但是其核心都是利用了脚本注入，因此我们解决办法其实很简单，不信赖用户输入，对特殊字符如”<”,”>”转义，就可以从根本上防止这一问题，当然很多解决方案都对XSS做了特定限制，如上面这中做法在ASP.NET中不幸不同，微软validateRequest对表单提交自动做了XSS验证。但防不胜防，总有些聪明的恶意用户会到我们的网站搞破坏，对自己站点不放心可以看看这个[XSS跨站测试代码大全](http://www.cnblogs.com/dsky/archive/2012/04/06/2434768.html)试试站点是否安全。\n\n","slug":"defent","published":1,"updated":"2019-12-24T02:00:57.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jvg00060j9krkkrqecu","content":"<h1 id=\"跨站请求伪造-CSRF\"><a href=\"#跨站请求伪造-CSRF\" class=\"headerlink\" title=\"跨站请求伪造(CSRF)\"></a>跨站请求伪造(CSRF)</h1><h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>危害是攻击者可以盗用你的身份，以你的名义发送恶意请求。比如可以盗取你的账号，以你的身份发送邮件，购买商品等</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>在某个论坛管理页面，管理员可以在list.php页面执行删除帖子操作，根据URL判断删除帖子的id，像这样的一个URL</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost/list.php?action=delete&amp;id=12</span><br></pre></td></tr></table></figure>\n<p>当恶意用户想管理员发送包含CSFR的邮件，骗取管理员访问 <a href=\"http://test.com/csrf.php\" target=\"_blank\" rel=\"noopener\">http://test.com/csrf.php</a> 在这个恶意网页中只要包含这样的html语句就可以利用让管理员在不知<br>情的情况下删除帖子了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img alt=&quot;&quot; src=&quot;http://localhost/list.php?action=delete&amp;id=12&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用post修改信息就安全了么？\"><a href=\"#使用post修改信息就安全了么？\" class=\"headerlink\" title=\"使用post修改信息就安全了么？\"></a>使用post修改信息就安全了么？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">$action=$_POST[&apos;action&apos;];</span><br><span class=\"line\">$id=$_POST[&apos;id&apos;];</span><br><span class=\"line\">delete($action,$id);</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<p>同样可以攻击<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">　　&lt;body&gt;</span><br><span class=\"line\">　　　　&lt;iframe display=&quot;none&quot;&gt;</span><br><span class=\"line\">　　　　　　&lt;form method=&quot;post&quot; action=&quot;http://localhost/list.php&quot;&gt;</span><br><span class=\"line\">　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;delete&quot;&gt;</span><br><span class=\"line\">　　　　　　　 &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;12&quot;&gt;</span><br><span class=\"line\">&lt;input id=&quot;csfr&quot; type=&quot;submit&quot;/&gt;</span><br><span class=\"line\">　　　　　　&lt;/form&gt;</span><br><span class=\"line\">　　　　&lt;/iframe&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">　　　　 document.getElementById(&apos;csfr&apos;).submit();</span><br><span class=\"line\">　　　　&lt;/script&gt;</span><br><span class=\"line\">　　&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"如何防范\"><a href=\"#如何防范\" class=\"headerlink\" title=\"如何防范\"></a>如何防范</h2><ol>\n<li>使用post，不使用get修改信息</li>\n<li>验证码，所有表单的提交需要验证码，但是貌似用起来很麻烦，所以一些关键的操作可以</li>\n<li>在表单中预先植入一些加密信息，验证请求是此表单发送</li>\n</ol>\n<h1 id=\"跨站脚本攻击-XSS\"><a href=\"#跨站脚本攻击-XSS\" class=\"headerlink\" title=\"跨站脚本攻击(XSS)\"></a>跨站脚本攻击(XSS)</h1><h2 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>跨站脚本攻击(Cross Site Script为了区别于CSS简称为XSS)指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的htm<br>l代码会被执行，从而达到恶意用户的特殊目的</p>\n<h2 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>我们有个页面用于允许用户发表留言，然后在页面底部显示留言列表<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;?php include(&apos;/components/headerinclude.php&apos;);?&gt;&lt;/head&gt;</span><br><span class=\"line\">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">.comment-title&#123;</span><br><span class=\"line\">    font-size:14px;</span><br><span class=\"line\">margin: 6px 0px 2px 4px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.comment-body&#123;</span><br><span class=\"line\">    font-size: 14px;</span><br><span class=\"line\">color:#ccc;</span><br><span class=\"line\">      font-style: italic;</span><br><span class=\"line\">      border-bottom: dashed 1px #ccc;</span><br><span class=\"line\">margin: 4px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/cookies.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;form method=&quot;post&quot; action=&quot;list.php&quot;&gt;</span><br><span class=\"line\">&lt;div style=&quot;margin:20px;&quot;&gt;</span><br><span class=\"line\">&lt;div style=&quot;font-size:16px;font-weight:bold;&quot;&gt;Your Comment&lt;/div&gt;</span><br><span class=\"line\">&lt;div style=&quot;padding:6px;&quot;&gt;</span><br><span class=\"line\">Nick Name:</span><br><span class=\"line\">&lt;br/&gt;</span><br><span class=\"line\">&lt;input name=&quot;name&quot; type=&quot;text&quot; style=&quot;width:300px;&quot;/&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div style=&quot;padding:6px;&quot;&gt;</span><br><span class=\"line\">Comment:</span><br><span class=\"line\">&lt;br/&gt;</span><br><span class=\"line\">&lt;textarea name=&quot;comment&quot; style=&quot;height:100px; width:300px;&quot;&gt;&lt;/textarea&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div style=&quot;padding-left:230px;&quot;&gt;</span><br><span class=\"line\">&lt;input type=&quot;submit&quot; value=&quot;POST&quot; style=&quot;padding:4px 0px; width:80px;&quot;/&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div style=&quot;border-bottom:solid 1px #fff;margin-top:10px;&quot;&gt;</span><br><span class=\"line\">&lt;div style=&quot;font-size:16px;font-weight:bold;&quot;&gt;Comments&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;?php </span><br><span class=\"line\">require(&apos;/components/comments.php&apos;); </span><br><span class=\"line\">if(!empty($_POST[&apos;name&apos;]))&#123;</span><br><span class=\"line\">    addElement($_POST[&apos;name&apos;],$_POST[&apos;comment&apos;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">renderComments();</span><br><span class=\"line\">?&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>addElement()方法用于添加新的留言，而renderComments()方法用于展留言列表，网页看起来是这样的<br><img src=\"http://img.blog.csdn.net/20171008105555518?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>因为我们完全信任了用户输入，但有些别有用心的用户会像这样的输入<br><img src=\"http://img.blog.csdn.net/20171008104916455?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>这样无论是谁访问这个页面的时候控制台都会输出“Hey you are a fool fish!”，如果这只是个恶意的小玩笑，有些人做的事情就不可爱了，有些用户会利用<br>这个漏洞窃取用户信息、诱骗人打开恶意网站或者下载恶意程序等</p>\n<h2 id=\"如何防范-1\"><a href=\"#如何防范-1\" class=\"headerlink\" title=\"如何防范\"></a>如何防范</h2><p>上面演示的是一个非常简单的XSS攻击，还有很多隐蔽的方式，但是其核心都是利用了脚本注入，因此我们解决办法其实很简单，不信赖用户输入，对特殊字符如”&lt;”,”&gt;”转义，就可以从根本上防止这一问题，当然很多解决方案都对XSS做了特定限制，如上面这中做法在ASP.NET中不幸不同，微软validateRequest对表单提交自动做了XSS验证。但防不胜防，总有些聪明的恶意用户会到我们的网站搞破坏，对自己站点不放心可以看看这个<a href=\"http://www.cnblogs.com/dsky/archive/2012/04/06/2434768.html\" target=\"_blank\" rel=\"noopener\">XSS跨站测试代码大全</a>试试站点是否安全。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"跨站请求伪造-CSRF\"><a href=\"#跨站请求伪造-CSRF\" class=\"headerlink\" title=\"跨站请求伪造(CSRF)\"></a>跨站请求伪造(CSRF)</h1><h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>危害是攻击者可以盗用你的身份，以你的名义发送恶意请求。比如可以盗取你的账号，以你的身份发送邮件，购买商品等</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>在某个论坛管理页面，管理员可以在list.php页面执行删除帖子操作，根据URL判断删除帖子的id，像这样的一个URL</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost/list.php?action=delete&amp;id=12</span><br></pre></td></tr></table></figure>\n<p>当恶意用户想管理员发送包含CSFR的邮件，骗取管理员访问 <a href=\"http://test.com/csrf.php\" target=\"_blank\" rel=\"noopener\">http://test.com/csrf.php</a> 在这个恶意网页中只要包含这样的html语句就可以利用让管理员在不知<br>情的情况下删除帖子了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img alt=&quot;&quot; src=&quot;http://localhost/list.php?action=delete&amp;id=12&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用post修改信息就安全了么？\"><a href=\"#使用post修改信息就安全了么？\" class=\"headerlink\" title=\"使用post修改信息就安全了么？\"></a>使用post修改信息就安全了么？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">$action=$_POST[&apos;action&apos;];</span><br><span class=\"line\">$id=$_POST[&apos;id&apos;];</span><br><span class=\"line\">delete($action,$id);</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<p>同样可以攻击<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">　　&lt;body&gt;</span><br><span class=\"line\">　　　　&lt;iframe display=&quot;none&quot;&gt;</span><br><span class=\"line\">　　　　　　&lt;form method=&quot;post&quot; action=&quot;http://localhost/list.php&quot;&gt;</span><br><span class=\"line\">　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;delete&quot;&gt;</span><br><span class=\"line\">　　　　　　　 &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;12&quot;&gt;</span><br><span class=\"line\">&lt;input id=&quot;csfr&quot; type=&quot;submit&quot;/&gt;</span><br><span class=\"line\">　　　　　　&lt;/form&gt;</span><br><span class=\"line\">　　　　&lt;/iframe&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">　　　　 document.getElementById(&apos;csfr&apos;).submit();</span><br><span class=\"line\">　　　　&lt;/script&gt;</span><br><span class=\"line\">　　&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"如何防范\"><a href=\"#如何防范\" class=\"headerlink\" title=\"如何防范\"></a>如何防范</h2><ol>\n<li>使用post，不使用get修改信息</li>\n<li>验证码，所有表单的提交需要验证码，但是貌似用起来很麻烦，所以一些关键的操作可以</li>\n<li>在表单中预先植入一些加密信息，验证请求是此表单发送</li>\n</ol>\n<h1 id=\"跨站脚本攻击-XSS\"><a href=\"#跨站脚本攻击-XSS\" class=\"headerlink\" title=\"跨站脚本攻击(XSS)\"></a>跨站脚本攻击(XSS)</h1><h2 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>跨站脚本攻击(Cross Site Script为了区别于CSS简称为XSS)指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的htm<br>l代码会被执行，从而达到恶意用户的特殊目的</p>\n<h2 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>我们有个页面用于允许用户发表留言，然后在页面底部显示留言列表<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;?php include(&apos;/components/headerinclude.php&apos;);?&gt;&lt;/head&gt;</span><br><span class=\"line\">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">.comment-title&#123;</span><br><span class=\"line\">    font-size:14px;</span><br><span class=\"line\">margin: 6px 0px 2px 4px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.comment-body&#123;</span><br><span class=\"line\">    font-size: 14px;</span><br><span class=\"line\">color:#ccc;</span><br><span class=\"line\">      font-style: italic;</span><br><span class=\"line\">      border-bottom: dashed 1px #ccc;</span><br><span class=\"line\">margin: 4px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/cookies.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;form method=&quot;post&quot; action=&quot;list.php&quot;&gt;</span><br><span class=\"line\">&lt;div style=&quot;margin:20px;&quot;&gt;</span><br><span class=\"line\">&lt;div style=&quot;font-size:16px;font-weight:bold;&quot;&gt;Your Comment&lt;/div&gt;</span><br><span class=\"line\">&lt;div style=&quot;padding:6px;&quot;&gt;</span><br><span class=\"line\">Nick Name:</span><br><span class=\"line\">&lt;br/&gt;</span><br><span class=\"line\">&lt;input name=&quot;name&quot; type=&quot;text&quot; style=&quot;width:300px;&quot;/&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div style=&quot;padding:6px;&quot;&gt;</span><br><span class=\"line\">Comment:</span><br><span class=\"line\">&lt;br/&gt;</span><br><span class=\"line\">&lt;textarea name=&quot;comment&quot; style=&quot;height:100px; width:300px;&quot;&gt;&lt;/textarea&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div style=&quot;padding-left:230px;&quot;&gt;</span><br><span class=\"line\">&lt;input type=&quot;submit&quot; value=&quot;POST&quot; style=&quot;padding:4px 0px; width:80px;&quot;/&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div style=&quot;border-bottom:solid 1px #fff;margin-top:10px;&quot;&gt;</span><br><span class=\"line\">&lt;div style=&quot;font-size:16px;font-weight:bold;&quot;&gt;Comments&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;?php </span><br><span class=\"line\">require(&apos;/components/comments.php&apos;); </span><br><span class=\"line\">if(!empty($_POST[&apos;name&apos;]))&#123;</span><br><span class=\"line\">    addElement($_POST[&apos;name&apos;],$_POST[&apos;comment&apos;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">renderComments();</span><br><span class=\"line\">?&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>addElement()方法用于添加新的留言，而renderComments()方法用于展留言列表，网页看起来是这样的<br><img src=\"http://img.blog.csdn.net/20171008105555518?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>因为我们完全信任了用户输入，但有些别有用心的用户会像这样的输入<br><img src=\"http://img.blog.csdn.net/20171008104916455?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>这样无论是谁访问这个页面的时候控制台都会输出“Hey you are a fool fish!”，如果这只是个恶意的小玩笑，有些人做的事情就不可爱了，有些用户会利用<br>这个漏洞窃取用户信息、诱骗人打开恶意网站或者下载恶意程序等</p>\n<h2 id=\"如何防范-1\"><a href=\"#如何防范-1\" class=\"headerlink\" title=\"如何防范\"></a>如何防范</h2><p>上面演示的是一个非常简单的XSS攻击，还有很多隐蔽的方式，但是其核心都是利用了脚本注入，因此我们解决办法其实很简单，不信赖用户输入，对特殊字符如”&lt;”,”&gt;”转义，就可以从根本上防止这一问题，当然很多解决方案都对XSS做了特定限制，如上面这中做法在ASP.NET中不幸不同，微软validateRequest对表单提交自动做了XSS验证。但防不胜防，总有些聪明的恶意用户会到我们的网站搞破坏，对自己站点不放心可以看看这个<a href=\"http://www.cnblogs.com/dsky/archive/2012/04/06/2434768.html\" target=\"_blank\" rel=\"noopener\">XSS跨站测试代码大全</a>试试站点是否安全。</p>\n"},{"title":"分布式锁","date":"2019-02-13T01:52:28.000Z","_content":"\n# 基本概念\n\n目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。\n\n在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如`分布式事务`、`分布式锁`等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，Java中其实提供了很多并发处理相关的API，但是这些API在分布式场景中就无能为力了。也就是说单纯的Java Api并不能提供分布式锁的能力。\n\n# 分布式锁应该具备的条件\n\n1. 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行;\n2. 高可用的获取锁与释放锁;\n3. 高性能的获取锁与释放锁;\n4. 具备可重入特性;\n5. 具备锁失效机制，防止死锁;\n6. 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。\n\n# 基于Redis的实现方式\n\n## Redis命令介绍\n\n- `SETNX key val` 当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0\n- `expire key timeout` 为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁\n- `delete key` 删除key\n\n## 实现思想\n\n1. 获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID（用来标识一次网络请求）\n2. 获取锁的时候还设置一个超时时间，若超过这个时间则放弃锁\n3. 释放锁的时候，通过UUID判断是不是该锁，若是，则执行delete进行释放\n\n## Redis操作工具类\n\n``` java\nimport redis.clients.jedis.Jedis;\n\nimport java.util.Collections;\n\npublic class RedisTool {\n\n    private static final String LOCK_SUCCESS = \"OK\";\n    private static final String SET_IF_NOT_EXIST = \"NX\";\n    private static final String SET_WITH_EXPIRE_TIME = \"PX\";\n\n    /**\n     * 尝试获取分布式锁\n     *\n     * @param jedis      Redis客户端\n     * @param lockKey    锁\n     * @param requestId  请求标识\n     * @param expireTime 超期时间\n     * @return 是否获取成功\n     */\n    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {\n\n        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);\n\n        if (LOCK_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n    }\n\n    private static final Long RELEASE_SUCCESS = 1L;\n\n    /**\n     * 释放分布式锁\n     *\n     * @param jedis     Redis客户端\n     * @param lockKey   锁\n     * @param requestId 请求标识\n     * @return 是否释放成功\n     */\n    public boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {\n\n        String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\";\n        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));\n\n        if (RELEASE_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n\n    }\n}\n```\n\n## 需要加锁的业务逻辑实现\n\n``` java\nimport cc.wangweiye.distributelock.DistributedLock;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport java.util.UUID;\n\npublic class Service2 {\n\n    private static JedisPool pool = null;\n    private RedisTool lock = new RedisTool();\n\n    int n = 500;\n\n    static {\n        JedisPoolConfig config = new JedisPoolConfig();\n        // 设置最大连接数\n        config.setMaxTotal(500);\n        // 设置最大空闲数\n        config.setMaxIdle(8);\n        // 设置最大等待时间\n        config.setMaxWaitMillis(1000 * 100);\n        // 在borrow一个jedis实例时，是否需要验证，若为true，则所有jedis实例均是可用的\n        config.setTestOnBorrow(true);\n        pool = new JedisPool(config, \"127.0.0.1\", 6379, 3000);\n    }\n\n    public void seckill() {\n        Jedis jedis = pool.getResource();\n        // 返回锁的value值，供释放锁时候进行判断\n        String uuid = UUID.randomUUID().toString();\n\n        while (true) {\n            boolean locked = lock.tryGetDistributedLock(jedis, \"resource\", uuid, 500);\n\n            if (locked) {\n                System.out.println(Thread.currentThread().getName() + \"获得了锁\");\n                System.out.println(--n);\n                break;\n            }\n        }\n\n        lock.releaseDistributedLock(jedis, \"resource\", uuid);\n    }\n}\n```\n\n## 线程执行逻辑\n\n``` java\npublic class ThreadB extends Thread {\n    private Service2 service2;\n\n    public ThreadB(Service2 service2) {\n        this.service2 = service2;\n    }\n\n    @Override\n    public void run() {\n        service2.seckill();\n    }\n}\n```\n\n## 测试代码\n\n``` java\npublic class Test2 {\n    public static void main(String[] args) {\n        Service2 service2 = new Service2();\n        for (int i = 0; i < 499; i++) {\n            ThreadB threadB = new ThreadB(service2);\n            threadB.start();\n        }\n    }\n}\n```\n","source":"_posts/distribute-lock.md","raw":"---\ntitle: 分布式锁\ndate: 2019-02-13 09:52:28\ntags:\n---\n\n# 基本概念\n\n目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。\n\n在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如`分布式事务`、`分布式锁`等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，Java中其实提供了很多并发处理相关的API，但是这些API在分布式场景中就无能为力了。也就是说单纯的Java Api并不能提供分布式锁的能力。\n\n# 分布式锁应该具备的条件\n\n1. 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行;\n2. 高可用的获取锁与释放锁;\n3. 高性能的获取锁与释放锁;\n4. 具备可重入特性;\n5. 具备锁失效机制，防止死锁;\n6. 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。\n\n# 基于Redis的实现方式\n\n## Redis命令介绍\n\n- `SETNX key val` 当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0\n- `expire key timeout` 为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁\n- `delete key` 删除key\n\n## 实现思想\n\n1. 获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID（用来标识一次网络请求）\n2. 获取锁的时候还设置一个超时时间，若超过这个时间则放弃锁\n3. 释放锁的时候，通过UUID判断是不是该锁，若是，则执行delete进行释放\n\n## Redis操作工具类\n\n``` java\nimport redis.clients.jedis.Jedis;\n\nimport java.util.Collections;\n\npublic class RedisTool {\n\n    private static final String LOCK_SUCCESS = \"OK\";\n    private static final String SET_IF_NOT_EXIST = \"NX\";\n    private static final String SET_WITH_EXPIRE_TIME = \"PX\";\n\n    /**\n     * 尝试获取分布式锁\n     *\n     * @param jedis      Redis客户端\n     * @param lockKey    锁\n     * @param requestId  请求标识\n     * @param expireTime 超期时间\n     * @return 是否获取成功\n     */\n    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {\n\n        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);\n\n        if (LOCK_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n    }\n\n    private static final Long RELEASE_SUCCESS = 1L;\n\n    /**\n     * 释放分布式锁\n     *\n     * @param jedis     Redis客户端\n     * @param lockKey   锁\n     * @param requestId 请求标识\n     * @return 是否释放成功\n     */\n    public boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {\n\n        String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\";\n        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));\n\n        if (RELEASE_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n\n    }\n}\n```\n\n## 需要加锁的业务逻辑实现\n\n``` java\nimport cc.wangweiye.distributelock.DistributedLock;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport java.util.UUID;\n\npublic class Service2 {\n\n    private static JedisPool pool = null;\n    private RedisTool lock = new RedisTool();\n\n    int n = 500;\n\n    static {\n        JedisPoolConfig config = new JedisPoolConfig();\n        // 设置最大连接数\n        config.setMaxTotal(500);\n        // 设置最大空闲数\n        config.setMaxIdle(8);\n        // 设置最大等待时间\n        config.setMaxWaitMillis(1000 * 100);\n        // 在borrow一个jedis实例时，是否需要验证，若为true，则所有jedis实例均是可用的\n        config.setTestOnBorrow(true);\n        pool = new JedisPool(config, \"127.0.0.1\", 6379, 3000);\n    }\n\n    public void seckill() {\n        Jedis jedis = pool.getResource();\n        // 返回锁的value值，供释放锁时候进行判断\n        String uuid = UUID.randomUUID().toString();\n\n        while (true) {\n            boolean locked = lock.tryGetDistributedLock(jedis, \"resource\", uuid, 500);\n\n            if (locked) {\n                System.out.println(Thread.currentThread().getName() + \"获得了锁\");\n                System.out.println(--n);\n                break;\n            }\n        }\n\n        lock.releaseDistributedLock(jedis, \"resource\", uuid);\n    }\n}\n```\n\n## 线程执行逻辑\n\n``` java\npublic class ThreadB extends Thread {\n    private Service2 service2;\n\n    public ThreadB(Service2 service2) {\n        this.service2 = service2;\n    }\n\n    @Override\n    public void run() {\n        service2.seckill();\n    }\n}\n```\n\n## 测试代码\n\n``` java\npublic class Test2 {\n    public static void main(String[] args) {\n        Service2 service2 = new Service2();\n        for (int i = 0; i < 499; i++) {\n            ThreadB threadB = new ThreadB(service2);\n            threadB.start();\n        }\n    }\n}\n```\n","slug":"distribute-lock","published":1,"updated":"2019-12-24T02:00:57.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jvh00070j9k9bvdzv2m","content":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p>\n<p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如<code>分布式事务</code>、<code>分布式锁</code>等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，Java中其实提供了很多并发处理相关的API，但是这些API在分布式场景中就无能为力了。也就是说单纯的Java Api并不能提供分布式锁的能力。</p>\n<h1 id=\"分布式锁应该具备的条件\"><a href=\"#分布式锁应该具备的条件\" class=\"headerlink\" title=\"分布式锁应该具备的条件\"></a>分布式锁应该具备的条件</h1><ol>\n<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行;</li>\n<li>高可用的获取锁与释放锁;</li>\n<li>高性能的获取锁与释放锁;</li>\n<li>具备可重入特性;</li>\n<li>具备锁失效机制，防止死锁;</li>\n<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li>\n</ol>\n<h1 id=\"基于Redis的实现方式\"><a href=\"#基于Redis的实现方式\" class=\"headerlink\" title=\"基于Redis的实现方式\"></a>基于Redis的实现方式</h1><h2 id=\"Redis命令介绍\"><a href=\"#Redis命令介绍\" class=\"headerlink\" title=\"Redis命令介绍\"></a>Redis命令介绍</h2><ul>\n<li><code>SETNX key val</code> 当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0</li>\n<li><code>expire key timeout</code> 为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁</li>\n<li><code>delete key</code> 删除key</li>\n</ul>\n<h2 id=\"实现思想\"><a href=\"#实现思想\" class=\"headerlink\" title=\"实现思想\"></a>实现思想</h2><ol>\n<li>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID（用来标识一次网络请求）</li>\n<li>获取锁的时候还设置一个超时时间，若超过这个时间则放弃锁</li>\n<li>释放锁的时候，通过UUID判断是不是该锁，若是，则执行delete进行释放</li>\n</ol>\n<h2 id=\"Redis操作工具类\"><a href=\"#Redis操作工具类\" class=\"headerlink\" title=\"Redis操作工具类\"></a>Redis操作工具类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisTool</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String LOCK_SUCCESS = <span class=\"string\">\"OK\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SET_IF_NOT_EXIST = <span class=\"string\">\"NX\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SET_WITH_EXPIRE_TIME = <span class=\"string\">\"PX\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试获取分布式锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jedis      Redis客户端</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockKey    锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> requestId  请求标识</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> expireTime 超期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否获取成功</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryGetDistributedLock</span><span class=\"params\">(Jedis jedis, String lockKey, String requestId, <span class=\"keyword\">int</span> expireTime)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Long RELEASE_SUCCESS = <span class=\"number\">1L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 释放分布式锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jedis     Redis客户端</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockKey   锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> requestId 请求标识</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否释放成功</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseDistributedLock</span><span class=\"params\">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String script = <span class=\"string\">\"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\"</span>;</span><br><span class=\"line\">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"需要加锁的业务逻辑实现\"><a href=\"#需要加锁的业务逻辑实现\" class=\"headerlink\" title=\"需要加锁的业务逻辑实现\"></a>需要加锁的业务逻辑实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cc.wangweiye.distributelock.DistributedLock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.JedisPool;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.UUID;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> JedisPool pool = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisTool lock = <span class=\"keyword\">new</span> RedisTool();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">500</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        JedisPoolConfig config = <span class=\"keyword\">new</span> JedisPoolConfig();</span><br><span class=\"line\">        <span class=\"comment\">// 设置最大连接数</span></span><br><span class=\"line\">        config.setMaxTotal(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置最大空闲数</span></span><br><span class=\"line\">        config.setMaxIdle(<span class=\"number\">8</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置最大等待时间</span></span><br><span class=\"line\">        config.setMaxWaitMillis(<span class=\"number\">1000</span> * <span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 在borrow一个jedis实例时，是否需要验证，若为true，则所有jedis实例均是可用的</span></span><br><span class=\"line\">        config.setTestOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        pool = <span class=\"keyword\">new</span> JedisPool(config, <span class=\"string\">\"127.0.0.1\"</span>, <span class=\"number\">6379</span>, <span class=\"number\">3000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">seckill</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = pool.getResource();</span><br><span class=\"line\">        <span class=\"comment\">// 返回锁的value值，供释放锁时候进行判断</span></span><br><span class=\"line\">        String uuid = UUID.randomUUID().toString();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> locked = lock.tryGetDistributedLock(jedis, <span class=\"string\">\"resource\"</span>, uuid, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (locked) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"获得了锁\"</span>);</span><br><span class=\"line\">                System.out.println(--n);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        lock.releaseDistributedLock(jedis, <span class=\"string\">\"resource\"</span>, uuid);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程执行逻辑\"><a href=\"#线程执行逻辑\" class=\"headerlink\" title=\"线程执行逻辑\"></a>线程执行逻辑</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Service2 service2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadB</span><span class=\"params\">(Service2 service2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.service2 = service2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        service2.seckill();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Service2 service2 = <span class=\"keyword\">new</span> Service2();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">499</span>; i++) &#123;</span><br><span class=\"line\">            ThreadB threadB = <span class=\"keyword\">new</span> ThreadB(service2);</span><br><span class=\"line\">            threadB.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p>\n<p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如<code>分布式事务</code>、<code>分布式锁</code>等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，Java中其实提供了很多并发处理相关的API，但是这些API在分布式场景中就无能为力了。也就是说单纯的Java Api并不能提供分布式锁的能力。</p>\n<h1 id=\"分布式锁应该具备的条件\"><a href=\"#分布式锁应该具备的条件\" class=\"headerlink\" title=\"分布式锁应该具备的条件\"></a>分布式锁应该具备的条件</h1><ol>\n<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行;</li>\n<li>高可用的获取锁与释放锁;</li>\n<li>高性能的获取锁与释放锁;</li>\n<li>具备可重入特性;</li>\n<li>具备锁失效机制，防止死锁;</li>\n<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li>\n</ol>\n<h1 id=\"基于Redis的实现方式\"><a href=\"#基于Redis的实现方式\" class=\"headerlink\" title=\"基于Redis的实现方式\"></a>基于Redis的实现方式</h1><h2 id=\"Redis命令介绍\"><a href=\"#Redis命令介绍\" class=\"headerlink\" title=\"Redis命令介绍\"></a>Redis命令介绍</h2><ul>\n<li><code>SETNX key val</code> 当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0</li>\n<li><code>expire key timeout</code> 为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁</li>\n<li><code>delete key</code> 删除key</li>\n</ul>\n<h2 id=\"实现思想\"><a href=\"#实现思想\" class=\"headerlink\" title=\"实现思想\"></a>实现思想</h2><ol>\n<li>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID（用来标识一次网络请求）</li>\n<li>获取锁的时候还设置一个超时时间，若超过这个时间则放弃锁</li>\n<li>释放锁的时候，通过UUID判断是不是该锁，若是，则执行delete进行释放</li>\n</ol>\n<h2 id=\"Redis操作工具类\"><a href=\"#Redis操作工具类\" class=\"headerlink\" title=\"Redis操作工具类\"></a>Redis操作工具类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisTool</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String LOCK_SUCCESS = <span class=\"string\">\"OK\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SET_IF_NOT_EXIST = <span class=\"string\">\"NX\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SET_WITH_EXPIRE_TIME = <span class=\"string\">\"PX\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试获取分布式锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jedis      Redis客户端</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockKey    锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> requestId  请求标识</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> expireTime 超期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否获取成功</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryGetDistributedLock</span><span class=\"params\">(Jedis jedis, String lockKey, String requestId, <span class=\"keyword\">int</span> expireTime)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Long RELEASE_SUCCESS = <span class=\"number\">1L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 释放分布式锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jedis     Redis客户端</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockKey   锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> requestId 请求标识</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否释放成功</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseDistributedLock</span><span class=\"params\">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String script = <span class=\"string\">\"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\"</span>;</span><br><span class=\"line\">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"需要加锁的业务逻辑实现\"><a href=\"#需要加锁的业务逻辑实现\" class=\"headerlink\" title=\"需要加锁的业务逻辑实现\"></a>需要加锁的业务逻辑实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cc.wangweiye.distributelock.DistributedLock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.JedisPool;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.UUID;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> JedisPool pool = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisTool lock = <span class=\"keyword\">new</span> RedisTool();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">500</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        JedisPoolConfig config = <span class=\"keyword\">new</span> JedisPoolConfig();</span><br><span class=\"line\">        <span class=\"comment\">// 设置最大连接数</span></span><br><span class=\"line\">        config.setMaxTotal(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置最大空闲数</span></span><br><span class=\"line\">        config.setMaxIdle(<span class=\"number\">8</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置最大等待时间</span></span><br><span class=\"line\">        config.setMaxWaitMillis(<span class=\"number\">1000</span> * <span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 在borrow一个jedis实例时，是否需要验证，若为true，则所有jedis实例均是可用的</span></span><br><span class=\"line\">        config.setTestOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        pool = <span class=\"keyword\">new</span> JedisPool(config, <span class=\"string\">\"127.0.0.1\"</span>, <span class=\"number\">6379</span>, <span class=\"number\">3000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">seckill</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = pool.getResource();</span><br><span class=\"line\">        <span class=\"comment\">// 返回锁的value值，供释放锁时候进行判断</span></span><br><span class=\"line\">        String uuid = UUID.randomUUID().toString();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> locked = lock.tryGetDistributedLock(jedis, <span class=\"string\">\"resource\"</span>, uuid, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (locked) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"获得了锁\"</span>);</span><br><span class=\"line\">                System.out.println(--n);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        lock.releaseDistributedLock(jedis, <span class=\"string\">\"resource\"</span>, uuid);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程执行逻辑\"><a href=\"#线程执行逻辑\" class=\"headerlink\" title=\"线程执行逻辑\"></a>线程执行逻辑</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Service2 service2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadB</span><span class=\"params\">(Service2 service2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.service2 = service2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        service2.seckill();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Service2 service2 = <span class=\"keyword\">new</span> Service2();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">499</span>; i++) &#123;</span><br><span class=\"line\">            ThreadB threadB = <span class=\"keyword\">new</span> ThreadB(service2);</span><br><span class=\"line\">            threadB.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"强大的docker","date":"2018-04-13T13:06:56.000Z","top":110,"_content":"\n![](http://www.wailian.work/images/2018/04/18/1211be9c.jpg)\n\n# 什么是Docker\n\nDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口 --[百度百科](https://baike.baidu.com/item/Docker/13344470?fr=aladdin)\n\nDocker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。\n\ndocker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。docker就是集装箱 --[知乎](https://www.zhihu.com/question/28300645/answer/67707287)\n\n# 镜像\n\nDocker 镜像是用于创建 Docker 容器的只读模板\n\n# 容器\n\n容器是独立运行的一个或一组应用\nDocker容器通过Docker镜像来创建\n\n# Docker在不同操作系统下的安装\n\n## Mac安装\n\nMac下安装Docker很简单，可视化操作即可  [dmg包下载地址](https://docs.docker.com/docker-for-mac/install/#download-docker-for-mac)\n\n查看docker版本\n\n```\ndocker -v\n```\n\n## CentOS安装\n\n```\nyum install docker\n```\n\n安装完成后，查看docker版本\n\n```\ndocker version\n```\n\n# Docker镜像中心\n\n- [Docker官方仓库](https://hub.docker.com) 国内速度较慢\n- [网易云仓库](https://c.163yun.com) 需要注册然后使用，速度较快\n\n# 动手构建Spring Boot+Docker应用\n\n## 通过Spring Initializr创建普通Spring Boot应用\n\n```\n@SpringBootApplication\n@RestController\npublic class DockerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(DockerApplication.class, args);\n    }\n\n    @RequestMapping(\"/\")\n    public String home() {\n        return \"Hello Spring Boot, Docker and CloudComb!\";\n    }\n}\n```\n\n## 打包并运行jar包\n\n```\nmvn clean package\n```\n\n![](http://www.wailian.work/images/2018/04/13/dabao.png)\n\n```\njava -jar docker-0.0.1-SNAPSHOT.jar\n```\n\n浏览器访问`http://127.0.0.1:8080`输出正常则证明成功\n\n# 容器化构建及运行\n\n## 编写Dockerfile文件\n\n在项目根目录下创建`Dockerfile`文件，\n\n```\nFROM hub.c.163.com/bingohuang/jdk8:latest\n\nMAINTAINER wangweiye wwyknight@163.com\n\nCOPY target/docker-0.0.1-SNAPSHOT.jar app.jar\n\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n```\n\n此Dockerfile核心功能就是将可执行文件拷贝到镜像中，并在容器启动时默认执行启动命令`java -jar /app.jar`\n\n## docker创建\n\n```\ndocker build -t spring-boot:latest .\n```\n\n`-t`为docker设置镜像名称和版本\n\n详情查看[docker build](https://docs.docker.com/engine/reference/commandline/build/)\n\n## docker运行\n\n```\ndocker run -d -p 9999:8080 spring-boot\n```\n\n`-d` Run container in background and print container ID(在后台运行容器并打印容器ID)\n\n`-p` 设置本机端口和容器端口的映射关系\n\n详情查看[docker run](https://docs.docker.com/engine/reference/commandline/run/)\n\n## 访问\n\n浏览器访问`http://127.0.0.1:8080`输出正常则证明成功\n\n## 推送镜像到网易蜂巢\n\n首先需要一个网易蜂巢账号,[注册地址](https://www.163yun.com/?h=fc)\n\n在命令行中登录蜂巢仓库\n\n```\ndocker login hub.c.163.com\nUsername: wwyknight@163.com\nPassword:\nLogin Succeeded\n```\n\n[推送本地镜像](https://www.163yun.com/help/documents/15587826830438400)\n\n```\ndocker tag {镜像名或ID} hub.c.163.com/{你的用户名}/{标签名}\n```\n\n你的网易云镜像仓库推送地址为`hub.c.163.com/{你的用户名}/{标签名}`\nAttention: 此处为你的用户名，不是你的邮箱帐号或者手机号码 登录网易云控制台，页面右上角头像右侧即为「用户名」\n推送至不存在的镜像仓库时，自动创建镜像仓库并保存新推送的镜像版本；\n推送至已存在的镜像仓库时，在该镜像仓库中保存新推送的版本，当版本号相同时覆盖原有镜像。\n\n```\ndocker push hub.c.163.com/{你的用户名}/{标签名}\n```\n默认为私有镜像仓库，推送成功后即可在控制台的「镜像仓库」查看。\n\n![](http://www.wailian.work/images/2018/04/13/12.png)\n","source":"_posts/docker.md","raw":"---\ntitle: 强大的docker\ndate: 2018-04-13 21:06:56\ntags:\ntop: 110\n---\n\n![](http://www.wailian.work/images/2018/04/18/1211be9c.jpg)\n\n# 什么是Docker\n\nDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口 --[百度百科](https://baike.baidu.com/item/Docker/13344470?fr=aladdin)\n\nDocker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。\n\ndocker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。docker就是集装箱 --[知乎](https://www.zhihu.com/question/28300645/answer/67707287)\n\n# 镜像\n\nDocker 镜像是用于创建 Docker 容器的只读模板\n\n# 容器\n\n容器是独立运行的一个或一组应用\nDocker容器通过Docker镜像来创建\n\n# Docker在不同操作系统下的安装\n\n## Mac安装\n\nMac下安装Docker很简单，可视化操作即可  [dmg包下载地址](https://docs.docker.com/docker-for-mac/install/#download-docker-for-mac)\n\n查看docker版本\n\n```\ndocker -v\n```\n\n## CentOS安装\n\n```\nyum install docker\n```\n\n安装完成后，查看docker版本\n\n```\ndocker version\n```\n\n# Docker镜像中心\n\n- [Docker官方仓库](https://hub.docker.com) 国内速度较慢\n- [网易云仓库](https://c.163yun.com) 需要注册然后使用，速度较快\n\n# 动手构建Spring Boot+Docker应用\n\n## 通过Spring Initializr创建普通Spring Boot应用\n\n```\n@SpringBootApplication\n@RestController\npublic class DockerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(DockerApplication.class, args);\n    }\n\n    @RequestMapping(\"/\")\n    public String home() {\n        return \"Hello Spring Boot, Docker and CloudComb!\";\n    }\n}\n```\n\n## 打包并运行jar包\n\n```\nmvn clean package\n```\n\n![](http://www.wailian.work/images/2018/04/13/dabao.png)\n\n```\njava -jar docker-0.0.1-SNAPSHOT.jar\n```\n\n浏览器访问`http://127.0.0.1:8080`输出正常则证明成功\n\n# 容器化构建及运行\n\n## 编写Dockerfile文件\n\n在项目根目录下创建`Dockerfile`文件，\n\n```\nFROM hub.c.163.com/bingohuang/jdk8:latest\n\nMAINTAINER wangweiye wwyknight@163.com\n\nCOPY target/docker-0.0.1-SNAPSHOT.jar app.jar\n\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n```\n\n此Dockerfile核心功能就是将可执行文件拷贝到镜像中，并在容器启动时默认执行启动命令`java -jar /app.jar`\n\n## docker创建\n\n```\ndocker build -t spring-boot:latest .\n```\n\n`-t`为docker设置镜像名称和版本\n\n详情查看[docker build](https://docs.docker.com/engine/reference/commandline/build/)\n\n## docker运行\n\n```\ndocker run -d -p 9999:8080 spring-boot\n```\n\n`-d` Run container in background and print container ID(在后台运行容器并打印容器ID)\n\n`-p` 设置本机端口和容器端口的映射关系\n\n详情查看[docker run](https://docs.docker.com/engine/reference/commandline/run/)\n\n## 访问\n\n浏览器访问`http://127.0.0.1:8080`输出正常则证明成功\n\n## 推送镜像到网易蜂巢\n\n首先需要一个网易蜂巢账号,[注册地址](https://www.163yun.com/?h=fc)\n\n在命令行中登录蜂巢仓库\n\n```\ndocker login hub.c.163.com\nUsername: wwyknight@163.com\nPassword:\nLogin Succeeded\n```\n\n[推送本地镜像](https://www.163yun.com/help/documents/15587826830438400)\n\n```\ndocker tag {镜像名或ID} hub.c.163.com/{你的用户名}/{标签名}\n```\n\n你的网易云镜像仓库推送地址为`hub.c.163.com/{你的用户名}/{标签名}`\nAttention: 此处为你的用户名，不是你的邮箱帐号或者手机号码 登录网易云控制台，页面右上角头像右侧即为「用户名」\n推送至不存在的镜像仓库时，自动创建镜像仓库并保存新推送的镜像版本；\n推送至已存在的镜像仓库时，在该镜像仓库中保存新推送的版本，当版本号相同时覆盖原有镜像。\n\n```\ndocker push hub.c.163.com/{你的用户名}/{标签名}\n```\n默认为私有镜像仓库，推送成功后即可在控制台的「镜像仓库」查看。\n\n![](http://www.wailian.work/images/2018/04/13/12.png)\n","slug":"docker","published":1,"updated":"2019-12-24T02:00:57.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jvj00080j9k8dyjv7ik","content":"<p><img src=\"http://www.wailian.work/images/2018/04/18/1211be9c.jpg\" alt=\"\"></p>\n<h1 id=\"什么是Docker\"><a href=\"#什么是Docker\" class=\"headerlink\" title=\"什么是Docker\"></a>什么是Docker</h1><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口 –<a href=\"https://baike.baidu.com/item/Docker/13344470?fr=aladdin\" target=\"_blank\" rel=\"noopener\">百度百科</a></p>\n<p>Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。</p>\n<p>docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。docker就是集装箱 –<a href=\"https://www.zhihu.com/question/28300645/answer/67707287\" target=\"_blank\" rel=\"noopener\">知乎</a></p>\n<h1 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h1><p>Docker 镜像是用于创建 Docker 容器的只读模板</p>\n<h1 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h1><p>容器是独立运行的一个或一组应用<br>Docker容器通过Docker镜像来创建</p>\n<h1 id=\"Docker在不同操作系统下的安装\"><a href=\"#Docker在不同操作系统下的安装\" class=\"headerlink\" title=\"Docker在不同操作系统下的安装\"></a>Docker在不同操作系统下的安装</h1><h2 id=\"Mac安装\"><a href=\"#Mac安装\" class=\"headerlink\" title=\"Mac安装\"></a>Mac安装</h2><p>Mac下安装Docker很简单，可视化操作即可  <a href=\"https://docs.docker.com/docker-for-mac/install/#download-docker-for-mac\" target=\"_blank\" rel=\"noopener\">dmg包下载地址</a></p>\n<p>查看docker版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker -v</span><br></pre></td></tr></table></figure>\n<h2 id=\"CentOS安装\"><a href=\"#CentOS安装\" class=\"headerlink\" title=\"CentOS安装\"></a>CentOS安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install docker</span><br></pre></td></tr></table></figure>\n<p>安装完成后，查看docker版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure>\n<h1 id=\"Docker镜像中心\"><a href=\"#Docker镜像中心\" class=\"headerlink\" title=\"Docker镜像中心\"></a>Docker镜像中心</h1><ul>\n<li><a href=\"https://hub.docker.com\" target=\"_blank\" rel=\"noopener\">Docker官方仓库</a> 国内速度较慢</li>\n<li><a href=\"https://c.163yun.com\" target=\"_blank\" rel=\"noopener\">网易云仓库</a> 需要注册然后使用，速度较快</li>\n</ul>\n<h1 id=\"动手构建Spring-Boot-Docker应用\"><a href=\"#动手构建Spring-Boot-Docker应用\" class=\"headerlink\" title=\"动手构建Spring Boot+Docker应用\"></a>动手构建Spring Boot+Docker应用</h1><h2 id=\"通过Spring-Initializr创建普通Spring-Boot应用\"><a href=\"#通过Spring-Initializr创建普通Spring-Boot应用\" class=\"headerlink\" title=\"通过Spring Initializr创建普通Spring Boot应用\"></a>通过Spring Initializr创建普通Spring Boot应用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">public class DockerApplication &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SpringApplication.run(DockerApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/&quot;)</span><br><span class=\"line\">    public String home() &#123;</span><br><span class=\"line\">        return &quot;Hello Spring Boot, Docker and CloudComb!&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包并运行jar包\"><a href=\"#打包并运行jar包\" class=\"headerlink\" title=\"打包并运行jar包\"></a>打包并运行jar包</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean package</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/04/13/dabao.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar docker-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>\n<p>浏览器访问<code>http://127.0.0.1:8080</code>输出正常则证明成功</p>\n<h1 id=\"容器化构建及运行\"><a href=\"#容器化构建及运行\" class=\"headerlink\" title=\"容器化构建及运行\"></a>容器化构建及运行</h1><h2 id=\"编写Dockerfile文件\"><a href=\"#编写Dockerfile文件\" class=\"headerlink\" title=\"编写Dockerfile文件\"></a>编写Dockerfile文件</h2><p>在项目根目录下创建<code>Dockerfile</code>文件，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM hub.c.163.com/bingohuang/jdk8:latest</span><br><span class=\"line\"></span><br><span class=\"line\">MAINTAINER wangweiye wwyknight@163.com</span><br><span class=\"line\"></span><br><span class=\"line\">COPY target/docker-0.0.1-SNAPSHOT.jar app.jar</span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure>\n<p>此Dockerfile核心功能就是将可执行文件拷贝到镜像中，并在容器启动时默认执行启动命令<code>java -jar /app.jar</code></p>\n<h2 id=\"docker创建\"><a href=\"#docker创建\" class=\"headerlink\" title=\"docker创建\"></a>docker创建</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t spring-boot:latest .</span><br></pre></td></tr></table></figure>\n<p><code>-t</code>为docker设置镜像名称和版本</p>\n<p>详情查看<a href=\"https://docs.docker.com/engine/reference/commandline/build/\" target=\"_blank\" rel=\"noopener\">docker build</a></p>\n<h2 id=\"docker运行\"><a href=\"#docker运行\" class=\"headerlink\" title=\"docker运行\"></a>docker运行</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 9999:8080 spring-boot</span><br></pre></td></tr></table></figure>\n<p><code>-d</code> Run container in background and print container ID(在后台运行容器并打印容器ID)</p>\n<p><code>-p</code> 设置本机端口和容器端口的映射关系</p>\n<p>详情查看<a href=\"https://docs.docker.com/engine/reference/commandline/run/\" target=\"_blank\" rel=\"noopener\">docker run</a></p>\n<h2 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h2><p>浏览器访问<code>http://127.0.0.1:8080</code>输出正常则证明成功</p>\n<h2 id=\"推送镜像到网易蜂巢\"><a href=\"#推送镜像到网易蜂巢\" class=\"headerlink\" title=\"推送镜像到网易蜂巢\"></a>推送镜像到网易蜂巢</h2><p>首先需要一个网易蜂巢账号,<a href=\"https://www.163yun.com/?h=fc\" target=\"_blank\" rel=\"noopener\">注册地址</a></p>\n<p>在命令行中登录蜂巢仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker login hub.c.163.com</span><br><span class=\"line\">Username: wwyknight@163.com</span><br><span class=\"line\">Password:</span><br><span class=\"line\">Login Succeeded</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.163yun.com/help/documents/15587826830438400\" target=\"_blank\" rel=\"noopener\">推送本地镜像</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker tag &#123;镜像名或ID&#125; hub.c.163.com/&#123;你的用户名&#125;/&#123;标签名&#125;</span><br></pre></td></tr></table></figure>\n<p>你的网易云镜像仓库推送地址为<code>hub.c.163.com/{你的用户名}/{标签名}</code><br>Attention: 此处为你的用户名，不是你的邮箱帐号或者手机号码 登录网易云控制台，页面右上角头像右侧即为「用户名」<br>推送至不存在的镜像仓库时，自动创建镜像仓库并保存新推送的镜像版本；<br>推送至已存在的镜像仓库时，在该镜像仓库中保存新推送的版本，当版本号相同时覆盖原有镜像。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker push hub.c.163.com/&#123;你的用户名&#125;/&#123;标签名&#125;</span><br></pre></td></tr></table></figure>\n<p>默认为私有镜像仓库，推送成功后即可在控制台的「镜像仓库」查看。</p>\n<p><img src=\"http://www.wailian.work/images/2018/04/13/12.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/04/18/1211be9c.jpg\" alt=\"\"></p>\n<h1 id=\"什么是Docker\"><a href=\"#什么是Docker\" class=\"headerlink\" title=\"什么是Docker\"></a>什么是Docker</h1><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口 –<a href=\"https://baike.baidu.com/item/Docker/13344470?fr=aladdin\" target=\"_blank\" rel=\"noopener\">百度百科</a></p>\n<p>Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。</p>\n<p>docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。docker就是集装箱 –<a href=\"https://www.zhihu.com/question/28300645/answer/67707287\" target=\"_blank\" rel=\"noopener\">知乎</a></p>\n<h1 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h1><p>Docker 镜像是用于创建 Docker 容器的只读模板</p>\n<h1 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h1><p>容器是独立运行的一个或一组应用<br>Docker容器通过Docker镜像来创建</p>\n<h1 id=\"Docker在不同操作系统下的安装\"><a href=\"#Docker在不同操作系统下的安装\" class=\"headerlink\" title=\"Docker在不同操作系统下的安装\"></a>Docker在不同操作系统下的安装</h1><h2 id=\"Mac安装\"><a href=\"#Mac安装\" class=\"headerlink\" title=\"Mac安装\"></a>Mac安装</h2><p>Mac下安装Docker很简单，可视化操作即可  <a href=\"https://docs.docker.com/docker-for-mac/install/#download-docker-for-mac\" target=\"_blank\" rel=\"noopener\">dmg包下载地址</a></p>\n<p>查看docker版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker -v</span><br></pre></td></tr></table></figure>\n<h2 id=\"CentOS安装\"><a href=\"#CentOS安装\" class=\"headerlink\" title=\"CentOS安装\"></a>CentOS安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install docker</span><br></pre></td></tr></table></figure>\n<p>安装完成后，查看docker版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure>\n<h1 id=\"Docker镜像中心\"><a href=\"#Docker镜像中心\" class=\"headerlink\" title=\"Docker镜像中心\"></a>Docker镜像中心</h1><ul>\n<li><a href=\"https://hub.docker.com\" target=\"_blank\" rel=\"noopener\">Docker官方仓库</a> 国内速度较慢</li>\n<li><a href=\"https://c.163yun.com\" target=\"_blank\" rel=\"noopener\">网易云仓库</a> 需要注册然后使用，速度较快</li>\n</ul>\n<h1 id=\"动手构建Spring-Boot-Docker应用\"><a href=\"#动手构建Spring-Boot-Docker应用\" class=\"headerlink\" title=\"动手构建Spring Boot+Docker应用\"></a>动手构建Spring Boot+Docker应用</h1><h2 id=\"通过Spring-Initializr创建普通Spring-Boot应用\"><a href=\"#通过Spring-Initializr创建普通Spring-Boot应用\" class=\"headerlink\" title=\"通过Spring Initializr创建普通Spring Boot应用\"></a>通过Spring Initializr创建普通Spring Boot应用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">public class DockerApplication &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SpringApplication.run(DockerApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/&quot;)</span><br><span class=\"line\">    public String home() &#123;</span><br><span class=\"line\">        return &quot;Hello Spring Boot, Docker and CloudComb!&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包并运行jar包\"><a href=\"#打包并运行jar包\" class=\"headerlink\" title=\"打包并运行jar包\"></a>打包并运行jar包</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean package</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/04/13/dabao.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar docker-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>\n<p>浏览器访问<code>http://127.0.0.1:8080</code>输出正常则证明成功</p>\n<h1 id=\"容器化构建及运行\"><a href=\"#容器化构建及运行\" class=\"headerlink\" title=\"容器化构建及运行\"></a>容器化构建及运行</h1><h2 id=\"编写Dockerfile文件\"><a href=\"#编写Dockerfile文件\" class=\"headerlink\" title=\"编写Dockerfile文件\"></a>编写Dockerfile文件</h2><p>在项目根目录下创建<code>Dockerfile</code>文件，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM hub.c.163.com/bingohuang/jdk8:latest</span><br><span class=\"line\"></span><br><span class=\"line\">MAINTAINER wangweiye wwyknight@163.com</span><br><span class=\"line\"></span><br><span class=\"line\">COPY target/docker-0.0.1-SNAPSHOT.jar app.jar</span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure>\n<p>此Dockerfile核心功能就是将可执行文件拷贝到镜像中，并在容器启动时默认执行启动命令<code>java -jar /app.jar</code></p>\n<h2 id=\"docker创建\"><a href=\"#docker创建\" class=\"headerlink\" title=\"docker创建\"></a>docker创建</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t spring-boot:latest .</span><br></pre></td></tr></table></figure>\n<p><code>-t</code>为docker设置镜像名称和版本</p>\n<p>详情查看<a href=\"https://docs.docker.com/engine/reference/commandline/build/\" target=\"_blank\" rel=\"noopener\">docker build</a></p>\n<h2 id=\"docker运行\"><a href=\"#docker运行\" class=\"headerlink\" title=\"docker运行\"></a>docker运行</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 9999:8080 spring-boot</span><br></pre></td></tr></table></figure>\n<p><code>-d</code> Run container in background and print container ID(在后台运行容器并打印容器ID)</p>\n<p><code>-p</code> 设置本机端口和容器端口的映射关系</p>\n<p>详情查看<a href=\"https://docs.docker.com/engine/reference/commandline/run/\" target=\"_blank\" rel=\"noopener\">docker run</a></p>\n<h2 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h2><p>浏览器访问<code>http://127.0.0.1:8080</code>输出正常则证明成功</p>\n<h2 id=\"推送镜像到网易蜂巢\"><a href=\"#推送镜像到网易蜂巢\" class=\"headerlink\" title=\"推送镜像到网易蜂巢\"></a>推送镜像到网易蜂巢</h2><p>首先需要一个网易蜂巢账号,<a href=\"https://www.163yun.com/?h=fc\" target=\"_blank\" rel=\"noopener\">注册地址</a></p>\n<p>在命令行中登录蜂巢仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker login hub.c.163.com</span><br><span class=\"line\">Username: wwyknight@163.com</span><br><span class=\"line\">Password:</span><br><span class=\"line\">Login Succeeded</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.163yun.com/help/documents/15587826830438400\" target=\"_blank\" rel=\"noopener\">推送本地镜像</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker tag &#123;镜像名或ID&#125; hub.c.163.com/&#123;你的用户名&#125;/&#123;标签名&#125;</span><br></pre></td></tr></table></figure>\n<p>你的网易云镜像仓库推送地址为<code>hub.c.163.com/{你的用户名}/{标签名}</code><br>Attention: 此处为你的用户名，不是你的邮箱帐号或者手机号码 登录网易云控制台，页面右上角头像右侧即为「用户名」<br>推送至不存在的镜像仓库时，自动创建镜像仓库并保存新推送的镜像版本；<br>推送至已存在的镜像仓库时，在该镜像仓库中保存新推送的版本，当版本号相同时覆盖原有镜像。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker push hub.c.163.com/&#123;你的用户名&#125;/&#123;标签名&#125;</span><br></pre></td></tr></table></figure>\n<p>默认为私有镜像仓库，推送成功后即可在控制台的「镜像仓库」查看。</p>\n<p><img src=\"http://www.wailian.work/images/2018/04/13/12.png\" alt=\"\"></p>\n"},{"title":"floyd最短路径算法","date":"2020-03-24T07:39:41.000Z","_content":"\n## floyd算法\n\n弗洛伊德算法又称插点法是**解决任意两点间的最短路径的一种算法**\n\n## 适用范围\n\n边权可正可负，运行一次算法即可求得任意两点间的最短路径（无负权回路即可）\n\n可以解决“多源最短路径”\n\n### 什么是负权回路\n\n图中1号点到3号点的最短路径是什么？\n\n![6.10.png](http://s1.wailian.download/2020/03/24/6.10.png)\n\n由于每次经过1->2->3这样的环，最短路径就会-1，所有永远找不到最短路径\n\n## 实例\n\n![6.2-floyd.png](http://s1.wailian.download/2020/03/24/6.2-floyd.png)\n\n计算图中各个顶点到各个顶点的最短距离\n\n首先我们定义一个二维数组来存储图中最易可见的点对点(不允许经过第三点)之间的距离，如果不能到达使用∞表示。另外规定自己到自己的距离是0，具体表示如下\n\n[![6.3-.png](http://s1.wailian.download/2020/03/24/6.3-.png)](http://www.wailian.work/image/Ae1zve)\n\n如果要使两点之间距离变短，唯一方法就是通过第三个点来解决。例如a点到b点的距离通过顶点k来中转那么a->k->b才有可能缩短a->b的距离。那么这个k点是哪个点呢？是否不只通过1个k点最短，而是经过两个或者更多点最短，比如a->k1->k2>b\n\n比如图中4->3的距离是12，如果经过1点，那么4->1->3的距离就变为11。现在只允许经过1号点，求i点到j点的最短距离，只需判断e[i][1]+e[1][j]是否比e[i][j]要小。代码实现如下\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport copy\n\n# 创建一个4行4列的二维数组\nm = [[0]*4 for i in range(4)]\n\n# 为数组赋值\nm[0][0] = 0\nm[0][1] = 2\nm[0][2] = 6\nm[0][3] = 4\nm[1][0] = 9999\nm[1][1] = 0\nm[1][2] = 3\nm[1][3] = 9999\nm[2][0] = 7\nm[2][1] = 9999\nm[2][2] = 0\nm[2][3] = 1\nm[3][0] = 5\nm[3][1] = 9999\nm[3][2] = 12\nm[3][3] = 0\n\nprint('原路径数据:', m)\n\n# 允许经过1号点的最短路径\nn = copy.deepcopy(m)\ni = 0\nj = 0\n\nfor i in range(4):\n    for j in range(4):\n        if (n[i][j] > n[i][0] + n[0][j]):\n                n[i][j] = n[i][0] + n[0][j]\n\nprint('在允许经过1号点后的最短路径:', n)\n```\n\n执行结果如下：\n\n原路径数据: [[0, 2, 6, 4], [9999, 0, 3, 9999], [7, 9999, 0, 1], [5, 9999, 12, 0]]\n\n在允许经过1号点后的最短路径: [[0, 2, 6, 4], [9999, 0, 3, 9999], [7, 9, 0, 1], [5, 7, 11, 0]]\n\n![6.5-1.png](http://s1.wailian.download/2020/03/24/6.5-1.png)\n\n通过图中白色背景处我们可以看到通过1号点中转的情况下,3->2,4->2,4->3的路径都变短了\n\n接下来求只允许1号和2号点的情况下任意两点间的最短距离，如何做呢？我们只需要在只经过1号点时任意两点最短距离的结果下，再判断经过2号顶点如何使i号点到j号点的路径边的更短\n\n```python\n# 再允许经过2号点后的路径\no = copy.deepcopy(n)\ni = 0\nj = 0\n\nfor i in range(4):\n    for j in range(4):\n        if(o[i][j] > o[i][1] + o[1][j]):\n            o[i][j] = o[i][1] + o[1][j]\n\nprint('再允许经过2号点后的最短路径:', o)\n```\n\n执行结果如下：\n\n再允许经过2号点后的最短路径: [[0, 2, 5, 4], [9999, 0, 3, 9999], [7, 9, 0, 1], [5, 7, 10, 0]]\n\n![6.6-1-2.png](http://s1.wailian.download/2020/03/24/6.6-1-2.png)\n\n\n同理继续在只允许1，2，3进行中转的情况下求最短距离。\n\n![6.7-1-2-3.png](http://s1.wailian.download/2020/03/24/6.7-1-2-3.png)\n\n\n最后在允许通过所有顶点作为中转，任意两点之间最终的最短路径为：\n\n![6.8-1-2-3-4.png](http://s1.wailian.download/2020/03/24/6.8-1-2-3-4.png)\n\n整个算法最终代码实现如下：\n\n```python\nk = 0\ni = 0\nj = 0\n\nfor k in range(4):\n    for i in range(4):\n        for j in range(4):\n            if (m[i][j] > m[i][k] + m[k][j]):\n                m[i][j] = m[i][k] + m[k][j]\n\nprint('最终路径:', m)\n```\n\n最终路径: [[0, 2, 5, 4], [9, 0, 3, 4], [6, 8, 0, 1], [5, 7, 10, 0]]\n\n通过这种方法我们可以求出任意两个点之间最短路径。它的时间复杂度是 O(n<sup>3</sup>)\n","source":"_posts/floyd.md","raw":"---\ntitle: floyd最短路径算法\ndate: 2020-03-24 15:39:41\ntags:\n---\n\n## floyd算法\n\n弗洛伊德算法又称插点法是**解决任意两点间的最短路径的一种算法**\n\n## 适用范围\n\n边权可正可负，运行一次算法即可求得任意两点间的最短路径（无负权回路即可）\n\n可以解决“多源最短路径”\n\n### 什么是负权回路\n\n图中1号点到3号点的最短路径是什么？\n\n![6.10.png](http://s1.wailian.download/2020/03/24/6.10.png)\n\n由于每次经过1->2->3这样的环，最短路径就会-1，所有永远找不到最短路径\n\n## 实例\n\n![6.2-floyd.png](http://s1.wailian.download/2020/03/24/6.2-floyd.png)\n\n计算图中各个顶点到各个顶点的最短距离\n\n首先我们定义一个二维数组来存储图中最易可见的点对点(不允许经过第三点)之间的距离，如果不能到达使用∞表示。另外规定自己到自己的距离是0，具体表示如下\n\n[![6.3-.png](http://s1.wailian.download/2020/03/24/6.3-.png)](http://www.wailian.work/image/Ae1zve)\n\n如果要使两点之间距离变短，唯一方法就是通过第三个点来解决。例如a点到b点的距离通过顶点k来中转那么a->k->b才有可能缩短a->b的距离。那么这个k点是哪个点呢？是否不只通过1个k点最短，而是经过两个或者更多点最短，比如a->k1->k2>b\n\n比如图中4->3的距离是12，如果经过1点，那么4->1->3的距离就变为11。现在只允许经过1号点，求i点到j点的最短距离，只需判断e[i][1]+e[1][j]是否比e[i][j]要小。代码实现如下\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport copy\n\n# 创建一个4行4列的二维数组\nm = [[0]*4 for i in range(4)]\n\n# 为数组赋值\nm[0][0] = 0\nm[0][1] = 2\nm[0][2] = 6\nm[0][3] = 4\nm[1][0] = 9999\nm[1][1] = 0\nm[1][2] = 3\nm[1][3] = 9999\nm[2][0] = 7\nm[2][1] = 9999\nm[2][2] = 0\nm[2][3] = 1\nm[3][0] = 5\nm[3][1] = 9999\nm[3][2] = 12\nm[3][3] = 0\n\nprint('原路径数据:', m)\n\n# 允许经过1号点的最短路径\nn = copy.deepcopy(m)\ni = 0\nj = 0\n\nfor i in range(4):\n    for j in range(4):\n        if (n[i][j] > n[i][0] + n[0][j]):\n                n[i][j] = n[i][0] + n[0][j]\n\nprint('在允许经过1号点后的最短路径:', n)\n```\n\n执行结果如下：\n\n原路径数据: [[0, 2, 6, 4], [9999, 0, 3, 9999], [7, 9999, 0, 1], [5, 9999, 12, 0]]\n\n在允许经过1号点后的最短路径: [[0, 2, 6, 4], [9999, 0, 3, 9999], [7, 9, 0, 1], [5, 7, 11, 0]]\n\n![6.5-1.png](http://s1.wailian.download/2020/03/24/6.5-1.png)\n\n通过图中白色背景处我们可以看到通过1号点中转的情况下,3->2,4->2,4->3的路径都变短了\n\n接下来求只允许1号和2号点的情况下任意两点间的最短距离，如何做呢？我们只需要在只经过1号点时任意两点最短距离的结果下，再判断经过2号顶点如何使i号点到j号点的路径边的更短\n\n```python\n# 再允许经过2号点后的路径\no = copy.deepcopy(n)\ni = 0\nj = 0\n\nfor i in range(4):\n    for j in range(4):\n        if(o[i][j] > o[i][1] + o[1][j]):\n            o[i][j] = o[i][1] + o[1][j]\n\nprint('再允许经过2号点后的最短路径:', o)\n```\n\n执行结果如下：\n\n再允许经过2号点后的最短路径: [[0, 2, 5, 4], [9999, 0, 3, 9999], [7, 9, 0, 1], [5, 7, 10, 0]]\n\n![6.6-1-2.png](http://s1.wailian.download/2020/03/24/6.6-1-2.png)\n\n\n同理继续在只允许1，2，3进行中转的情况下求最短距离。\n\n![6.7-1-2-3.png](http://s1.wailian.download/2020/03/24/6.7-1-2-3.png)\n\n\n最后在允许通过所有顶点作为中转，任意两点之间最终的最短路径为：\n\n![6.8-1-2-3-4.png](http://s1.wailian.download/2020/03/24/6.8-1-2-3-4.png)\n\n整个算法最终代码实现如下：\n\n```python\nk = 0\ni = 0\nj = 0\n\nfor k in range(4):\n    for i in range(4):\n        for j in range(4):\n            if (m[i][j] > m[i][k] + m[k][j]):\n                m[i][j] = m[i][k] + m[k][j]\n\nprint('最终路径:', m)\n```\n\n最终路径: [[0, 2, 5, 4], [9, 0, 3, 4], [6, 8, 0, 1], [5, 7, 10, 0]]\n\n通过这种方法我们可以求出任意两个点之间最短路径。它的时间复杂度是 O(n<sup>3</sup>)\n","slug":"floyd","published":1,"updated":"2020-03-24T08:39:43.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jvm00090j9kjw2xicsb","content":"<h2 id=\"floyd算法\"><a href=\"#floyd算法\" class=\"headerlink\" title=\"floyd算法\"></a>floyd算法</h2><p>弗洛伊德算法又称插点法是<strong>解决任意两点间的最短路径的一种算法</strong></p>\n<h2 id=\"适用范围\"><a href=\"#适用范围\" class=\"headerlink\" title=\"适用范围\"></a>适用范围</h2><p>边权可正可负，运行一次算法即可求得任意两点间的最短路径（无负权回路即可）</p>\n<p>可以解决“多源最短路径”</p>\n<h3 id=\"什么是负权回路\"><a href=\"#什么是负权回路\" class=\"headerlink\" title=\"什么是负权回路\"></a>什么是负权回路</h3><p>图中1号点到3号点的最短路径是什么？</p>\n<p><img src=\"http://s1.wailian.download/2020/03/24/6.10.png\" alt=\"6.10.png\"></p>\n<p>由于每次经过1-&gt;2-&gt;3这样的环，最短路径就会-1，所有永远找不到最短路径</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p><img src=\"http://s1.wailian.download/2020/03/24/6.2-floyd.png\" alt=\"6.2-floyd.png\"></p>\n<p>计算图中各个顶点到各个顶点的最短距离</p>\n<p>首先我们定义一个二维数组来存储图中最易可见的点对点(不允许经过第三点)之间的距离，如果不能到达使用∞表示。另外规定自己到自己的距离是0，具体表示如下</p>\n<p><a href=\"http://www.wailian.work/image/Ae1zve\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s1.wailian.download/2020/03/24/6.3-.png\" alt=\"6.3-.png\"></a></p>\n<p>如果要使两点之间距离变短，唯一方法就是通过第三个点来解决。例如a点到b点的距离通过顶点k来中转那么a-&gt;k-&gt;b才有可能缩短a-&gt;b的距离。那么这个k点是哪个点呢？是否不只通过1个k点最短，而是经过两个或者更多点最短，比如a-&gt;k1-&gt;k2&gt;b</p>\n<p>比如图中4-&gt;3的距离是12，如果经过1点，那么4-&gt;1-&gt;3的距离就变为11。现在只允许经过1号点，求i点到j点的最短距离，只需判断e[i][1]+e[1][j]是否比e[i][j]要小。代码实现如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python3</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个4行4列的二维数组</span></span><br><span class=\"line\">m = [[<span class=\"number\">0</span>]*<span class=\"number\">4</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为数组赋值</span></span><br><span class=\"line\">m[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">m[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"number\">2</span></span><br><span class=\"line\">m[<span class=\"number\">0</span>][<span class=\"number\">2</span>] = <span class=\"number\">6</span></span><br><span class=\"line\">m[<span class=\"number\">0</span>][<span class=\"number\">3</span>] = <span class=\"number\">4</span></span><br><span class=\"line\">m[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">9999</span></span><br><span class=\"line\">m[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">m[<span class=\"number\">1</span>][<span class=\"number\">2</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">m[<span class=\"number\">1</span>][<span class=\"number\">3</span>] = <span class=\"number\">9999</span></span><br><span class=\"line\">m[<span class=\"number\">2</span>][<span class=\"number\">0</span>] = <span class=\"number\">7</span></span><br><span class=\"line\">m[<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"number\">9999</span></span><br><span class=\"line\">m[<span class=\"number\">2</span>][<span class=\"number\">2</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">m[<span class=\"number\">2</span>][<span class=\"number\">3</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">m[<span class=\"number\">3</span>][<span class=\"number\">0</span>] = <span class=\"number\">5</span></span><br><span class=\"line\">m[<span class=\"number\">3</span>][<span class=\"number\">1</span>] = <span class=\"number\">9999</span></span><br><span class=\"line\">m[<span class=\"number\">3</span>][<span class=\"number\">2</span>] = <span class=\"number\">12</span></span><br><span class=\"line\">m[<span class=\"number\">3</span>][<span class=\"number\">3</span>] = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'原路径数据:'</span>, m)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 允许经过1号点的最短路径</span></span><br><span class=\"line\">n = copy.deepcopy(m)</span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\">j = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n[i][j] &gt; n[i][<span class=\"number\">0</span>] + n[<span class=\"number\">0</span>][j]):</span><br><span class=\"line\">                n[i][j] = n[i][<span class=\"number\">0</span>] + n[<span class=\"number\">0</span>][j]</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'在允许经过1号点后的最短路径:'</span>, n)</span><br></pre></td></tr></table></figure>\n<p>执行结果如下：</p>\n<p>原路径数据: [[0, 2, 6, 4], [9999, 0, 3, 9999], [7, 9999, 0, 1], [5, 9999, 12, 0]]</p>\n<p>在允许经过1号点后的最短路径: [[0, 2, 6, 4], [9999, 0, 3, 9999], [7, 9, 0, 1], [5, 7, 11, 0]]</p>\n<p><img src=\"http://s1.wailian.download/2020/03/24/6.5-1.png\" alt=\"6.5-1.png\"></p>\n<p>通过图中白色背景处我们可以看到通过1号点中转的情况下,3-&gt;2,4-&gt;2,4-&gt;3的路径都变短了</p>\n<p>接下来求只允许1号和2号点的情况下任意两点间的最短距离，如何做呢？我们只需要在只经过1号点时任意两点最短距离的结果下，再判断经过2号顶点如何使i号点到j号点的路径边的更短</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 再允许经过2号点后的路径</span></span><br><span class=\"line\">o = copy.deepcopy(n)</span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\">j = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(o[i][j] &gt; o[i][<span class=\"number\">1</span>] + o[<span class=\"number\">1</span>][j]):</span><br><span class=\"line\">            o[i][j] = o[i][<span class=\"number\">1</span>] + o[<span class=\"number\">1</span>][j]</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'再允许经过2号点后的最短路径:'</span>, o)</span><br></pre></td></tr></table></figure>\n<p>执行结果如下：</p>\n<p>再允许经过2号点后的最短路径: [[0, 2, 5, 4], [9999, 0, 3, 9999], [7, 9, 0, 1], [5, 7, 10, 0]]</p>\n<p><img src=\"http://s1.wailian.download/2020/03/24/6.6-1-2.png\" alt=\"6.6-1-2.png\"></p>\n<p>同理继续在只允许1，2，3进行中转的情况下求最短距离。</p>\n<p><img src=\"http://s1.wailian.download/2020/03/24/6.7-1-2-3.png\" alt=\"6.7-1-2-3.png\"></p>\n<p>最后在允许通过所有顶点作为中转，任意两点之间最终的最短路径为：</p>\n<p><img src=\"http://s1.wailian.download/2020/03/24/6.8-1-2-3-4.png\" alt=\"6.8-1-2-3-4.png\"></p>\n<p>整个算法最终代码实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k = <span class=\"number\">0</span></span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\">j = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m[i][j] &gt; m[i][k] + m[k][j]):</span><br><span class=\"line\">                m[i][j] = m[i][k] + m[k][j]</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'最终路径:'</span>, m)</span><br></pre></td></tr></table></figure>\n<p>最终路径: [[0, 2, 5, 4], [9, 0, 3, 4], [6, 8, 0, 1], [5, 7, 10, 0]]</p>\n<p>通过这种方法我们可以求出任意两个点之间最短路径。它的时间复杂度是 O(n<sup>3</sup>)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"floyd算法\"><a href=\"#floyd算法\" class=\"headerlink\" title=\"floyd算法\"></a>floyd算法</h2><p>弗洛伊德算法又称插点法是<strong>解决任意两点间的最短路径的一种算法</strong></p>\n<h2 id=\"适用范围\"><a href=\"#适用范围\" class=\"headerlink\" title=\"适用范围\"></a>适用范围</h2><p>边权可正可负，运行一次算法即可求得任意两点间的最短路径（无负权回路即可）</p>\n<p>可以解决“多源最短路径”</p>\n<h3 id=\"什么是负权回路\"><a href=\"#什么是负权回路\" class=\"headerlink\" title=\"什么是负权回路\"></a>什么是负权回路</h3><p>图中1号点到3号点的最短路径是什么？</p>\n<p><img src=\"http://s1.wailian.download/2020/03/24/6.10.png\" alt=\"6.10.png\"></p>\n<p>由于每次经过1-&gt;2-&gt;3这样的环，最短路径就会-1，所有永远找不到最短路径</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p><img src=\"http://s1.wailian.download/2020/03/24/6.2-floyd.png\" alt=\"6.2-floyd.png\"></p>\n<p>计算图中各个顶点到各个顶点的最短距离</p>\n<p>首先我们定义一个二维数组来存储图中最易可见的点对点(不允许经过第三点)之间的距离，如果不能到达使用∞表示。另外规定自己到自己的距离是0，具体表示如下</p>\n<p><a href=\"http://www.wailian.work/image/Ae1zve\" target=\"_blank\" rel=\"noopener\"><img src=\"http://s1.wailian.download/2020/03/24/6.3-.png\" alt=\"6.3-.png\"></a></p>\n<p>如果要使两点之间距离变短，唯一方法就是通过第三个点来解决。例如a点到b点的距离通过顶点k来中转那么a-&gt;k-&gt;b才有可能缩短a-&gt;b的距离。那么这个k点是哪个点呢？是否不只通过1个k点最短，而是经过两个或者更多点最短，比如a-&gt;k1-&gt;k2&gt;b</p>\n<p>比如图中4-&gt;3的距离是12，如果经过1点，那么4-&gt;1-&gt;3的距离就变为11。现在只允许经过1号点，求i点到j点的最短距离，只需判断e[i][1]+e[1][j]是否比e[i][j]要小。代码实现如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python3</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个4行4列的二维数组</span></span><br><span class=\"line\">m = [[<span class=\"number\">0</span>]*<span class=\"number\">4</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为数组赋值</span></span><br><span class=\"line\">m[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">m[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"number\">2</span></span><br><span class=\"line\">m[<span class=\"number\">0</span>][<span class=\"number\">2</span>] = <span class=\"number\">6</span></span><br><span class=\"line\">m[<span class=\"number\">0</span>][<span class=\"number\">3</span>] = <span class=\"number\">4</span></span><br><span class=\"line\">m[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">9999</span></span><br><span class=\"line\">m[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">m[<span class=\"number\">1</span>][<span class=\"number\">2</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">m[<span class=\"number\">1</span>][<span class=\"number\">3</span>] = <span class=\"number\">9999</span></span><br><span class=\"line\">m[<span class=\"number\">2</span>][<span class=\"number\">0</span>] = <span class=\"number\">7</span></span><br><span class=\"line\">m[<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"number\">9999</span></span><br><span class=\"line\">m[<span class=\"number\">2</span>][<span class=\"number\">2</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">m[<span class=\"number\">2</span>][<span class=\"number\">3</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">m[<span class=\"number\">3</span>][<span class=\"number\">0</span>] = <span class=\"number\">5</span></span><br><span class=\"line\">m[<span class=\"number\">3</span>][<span class=\"number\">1</span>] = <span class=\"number\">9999</span></span><br><span class=\"line\">m[<span class=\"number\">3</span>][<span class=\"number\">2</span>] = <span class=\"number\">12</span></span><br><span class=\"line\">m[<span class=\"number\">3</span>][<span class=\"number\">3</span>] = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'原路径数据:'</span>, m)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 允许经过1号点的最短路径</span></span><br><span class=\"line\">n = copy.deepcopy(m)</span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\">j = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n[i][j] &gt; n[i][<span class=\"number\">0</span>] + n[<span class=\"number\">0</span>][j]):</span><br><span class=\"line\">                n[i][j] = n[i][<span class=\"number\">0</span>] + n[<span class=\"number\">0</span>][j]</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'在允许经过1号点后的最短路径:'</span>, n)</span><br></pre></td></tr></table></figure>\n<p>执行结果如下：</p>\n<p>原路径数据: [[0, 2, 6, 4], [9999, 0, 3, 9999], [7, 9999, 0, 1], [5, 9999, 12, 0]]</p>\n<p>在允许经过1号点后的最短路径: [[0, 2, 6, 4], [9999, 0, 3, 9999], [7, 9, 0, 1], [5, 7, 11, 0]]</p>\n<p><img src=\"http://s1.wailian.download/2020/03/24/6.5-1.png\" alt=\"6.5-1.png\"></p>\n<p>通过图中白色背景处我们可以看到通过1号点中转的情况下,3-&gt;2,4-&gt;2,4-&gt;3的路径都变短了</p>\n<p>接下来求只允许1号和2号点的情况下任意两点间的最短距离，如何做呢？我们只需要在只经过1号点时任意两点最短距离的结果下，再判断经过2号顶点如何使i号点到j号点的路径边的更短</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 再允许经过2号点后的路径</span></span><br><span class=\"line\">o = copy.deepcopy(n)</span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\">j = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(o[i][j] &gt; o[i][<span class=\"number\">1</span>] + o[<span class=\"number\">1</span>][j]):</span><br><span class=\"line\">            o[i][j] = o[i][<span class=\"number\">1</span>] + o[<span class=\"number\">1</span>][j]</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'再允许经过2号点后的最短路径:'</span>, o)</span><br></pre></td></tr></table></figure>\n<p>执行结果如下：</p>\n<p>再允许经过2号点后的最短路径: [[0, 2, 5, 4], [9999, 0, 3, 9999], [7, 9, 0, 1], [5, 7, 10, 0]]</p>\n<p><img src=\"http://s1.wailian.download/2020/03/24/6.6-1-2.png\" alt=\"6.6-1-2.png\"></p>\n<p>同理继续在只允许1，2，3进行中转的情况下求最短距离。</p>\n<p><img src=\"http://s1.wailian.download/2020/03/24/6.7-1-2-3.png\" alt=\"6.7-1-2-3.png\"></p>\n<p>最后在允许通过所有顶点作为中转，任意两点之间最终的最短路径为：</p>\n<p><img src=\"http://s1.wailian.download/2020/03/24/6.8-1-2-3-4.png\" alt=\"6.8-1-2-3-4.png\"></p>\n<p>整个算法最终代码实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k = <span class=\"number\">0</span></span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\">j = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m[i][j] &gt; m[i][k] + m[k][j]):</span><br><span class=\"line\">                m[i][j] = m[i][k] + m[k][j]</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'最终路径:'</span>, m)</span><br></pre></td></tr></table></figure>\n<p>最终路径: [[0, 2, 5, 4], [9, 0, 3, 4], [6, 8, 0, 1], [5, 7, 10, 0]]</p>\n<p>通过这种方法我们可以求出任意两个点之间最短路径。它的时间复杂度是 O(n<sup>3</sup>)</p>\n"},{"title":"Git笔记","date":"2018-02-02T05:58:28.000Z","_content":"\n![pic](http://www.wailian.work/images/2018/02/06/e58c7755f88b1e0ad82a30100cd3f781e3fe8f5970ada-GGAkXt_fw658.jpg)\n\n# 初始化项目\n\n## 在GitHub或者码云上新建仓库\n\n登录GitHub或者码云，新建仓库，不默认产生README文档\n\n## 本地新建仓库\n\n```\ngit init\n```\n\n## 本地仓库与远程相连\n\n```\ngit remote add origin git@git.oschina.net:wangweiye/SpringBoot-Learning.git\n```\n\n## 提交本地到远程\n\n```\ngit add .\n\ngit commit -m \"\"\n\ngit pull origin master\n\ngit push -u origin master\n```\n\n# 标签\n\n## 列显已有的标签\n\n```\ngit tag\n```\n\n## 新建轻量级标签\n\n```\ngit tag v1.0.0\n```\n\n## 分享标签\n\n```\ngit push origin [tagname]\n```\n\n## 删除远程tag\n\n```\ngit push origin --delete tag [tagname]\n```\n\n# .gitignore无效解决方法\n\n在工程中很容易出现.gitignore并没有忽略掉我们已经添加的文件，那是因为.gitignore对已经追踪(track)的文件是无效的，需要清除缓存，清除缓存后文件将以未追踪的形式出现，这时重新添加(add)并提交(commit)就可以了。\n\n```\ngit rm -r --cached .\ngit add .\ngit commit -m \"comment\"\n```\n","source":"_posts/git-remote.md","raw":"---\ntitle: Git笔记\ndate: 2018-02-02 13:58:28\ntags:\n---\n\n![pic](http://www.wailian.work/images/2018/02/06/e58c7755f88b1e0ad82a30100cd3f781e3fe8f5970ada-GGAkXt_fw658.jpg)\n\n# 初始化项目\n\n## 在GitHub或者码云上新建仓库\n\n登录GitHub或者码云，新建仓库，不默认产生README文档\n\n## 本地新建仓库\n\n```\ngit init\n```\n\n## 本地仓库与远程相连\n\n```\ngit remote add origin git@git.oschina.net:wangweiye/SpringBoot-Learning.git\n```\n\n## 提交本地到远程\n\n```\ngit add .\n\ngit commit -m \"\"\n\ngit pull origin master\n\ngit push -u origin master\n```\n\n# 标签\n\n## 列显已有的标签\n\n```\ngit tag\n```\n\n## 新建轻量级标签\n\n```\ngit tag v1.0.0\n```\n\n## 分享标签\n\n```\ngit push origin [tagname]\n```\n\n## 删除远程tag\n\n```\ngit push origin --delete tag [tagname]\n```\n\n# .gitignore无效解决方法\n\n在工程中很容易出现.gitignore并没有忽略掉我们已经添加的文件，那是因为.gitignore对已经追踪(track)的文件是无效的，需要清除缓存，清除缓存后文件将以未追踪的形式出现，这时重新添加(add)并提交(commit)就可以了。\n\n```\ngit rm -r --cached .\ngit add .\ngit commit -m \"comment\"\n```\n","slug":"git-remote","published":1,"updated":"2019-12-24T02:00:57.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jvo000a0j9k7fbli8yv","content":"<p><img src=\"http://www.wailian.work/images/2018/02/06/e58c7755f88b1e0ad82a30100cd3f781e3fe8f5970ada-GGAkXt_fw658.jpg\" alt=\"pic\"></p>\n<h1 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h1><h2 id=\"在GitHub或者码云上新建仓库\"><a href=\"#在GitHub或者码云上新建仓库\" class=\"headerlink\" title=\"在GitHub或者码云上新建仓库\"></a>在GitHub或者码云上新建仓库</h2><p>登录GitHub或者码云，新建仓库，不默认产生README文档</p>\n<h2 id=\"本地新建仓库\"><a href=\"#本地新建仓库\" class=\"headerlink\" title=\"本地新建仓库\"></a>本地新建仓库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<h2 id=\"本地仓库与远程相连\"><a href=\"#本地仓库与远程相连\" class=\"headerlink\" title=\"本地仓库与远程相连\"></a>本地仓库与远程相连</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@git.oschina.net:wangweiye/SpringBoot-Learning.git</span><br></pre></td></tr></table></figure>\n<h2 id=\"提交本地到远程\"><a href=\"#提交本地到远程\" class=\"headerlink\" title=\"提交本地到远程\"></a>提交本地到远程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\">git commit -m &quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">git pull origin master</span><br><span class=\"line\"></span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><h2 id=\"列显已有的标签\"><a href=\"#列显已有的标签\" class=\"headerlink\" title=\"列显已有的标签\"></a>列显已有的标签</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag</span><br></pre></td></tr></table></figure>\n<h2 id=\"新建轻量级标签\"><a href=\"#新建轻量级标签\" class=\"headerlink\" title=\"新建轻量级标签\"></a>新建轻量级标签</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v1.0.0</span><br></pre></td></tr></table></figure>\n<h2 id=\"分享标签\"><a href=\"#分享标签\" class=\"headerlink\" title=\"分享标签\"></a>分享标签</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin [tagname]</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除远程tag\"><a href=\"#删除远程tag\" class=\"headerlink\" title=\"删除远程tag\"></a>删除远程tag</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --delete tag [tagname]</span><br></pre></td></tr></table></figure>\n<h1 id=\"gitignore无效解决方法\"><a href=\"#gitignore无效解决方法\" class=\"headerlink\" title=\".gitignore无效解决方法\"></a>.gitignore无效解决方法</h1><p>在工程中很容易出现.gitignore并没有忽略掉我们已经添加的文件，那是因为.gitignore对已经追踪(track)的文件是无效的，需要清除缓存，清除缓存后文件将以未追踪的形式出现，这时重新添加(add)并提交(commit)就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r --cached .</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;comment&quot;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/02/06/e58c7755f88b1e0ad82a30100cd3f781e3fe8f5970ada-GGAkXt_fw658.jpg\" alt=\"pic\"></p>\n<h1 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h1><h2 id=\"在GitHub或者码云上新建仓库\"><a href=\"#在GitHub或者码云上新建仓库\" class=\"headerlink\" title=\"在GitHub或者码云上新建仓库\"></a>在GitHub或者码云上新建仓库</h2><p>登录GitHub或者码云，新建仓库，不默认产生README文档</p>\n<h2 id=\"本地新建仓库\"><a href=\"#本地新建仓库\" class=\"headerlink\" title=\"本地新建仓库\"></a>本地新建仓库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<h2 id=\"本地仓库与远程相连\"><a href=\"#本地仓库与远程相连\" class=\"headerlink\" title=\"本地仓库与远程相连\"></a>本地仓库与远程相连</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@git.oschina.net:wangweiye/SpringBoot-Learning.git</span><br></pre></td></tr></table></figure>\n<h2 id=\"提交本地到远程\"><a href=\"#提交本地到远程\" class=\"headerlink\" title=\"提交本地到远程\"></a>提交本地到远程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\">git commit -m &quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">git pull origin master</span><br><span class=\"line\"></span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><h2 id=\"列显已有的标签\"><a href=\"#列显已有的标签\" class=\"headerlink\" title=\"列显已有的标签\"></a>列显已有的标签</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag</span><br></pre></td></tr></table></figure>\n<h2 id=\"新建轻量级标签\"><a href=\"#新建轻量级标签\" class=\"headerlink\" title=\"新建轻量级标签\"></a>新建轻量级标签</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v1.0.0</span><br></pre></td></tr></table></figure>\n<h2 id=\"分享标签\"><a href=\"#分享标签\" class=\"headerlink\" title=\"分享标签\"></a>分享标签</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin [tagname]</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除远程tag\"><a href=\"#删除远程tag\" class=\"headerlink\" title=\"删除远程tag\"></a>删除远程tag</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --delete tag [tagname]</span><br></pre></td></tr></table></figure>\n<h1 id=\"gitignore无效解决方法\"><a href=\"#gitignore无效解决方法\" class=\"headerlink\" title=\".gitignore无效解决方法\"></a>.gitignore无效解决方法</h1><p>在工程中很容易出现.gitignore并没有忽略掉我们已经添加的文件，那是因为.gitignore对已经追踪(track)的文件是无效的，需要清除缓存，清除缓存后文件将以未追踪的形式出现，这时重新添加(add)并提交(commit)就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r --cached .</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;comment&quot;</span><br></pre></td></tr></table></figure>\n"},{"title":"Hello World","_content":"![pic](http://s1.wailian.download/2018/01/18/2850153e0f1cdea447791b1b3d0211ec7692fae81faba-YHBVwv_fw658.jpg)\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\n![pic](http://s1.wailian.download/2018/01/18/2850153e0f1cdea447791b1b3d0211ec7692fae81faba-YHBVwv_fw658.jpg)\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2019-12-24T02:00:57.000Z","updated":"2019-12-24T02:00:57.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jvs000b0j9k3uqchwso","content":"<p><img src=\"http://s1.wailian.download/2018/01/18/2850153e0f1cdea447791b1b3d0211ec7692fae81faba-YHBVwv_fw658.jpg\" alt=\"pic\"><br>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://s1.wailian.download/2018/01/18/2850153e0f1cdea447791b1b3d0211ec7692fae81faba-YHBVwv_fw658.jpg\" alt=\"pic\"><br>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"jasypt优雅加密","date":"2018-09-18T00:41:27.000Z","_content":"![](http://www.wailian.work/images/2018/09/18/botanical-close-up-color-788485.jpg)\n\n# 介绍\n\n使用Spring Boot开发时，如果配置文件的敏感信息以明文方式展示，将加大系统的安全隐患，使用jasypt加密，十分简单的解决了这个问题\n\n# 使用方法\n\n1. 在项目的启动类中(Application.java)增加注解`@EnableEncryptableProperties`;\n2. 增加配置文件`jasypt.encryptor.password = xxxx`,这是加密的密钥;\n3. 将配置文件中所有的敏感信息替换为`ENC(加密字符串)`;\n4. 引入maven依赖;\n\n```\n<dependency>\n    <groupId>com.github.ulisesbocchio</groupId>\n    <artifactId>jasypt-spring-boot-starter</artifactId>\n    <version>1.9</version>\n</dependency>\n```\n\n## 生成密钥的方法\n\n```\njava -cp /Users/wangweiye/.m2/repository/org/jasypt/jasypt/1.9.2/jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=\"root\" password=xxxx algorithm=PBEWithMD5AndDES\n```\n\n- input为需要加密的字符串;\n- password为配置文件中设置的加密密钥;\n\n## Java项目内使用\n\n### 加密\n\n```\npublic void encrypt() {\n    // 创建加密器\n    StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor();\n    // 配置\n    EnvironmentStringPBEConfig config = new EnvironmentStringPBEConfig();\n    config.setAlgorithm(\"PBEWithMD5AndDES\");// 加密算法\n    config.setPassword(\"xxxx\");// 密码\n    encryptor.setConfig(config);\n\n    String plaintext = \"root\"; //明文\n    String ciphertext = encryptor.encrypt(plaintext); // 加密\n    System.out.println(plaintext + \" : \" + ciphertext);// 运行结果：root : root : zLdyNB+Dj3iw+J+TXZiv5g==\n}\n```\n\n### 解密\n\n```\npublic void decrypt() {\n    StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor();\n    EnvironmentStringPBEConfig config = new EnvironmentStringPBEConfig();\n    config.setAlgorithm(\"PBEWithMD5AndDES\");\n    config.setPassword(\"xxxx\");\n    encryptor.setConfig(config);\n    String ciphertext = \"zLdyNB+Dj3iw+J+TXZiv5g==\";// 密文\n\n    //解密\n    String plaintext = encryptor.decrypt(ciphertext); // 解密\n    assertThat(plaintext).isEqualTo(\"root\");\n}\n```\n","source":"_posts/jasypt.md","raw":"---\ntitle: jasypt优雅加密\ndate: 2018-09-18 08:41:27\ntags:\n---\n![](http://www.wailian.work/images/2018/09/18/botanical-close-up-color-788485.jpg)\n\n# 介绍\n\n使用Spring Boot开发时，如果配置文件的敏感信息以明文方式展示，将加大系统的安全隐患，使用jasypt加密，十分简单的解决了这个问题\n\n# 使用方法\n\n1. 在项目的启动类中(Application.java)增加注解`@EnableEncryptableProperties`;\n2. 增加配置文件`jasypt.encryptor.password = xxxx`,这是加密的密钥;\n3. 将配置文件中所有的敏感信息替换为`ENC(加密字符串)`;\n4. 引入maven依赖;\n\n```\n<dependency>\n    <groupId>com.github.ulisesbocchio</groupId>\n    <artifactId>jasypt-spring-boot-starter</artifactId>\n    <version>1.9</version>\n</dependency>\n```\n\n## 生成密钥的方法\n\n```\njava -cp /Users/wangweiye/.m2/repository/org/jasypt/jasypt/1.9.2/jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=\"root\" password=xxxx algorithm=PBEWithMD5AndDES\n```\n\n- input为需要加密的字符串;\n- password为配置文件中设置的加密密钥;\n\n## Java项目内使用\n\n### 加密\n\n```\npublic void encrypt() {\n    // 创建加密器\n    StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor();\n    // 配置\n    EnvironmentStringPBEConfig config = new EnvironmentStringPBEConfig();\n    config.setAlgorithm(\"PBEWithMD5AndDES\");// 加密算法\n    config.setPassword(\"xxxx\");// 密码\n    encryptor.setConfig(config);\n\n    String plaintext = \"root\"; //明文\n    String ciphertext = encryptor.encrypt(plaintext); // 加密\n    System.out.println(plaintext + \" : \" + ciphertext);// 运行结果：root : root : zLdyNB+Dj3iw+J+TXZiv5g==\n}\n```\n\n### 解密\n\n```\npublic void decrypt() {\n    StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor();\n    EnvironmentStringPBEConfig config = new EnvironmentStringPBEConfig();\n    config.setAlgorithm(\"PBEWithMD5AndDES\");\n    config.setPassword(\"xxxx\");\n    encryptor.setConfig(config);\n    String ciphertext = \"zLdyNB+Dj3iw+J+TXZiv5g==\";// 密文\n\n    //解密\n    String plaintext = encryptor.decrypt(ciphertext); // 解密\n    assertThat(plaintext).isEqualTo(\"root\");\n}\n```\n","slug":"jasypt","published":1,"updated":"2019-12-24T02:00:57.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jvv000c0j9kk7jwphau","content":"<p><img src=\"http://www.wailian.work/images/2018/09/18/botanical-close-up-color-788485.jpg\" alt=\"\"></p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>使用Spring Boot开发时，如果配置文件的敏感信息以明文方式展示，将加大系统的安全隐患，使用jasypt加密，十分简单的解决了这个问题</p>\n<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><ol>\n<li>在项目的启动类中(Application.java)增加注解<code>@EnableEncryptableProperties</code>;</li>\n<li>增加配置文件<code>jasypt.encryptor.password = xxxx</code>,这是加密的密钥;</li>\n<li>将配置文件中所有的敏感信息替换为<code>ENC(加密字符串)</code>;</li>\n<li>引入maven依赖;</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.9&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成密钥的方法\"><a href=\"#生成密钥的方法\" class=\"headerlink\" title=\"生成密钥的方法\"></a>生成密钥的方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp /Users/wangweiye/.m2/repository/org/jasypt/jasypt/1.9.2/jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=&quot;root&quot; password=xxxx algorithm=PBEWithMD5AndDES</span><br></pre></td></tr></table></figure>\n<ul>\n<li>input为需要加密的字符串;</li>\n<li>password为配置文件中设置的加密密钥;</li>\n</ul>\n<h2 id=\"Java项目内使用\"><a href=\"#Java项目内使用\" class=\"headerlink\" title=\"Java项目内使用\"></a>Java项目内使用</h2><h3 id=\"加密\"><a href=\"#加密\" class=\"headerlink\" title=\"加密\"></a>加密</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void encrypt() &#123;</span><br><span class=\"line\">    // 创建加密器</span><br><span class=\"line\">    StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor();</span><br><span class=\"line\">    // 配置</span><br><span class=\"line\">    EnvironmentStringPBEConfig config = new EnvironmentStringPBEConfig();</span><br><span class=\"line\">    config.setAlgorithm(&quot;PBEWithMD5AndDES&quot;);// 加密算法</span><br><span class=\"line\">    config.setPassword(&quot;xxxx&quot;);// 密码</span><br><span class=\"line\">    encryptor.setConfig(config);</span><br><span class=\"line\"></span><br><span class=\"line\">    String plaintext = &quot;root&quot;; //明文</span><br><span class=\"line\">    String ciphertext = encryptor.encrypt(plaintext); // 加密</span><br><span class=\"line\">    System.out.println(plaintext + &quot; : &quot; + ciphertext);// 运行结果：root : root : zLdyNB+Dj3iw+J+TXZiv5g==</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解密\"><a href=\"#解密\" class=\"headerlink\" title=\"解密\"></a>解密</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void decrypt() &#123;</span><br><span class=\"line\">    StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor();</span><br><span class=\"line\">    EnvironmentStringPBEConfig config = new EnvironmentStringPBEConfig();</span><br><span class=\"line\">    config.setAlgorithm(&quot;PBEWithMD5AndDES&quot;);</span><br><span class=\"line\">    config.setPassword(&quot;xxxx&quot;);</span><br><span class=\"line\">    encryptor.setConfig(config);</span><br><span class=\"line\">    String ciphertext = &quot;zLdyNB+Dj3iw+J+TXZiv5g==&quot;;// 密文</span><br><span class=\"line\"></span><br><span class=\"line\">    //解密</span><br><span class=\"line\">    String plaintext = encryptor.decrypt(ciphertext); // 解密</span><br><span class=\"line\">    assertThat(plaintext).isEqualTo(&quot;root&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/09/18/botanical-close-up-color-788485.jpg\" alt=\"\"></p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>使用Spring Boot开发时，如果配置文件的敏感信息以明文方式展示，将加大系统的安全隐患，使用jasypt加密，十分简单的解决了这个问题</p>\n<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><ol>\n<li>在项目的启动类中(Application.java)增加注解<code>@EnableEncryptableProperties</code>;</li>\n<li>增加配置文件<code>jasypt.encryptor.password = xxxx</code>,这是加密的密钥;</li>\n<li>将配置文件中所有的敏感信息替换为<code>ENC(加密字符串)</code>;</li>\n<li>引入maven依赖;</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.9&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成密钥的方法\"><a href=\"#生成密钥的方法\" class=\"headerlink\" title=\"生成密钥的方法\"></a>生成密钥的方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp /Users/wangweiye/.m2/repository/org/jasypt/jasypt/1.9.2/jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=&quot;root&quot; password=xxxx algorithm=PBEWithMD5AndDES</span><br></pre></td></tr></table></figure>\n<ul>\n<li>input为需要加密的字符串;</li>\n<li>password为配置文件中设置的加密密钥;</li>\n</ul>\n<h2 id=\"Java项目内使用\"><a href=\"#Java项目内使用\" class=\"headerlink\" title=\"Java项目内使用\"></a>Java项目内使用</h2><h3 id=\"加密\"><a href=\"#加密\" class=\"headerlink\" title=\"加密\"></a>加密</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void encrypt() &#123;</span><br><span class=\"line\">    // 创建加密器</span><br><span class=\"line\">    StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor();</span><br><span class=\"line\">    // 配置</span><br><span class=\"line\">    EnvironmentStringPBEConfig config = new EnvironmentStringPBEConfig();</span><br><span class=\"line\">    config.setAlgorithm(&quot;PBEWithMD5AndDES&quot;);// 加密算法</span><br><span class=\"line\">    config.setPassword(&quot;xxxx&quot;);// 密码</span><br><span class=\"line\">    encryptor.setConfig(config);</span><br><span class=\"line\"></span><br><span class=\"line\">    String plaintext = &quot;root&quot;; //明文</span><br><span class=\"line\">    String ciphertext = encryptor.encrypt(plaintext); // 加密</span><br><span class=\"line\">    System.out.println(plaintext + &quot; : &quot; + ciphertext);// 运行结果：root : root : zLdyNB+Dj3iw+J+TXZiv5g==</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解密\"><a href=\"#解密\" class=\"headerlink\" title=\"解密\"></a>解密</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void decrypt() &#123;</span><br><span class=\"line\">    StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor();</span><br><span class=\"line\">    EnvironmentStringPBEConfig config = new EnvironmentStringPBEConfig();</span><br><span class=\"line\">    config.setAlgorithm(&quot;PBEWithMD5AndDES&quot;);</span><br><span class=\"line\">    config.setPassword(&quot;xxxx&quot;);</span><br><span class=\"line\">    encryptor.setConfig(config);</span><br><span class=\"line\">    String ciphertext = &quot;zLdyNB+Dj3iw+J+TXZiv5g==&quot;;// 密文</span><br><span class=\"line\"></span><br><span class=\"line\">    //解密</span><br><span class=\"line\">    String plaintext = encryptor.decrypt(ciphertext); // 解密</span><br><span class=\"line\">    assertThat(plaintext).isEqualTo(&quot;root&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"深度剖析Java拆箱与装箱","date":"2018-12-25T07:07:05.000Z","_content":"\n# 什么是拆箱和装箱\n\nJava中为每种基本类型都提供了对应的包装器类型。拆箱就是把包装器类型转换为基本数据类型的过程；装箱就是把基本数据类型转换为包装器类型的过程。\n\n```java\nInteger i = 10; // 装箱\n\nint b = i; // 拆箱\n```\n\nJava中拆箱和装箱的实现过程是：\n\n以Double类型举例\n\n拆箱：调用doubleValue方法;\n\n装箱：调用Double.valueOf方法\n\n# 面试相关问题\n\n## Integer比较\n\n```java\nInteger i1 = 100;\nInteger i2 = 100;\nInteger i3 = 200;\nInteger i4 = 200;\n\nassertThat(i1 == i2).isEqualTo(true);\nassertThat(i3 == i4).isEqualTo(false);\n```\n\n比较过程：\n\n1. 调用Integer.valueOf()方法将各个变量装箱;\n\n2. 装箱后比较各个变量指向的内存地址是否相同。\n\n但是为什么以上两个结果不同呢？看一下Integer的valueOf方法的实现便知究竟\n\n```java\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n\n```java\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n```\n\n通过分析源码，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。\n\n## Double类型比较\n\n那么Double类型是否相同呢？\n\n```java\nDouble d1 = 100.0;\nDouble d2 = 100.0;\nDouble d3 = 200.0;\nDouble d4 = 200.0;\n\nassertThat(d1 == d2).isEqualTo(false);\nassertThat(d3 == d4).isEqualTo(false);\n```\n\n\b\b原因同样我们去看Double.valueOf的源码实现\n\n```java\npublic static Double valueOf(String s) throws NumberFormatException {\n    return new Double(parseDouble(s));\n}\n```\n\n通过分析源码，doub\ble类型在每一次装箱时，都会新建一个对象。\n\n## Boolean类型比较\n\n```java\nBoolean i1 = false;\nBoolean i2 = false;\nBoolean i3 = true;\nBoolean i4 = true;\n  \nassertThat(i1 == i2).isEqualTo(true);\nassertThat(i3 == i4).isEqualTo(true);\n```\n\n同样看Boolean.valueOf的源码实现\n\n```java\n\npublic static final Boolean TRUE = new Boolean(true);\n\npublic static final Boolean FALSE = new Boolean(false);\n\npublic static Boolean valueOf(boolean b) {\n    return (b ? TRUE : FALSE);\n}\n```\n\n# 关于equals和==\n\n## ==\n\n如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；\n\n如果作用于引用类型的变量，则比较的是所指向的内存地址\n\n## equals\n\n如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；\n\n诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。","source":"_posts/java-pack-unpack.md","raw":"---\ntitle: 深度剖析Java拆箱与装箱\ndate: 2018-12-25 15:07:05\ntags:\n---\n\n# 什么是拆箱和装箱\n\nJava中为每种基本类型都提供了对应的包装器类型。拆箱就是把包装器类型转换为基本数据类型的过程；装箱就是把基本数据类型转换为包装器类型的过程。\n\n```java\nInteger i = 10; // 装箱\n\nint b = i; // 拆箱\n```\n\nJava中拆箱和装箱的实现过程是：\n\n以Double类型举例\n\n拆箱：调用doubleValue方法;\n\n装箱：调用Double.valueOf方法\n\n# 面试相关问题\n\n## Integer比较\n\n```java\nInteger i1 = 100;\nInteger i2 = 100;\nInteger i3 = 200;\nInteger i4 = 200;\n\nassertThat(i1 == i2).isEqualTo(true);\nassertThat(i3 == i4).isEqualTo(false);\n```\n\n比较过程：\n\n1. 调用Integer.valueOf()方法将各个变量装箱;\n\n2. 装箱后比较各个变量指向的内存地址是否相同。\n\n但是为什么以上两个结果不同呢？看一下Integer的valueOf方法的实现便知究竟\n\n```java\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n\n```java\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n```\n\n通过分析源码，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。\n\n## Double类型比较\n\n那么Double类型是否相同呢？\n\n```java\nDouble d1 = 100.0;\nDouble d2 = 100.0;\nDouble d3 = 200.0;\nDouble d4 = 200.0;\n\nassertThat(d1 == d2).isEqualTo(false);\nassertThat(d3 == d4).isEqualTo(false);\n```\n\n\b\b原因同样我们去看Double.valueOf的源码实现\n\n```java\npublic static Double valueOf(String s) throws NumberFormatException {\n    return new Double(parseDouble(s));\n}\n```\n\n通过分析源码，doub\ble类型在每一次装箱时，都会新建一个对象。\n\n## Boolean类型比较\n\n```java\nBoolean i1 = false;\nBoolean i2 = false;\nBoolean i3 = true;\nBoolean i4 = true;\n  \nassertThat(i1 == i2).isEqualTo(true);\nassertThat(i3 == i4).isEqualTo(true);\n```\n\n同样看Boolean.valueOf的源码实现\n\n```java\n\npublic static final Boolean TRUE = new Boolean(true);\n\npublic static final Boolean FALSE = new Boolean(false);\n\npublic static Boolean valueOf(boolean b) {\n    return (b ? TRUE : FALSE);\n}\n```\n\n# 关于equals和==\n\n## ==\n\n如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；\n\n如果作用于引用类型的变量，则比较的是所指向的内存地址\n\n## equals\n\n如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；\n\n诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。","slug":"java-pack-unpack","published":1,"updated":"2019-12-24T02:00:57.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jvx000d0j9kzi9qsl45","content":"<h1 id=\"什么是拆箱和装箱\"><a href=\"#什么是拆箱和装箱\" class=\"headerlink\" title=\"什么是拆箱和装箱\"></a>什么是拆箱和装箱</h1><p>Java中为每种基本类型都提供了对应的包装器类型。拆箱就是把包装器类型转换为基本数据类型的过程；装箱就是把基本数据类型转换为包装器类型的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = <span class=\"number\">10</span>; <span class=\"comment\">// 装箱</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> b = i; <span class=\"comment\">// 拆箱</span></span><br></pre></td></tr></table></figure>\n<p>Java中拆箱和装箱的实现过程是：</p>\n<p>以Double类型举例</p>\n<p>拆箱：调用doubleValue方法;</p>\n<p>装箱：调用Double.valueOf方法</p>\n<h1 id=\"面试相关问题\"><a href=\"#面试相关问题\" class=\"headerlink\" title=\"面试相关问题\"></a>面试相关问题</h1><h2 id=\"Integer比较\"><a href=\"#Integer比较\" class=\"headerlink\" title=\"Integer比较\"></a>Integer比较</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">100</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">100</span>;</span><br><span class=\"line\">Integer i3 = <span class=\"number\">200</span>;</span><br><span class=\"line\">Integer i4 = <span class=\"number\">200</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">assertThat(i1 == i2).isEqualTo(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">assertThat(i3 == i4).isEqualTo(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>比较过程：</p>\n<ol>\n<li><p>调用Integer.valueOf()方法将各个变量装箱;</p>\n</li>\n<li><p>装箱后比较各个变量指向的内存地址是否相同。</p>\n</li>\n</ol>\n<p>但是为什么以上两个结果不同呢？看一下Integer的valueOf方法的实现便知究竟</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerCache</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> low = -<span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> high;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// high value may be configured by property</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = <span class=\"number\">127</span>;</span><br><span class=\"line\">        String integerCacheHighPropValue =</span><br><span class=\"line\">            sun.misc.VM.getSavedProperty(<span class=\"string\">\"java.lang.Integer.IntegerCache.high\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (integerCacheHighPropValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                i = Math.max(i, <span class=\"number\">127</span>);</span><br><span class=\"line\">                <span class=\"comment\">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class=\"line\">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>( NumberFormatException nfe) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        high = h;</span><br><span class=\"line\"></span><br><span class=\"line\">        cache = <span class=\"keyword\">new</span> Integer[(high - low) + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = low;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; cache.length; k++)</span><br><span class=\"line\">            cache[k] = <span class=\"keyword\">new</span> Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> IntegerCache.high &gt;= <span class=\"number\">127</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IntegerCache</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过分析源码，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p>\n<h2 id=\"Double类型比较\"><a href=\"#Double类型比较\" class=\"headerlink\" title=\"Double类型比较\"></a>Double类型比较</h2><p>那么Double类型是否相同呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Double d1 = <span class=\"number\">100.0</span>;</span><br><span class=\"line\">Double d2 = <span class=\"number\">100.0</span>;</span><br><span class=\"line\">Double d3 = <span class=\"number\">200.0</span>;</span><br><span class=\"line\">Double d4 = <span class=\"number\">200.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">assertThat(d1 == d2).isEqualTo(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">assertThat(d3 == d4).isEqualTo(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>\b\b原因同样我们去看Double.valueOf的源码实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Double <span class=\"title\">valueOf</span><span class=\"params\">(String s)</span> <span class=\"keyword\">throws</span> NumberFormatException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Double(parseDouble(s));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过分析源码，doub\ble类型在每一次装箱时，都会新建一个对象。</p>\n<h2 id=\"Boolean类型比较\"><a href=\"#Boolean类型比较\" class=\"headerlink\" title=\"Boolean类型比较\"></a>Boolean类型比较</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean i1 = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">Boolean i2 = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">Boolean i3 = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">Boolean i4 = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">assertThat(i1 == i2).isEqualTo(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">assertThat(i3 == i4).isEqualTo(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>同样看Boolean.valueOf的源码实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Boolean TRUE = <span class=\"keyword\">new</span> Boolean(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Boolean FALSE = <span class=\"keyword\">new</span> Boolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Boolean <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (b ? TRUE : FALSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"关于equals和\"><a href=\"#关于equals和\" class=\"headerlink\" title=\"关于equals和==\"></a>关于equals和==</h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"==\"></a>==</h2><p>如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</p>\n<p>如果作用于引用类型的变量，则比较的是所指向的内存地址</p>\n<h2 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals\"></a>equals</h2><p>如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</p>\n<p>诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是拆箱和装箱\"><a href=\"#什么是拆箱和装箱\" class=\"headerlink\" title=\"什么是拆箱和装箱\"></a>什么是拆箱和装箱</h1><p>Java中为每种基本类型都提供了对应的包装器类型。拆箱就是把包装器类型转换为基本数据类型的过程；装箱就是把基本数据类型转换为包装器类型的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = <span class=\"number\">10</span>; <span class=\"comment\">// 装箱</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> b = i; <span class=\"comment\">// 拆箱</span></span><br></pre></td></tr></table></figure>\n<p>Java中拆箱和装箱的实现过程是：</p>\n<p>以Double类型举例</p>\n<p>拆箱：调用doubleValue方法;</p>\n<p>装箱：调用Double.valueOf方法</p>\n<h1 id=\"面试相关问题\"><a href=\"#面试相关问题\" class=\"headerlink\" title=\"面试相关问题\"></a>面试相关问题</h1><h2 id=\"Integer比较\"><a href=\"#Integer比较\" class=\"headerlink\" title=\"Integer比较\"></a>Integer比较</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">100</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">100</span>;</span><br><span class=\"line\">Integer i3 = <span class=\"number\">200</span>;</span><br><span class=\"line\">Integer i4 = <span class=\"number\">200</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">assertThat(i1 == i2).isEqualTo(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">assertThat(i3 == i4).isEqualTo(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>比较过程：</p>\n<ol>\n<li><p>调用Integer.valueOf()方法将各个变量装箱;</p>\n</li>\n<li><p>装箱后比较各个变量指向的内存地址是否相同。</p>\n</li>\n</ol>\n<p>但是为什么以上两个结果不同呢？看一下Integer的valueOf方法的实现便知究竟</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerCache</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> low = -<span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> high;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// high value may be configured by property</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = <span class=\"number\">127</span>;</span><br><span class=\"line\">        String integerCacheHighPropValue =</span><br><span class=\"line\">            sun.misc.VM.getSavedProperty(<span class=\"string\">\"java.lang.Integer.IntegerCache.high\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (integerCacheHighPropValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                i = Math.max(i, <span class=\"number\">127</span>);</span><br><span class=\"line\">                <span class=\"comment\">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class=\"line\">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>( NumberFormatException nfe) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        high = h;</span><br><span class=\"line\"></span><br><span class=\"line\">        cache = <span class=\"keyword\">new</span> Integer[(high - low) + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = low;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; cache.length; k++)</span><br><span class=\"line\">            cache[k] = <span class=\"keyword\">new</span> Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> IntegerCache.high &gt;= <span class=\"number\">127</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IntegerCache</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过分析源码，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p>\n<h2 id=\"Double类型比较\"><a href=\"#Double类型比较\" class=\"headerlink\" title=\"Double类型比较\"></a>Double类型比较</h2><p>那么Double类型是否相同呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Double d1 = <span class=\"number\">100.0</span>;</span><br><span class=\"line\">Double d2 = <span class=\"number\">100.0</span>;</span><br><span class=\"line\">Double d3 = <span class=\"number\">200.0</span>;</span><br><span class=\"line\">Double d4 = <span class=\"number\">200.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">assertThat(d1 == d2).isEqualTo(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">assertThat(d3 == d4).isEqualTo(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>\b\b原因同样我们去看Double.valueOf的源码实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Double <span class=\"title\">valueOf</span><span class=\"params\">(String s)</span> <span class=\"keyword\">throws</span> NumberFormatException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Double(parseDouble(s));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过分析源码，doub\ble类型在每一次装箱时，都会新建一个对象。</p>\n<h2 id=\"Boolean类型比较\"><a href=\"#Boolean类型比较\" class=\"headerlink\" title=\"Boolean类型比较\"></a>Boolean类型比较</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean i1 = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">Boolean i2 = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">Boolean i3 = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">Boolean i4 = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">assertThat(i1 == i2).isEqualTo(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">assertThat(i3 == i4).isEqualTo(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>同样看Boolean.valueOf的源码实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Boolean TRUE = <span class=\"keyword\">new</span> Boolean(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Boolean FALSE = <span class=\"keyword\">new</span> Boolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Boolean <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (b ? TRUE : FALSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"关于equals和\"><a href=\"#关于equals和\" class=\"headerlink\" title=\"关于equals和==\"></a>关于equals和==</h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"==\"></a>==</h2><p>如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</p>\n<p>如果作用于引用类型的变量，则比较的是所指向的内存地址</p>\n<h2 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals\"></a>equals</h2><p>如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</p>\n<p>诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p>\n"},{"title":"java新特性讲义","date":"2018-01-20T14:03:18.000Z","_content":"\n# Predicate操作集合\n\nJava 8为Collection集合新增一个removeIf(Predicate filter)方法，该方法将会批量删除符合filter条件的所有元素。该方法需要一个Predicate对象作为参数，Predicate也是函数式接口，因此可使用Lamada表达式作为参数。\n\n```\nCollection books = new HashSet();\nbooks.add(new String(\"123\"));\nbooks.add(new String(\"1234\"));\nbooks.add(new String(\"12345\"));\nbooks.add(new String(\"123456\"));\n// 使用Lamada表达式过滤集合\nbooks.removeIf(ele -> ((String)ele).length() < 3);\nSystem.out.println(books);\n```\n\n上面程序中调用了Collection集合的removeIf()方法批量删除集合中符合条件的元素，程序中传入了一个Lamada表达式作为过滤条件。\n\nPredicate就是一个函数式接口，可以把它当做C语言中函数指针来使用；\n\n```\npublic class Test {\n\n    public static void operate(Collection c, Predicate p) { // 满足谓词条件p的元素都打印出来\n        for (Object ele: c) {\n            if (p.test(ele)) {\n                System.out.println(ele);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Collection c = new ArrayList();\n        for (int i = 0; i < 10; i++) { // 加入0 ~ 9的字符串\n            c.add(String.valueOf(i));\n        }\n\n        operate(c, ele -> Integer.valueOf((String)ele) > 3); // 大于3的打印出来\n    }\n}\n```\n","source":"_posts/java.md","raw":"---\ntitle: java新特性讲义\ndate: 2018-01-20 22:03:18\ntags:\n---\n\n# Predicate操作集合\n\nJava 8为Collection集合新增一个removeIf(Predicate filter)方法，该方法将会批量删除符合filter条件的所有元素。该方法需要一个Predicate对象作为参数，Predicate也是函数式接口，因此可使用Lamada表达式作为参数。\n\n```\nCollection books = new HashSet();\nbooks.add(new String(\"123\"));\nbooks.add(new String(\"1234\"));\nbooks.add(new String(\"12345\"));\nbooks.add(new String(\"123456\"));\n// 使用Lamada表达式过滤集合\nbooks.removeIf(ele -> ((String)ele).length() < 3);\nSystem.out.println(books);\n```\n\n上面程序中调用了Collection集合的removeIf()方法批量删除集合中符合条件的元素，程序中传入了一个Lamada表达式作为过滤条件。\n\nPredicate就是一个函数式接口，可以把它当做C语言中函数指针来使用；\n\n```\npublic class Test {\n\n    public static void operate(Collection c, Predicate p) { // 满足谓词条件p的元素都打印出来\n        for (Object ele: c) {\n            if (p.test(ele)) {\n                System.out.println(ele);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Collection c = new ArrayList();\n        for (int i = 0; i < 10; i++) { // 加入0 ~ 9的字符串\n            c.add(String.valueOf(i));\n        }\n\n        operate(c, ele -> Integer.valueOf((String)ele) > 3); // 大于3的打印出来\n    }\n}\n```\n","slug":"java","published":1,"updated":"2019-12-24T02:00:57.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jvy000e0j9k7zyzc7p5","content":"<h1 id=\"Predicate操作集合\"><a href=\"#Predicate操作集合\" class=\"headerlink\" title=\"Predicate操作集合\"></a>Predicate操作集合</h1><p>Java 8为Collection集合新增一个removeIf(Predicate filter)方法，该方法将会批量删除符合filter条件的所有元素。该方法需要一个Predicate对象作为参数，Predicate也是函数式接口，因此可使用Lamada表达式作为参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collection books = new HashSet();</span><br><span class=\"line\">books.add(new String(&quot;123&quot;));</span><br><span class=\"line\">books.add(new String(&quot;1234&quot;));</span><br><span class=\"line\">books.add(new String(&quot;12345&quot;));</span><br><span class=\"line\">books.add(new String(&quot;123456&quot;));</span><br><span class=\"line\">// 使用Lamada表达式过滤集合</span><br><span class=\"line\">books.removeIf(ele -&gt; ((String)ele).length() &lt; 3);</span><br><span class=\"line\">System.out.println(books);</span><br></pre></td></tr></table></figure>\n<p>上面程序中调用了Collection集合的removeIf()方法批量删除集合中符合条件的元素，程序中传入了一个Lamada表达式作为过滤条件。</p>\n<p>Predicate就是一个函数式接口，可以把它当做C语言中函数指针来使用；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void operate(Collection c, Predicate p) &#123; // 满足谓词条件p的元素都打印出来</span><br><span class=\"line\">        for (Object ele: c) &#123;</span><br><span class=\"line\">            if (p.test(ele)) &#123;</span><br><span class=\"line\">                System.out.println(ele);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Collection c = new ArrayList();</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123; // 加入0 ~ 9的字符串</span><br><span class=\"line\">            c.add(String.valueOf(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        operate(c, ele -&gt; Integer.valueOf((String)ele) &gt; 3); // 大于3的打印出来</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Predicate操作集合\"><a href=\"#Predicate操作集合\" class=\"headerlink\" title=\"Predicate操作集合\"></a>Predicate操作集合</h1><p>Java 8为Collection集合新增一个removeIf(Predicate filter)方法，该方法将会批量删除符合filter条件的所有元素。该方法需要一个Predicate对象作为参数，Predicate也是函数式接口，因此可使用Lamada表达式作为参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collection books = new HashSet();</span><br><span class=\"line\">books.add(new String(&quot;123&quot;));</span><br><span class=\"line\">books.add(new String(&quot;1234&quot;));</span><br><span class=\"line\">books.add(new String(&quot;12345&quot;));</span><br><span class=\"line\">books.add(new String(&quot;123456&quot;));</span><br><span class=\"line\">// 使用Lamada表达式过滤集合</span><br><span class=\"line\">books.removeIf(ele -&gt; ((String)ele).length() &lt; 3);</span><br><span class=\"line\">System.out.println(books);</span><br></pre></td></tr></table></figure>\n<p>上面程序中调用了Collection集合的removeIf()方法批量删除集合中符合条件的元素，程序中传入了一个Lamada表达式作为过滤条件。</p>\n<p>Predicate就是一个函数式接口，可以把它当做C语言中函数指针来使用；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void operate(Collection c, Predicate p) &#123; // 满足谓词条件p的元素都打印出来</span><br><span class=\"line\">        for (Object ele: c) &#123;</span><br><span class=\"line\">            if (p.test(ele)) &#123;</span><br><span class=\"line\">                System.out.println(ele);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Collection c = new ArrayList();</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123; // 加入0 ~ 9的字符串</span><br><span class=\"line\">            c.add(String.valueOf(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        operate(c, ele -&gt; Integer.valueOf((String)ele) &gt; 3); // 大于3的打印出来</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Jenkins部署Spring Boot","date":"2017-12-15T15:00:10.000Z","_content":"# 持续集成是什么？\n\n互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）\n\n# 持续集成的目的\n\n让产品可以快速迭代，同时还能保持高质量\n\n# Jenkins是什么？\n\nJenkins是一个用Java编写的开源的持续集成工具，因此安装Jenkins必须有Java运行环境\n\n# Jenkins安装\n\n[官网](https://jenkins.io/download/)下载Jenkins安装包，按照官网提示进行安装\n\n## 安装常用插件\n![常用插件](http://s1.wailian.download/2017/12/18/1eebae.png)\n## 创建密码\n![创建密码](http://s1.wailian.download/2017/12/18/2625d8.png)\n\n注意：需要防火墙打开8080端口，Jenkins默认使用8080端口\n\n# Jenkins的配置\n\n## 全局工具配置\n\n- 配置jdk\n![](http://s1.wailian.download/2017/12/18/2ad234.png)\n- 配置maven\n![](http://s1.wailian.download/2017/12/18/3711fb.png)\n\n## 插件安装\n\nJenkins有很多插件已经被安装，其中Git plugin和Maven Integration plugin，publish over SSH是部署Spring Boot项目必备的插件\n\n## 配置Credentials\n\n配置成功后可以用ssh协议拉取git上的代码\n\n![](http://s1.wailian.download/2017/12/15/1.png)\n","source":"_posts/jenkins.md","raw":"---\ntitle: Jenkins部署Spring Boot\ndate: 2017-12-15 23:00:10\ntags:\n---\n# 持续集成是什么？\n\n互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）\n\n# 持续集成的目的\n\n让产品可以快速迭代，同时还能保持高质量\n\n# Jenkins是什么？\n\nJenkins是一个用Java编写的开源的持续集成工具，因此安装Jenkins必须有Java运行环境\n\n# Jenkins安装\n\n[官网](https://jenkins.io/download/)下载Jenkins安装包，按照官网提示进行安装\n\n## 安装常用插件\n![常用插件](http://s1.wailian.download/2017/12/18/1eebae.png)\n## 创建密码\n![创建密码](http://s1.wailian.download/2017/12/18/2625d8.png)\n\n注意：需要防火墙打开8080端口，Jenkins默认使用8080端口\n\n# Jenkins的配置\n\n## 全局工具配置\n\n- 配置jdk\n![](http://s1.wailian.download/2017/12/18/2ad234.png)\n- 配置maven\n![](http://s1.wailian.download/2017/12/18/3711fb.png)\n\n## 插件安装\n\nJenkins有很多插件已经被安装，其中Git plugin和Maven Integration plugin，publish over SSH是部署Spring Boot项目必备的插件\n\n## 配置Credentials\n\n配置成功后可以用ssh协议拉取git上的代码\n\n![](http://s1.wailian.download/2017/12/15/1.png)\n","slug":"jenkins","published":1,"updated":"2019-12-24T02:00:57.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jvz000f0j9kpvpxwzo3","content":"<h1 id=\"持续集成是什么？\"><a href=\"#持续集成是什么？\" class=\"headerlink\" title=\"持续集成是什么？\"></a>持续集成是什么？</h1><p>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）</p>\n<h1 id=\"持续集成的目的\"><a href=\"#持续集成的目的\" class=\"headerlink\" title=\"持续集成的目的\"></a>持续集成的目的</h1><p>让产品可以快速迭代，同时还能保持高质量</p>\n<h1 id=\"Jenkins是什么？\"><a href=\"#Jenkins是什么？\" class=\"headerlink\" title=\"Jenkins是什么？\"></a>Jenkins是什么？</h1><p>Jenkins是一个用Java编写的开源的持续集成工具，因此安装Jenkins必须有Java运行环境</p>\n<h1 id=\"Jenkins安装\"><a href=\"#Jenkins安装\" class=\"headerlink\" title=\"Jenkins安装\"></a>Jenkins安装</h1><p><a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"noopener\">官网</a>下载Jenkins安装包，按照官网提示进行安装</p>\n<h2 id=\"安装常用插件\"><a href=\"#安装常用插件\" class=\"headerlink\" title=\"安装常用插件\"></a>安装常用插件</h2><p><img src=\"http://s1.wailian.download/2017/12/18/1eebae.png\" alt=\"常用插件\"></p>\n<h2 id=\"创建密码\"><a href=\"#创建密码\" class=\"headerlink\" title=\"创建密码\"></a>创建密码</h2><p><img src=\"http://s1.wailian.download/2017/12/18/2625d8.png\" alt=\"创建密码\"></p>\n<p>注意：需要防火墙打开8080端口，Jenkins默认使用8080端口</p>\n<h1 id=\"Jenkins的配置\"><a href=\"#Jenkins的配置\" class=\"headerlink\" title=\"Jenkins的配置\"></a>Jenkins的配置</h1><h2 id=\"全局工具配置\"><a href=\"#全局工具配置\" class=\"headerlink\" title=\"全局工具配置\"></a>全局工具配置</h2><ul>\n<li>配置jdk<br><img src=\"http://s1.wailian.download/2017/12/18/2ad234.png\" alt=\"\"></li>\n<li>配置maven<br><img src=\"http://s1.wailian.download/2017/12/18/3711fb.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h2><p>Jenkins有很多插件已经被安装，其中Git plugin和Maven Integration plugin，publish over SSH是部署Spring Boot项目必备的插件</p>\n<h2 id=\"配置Credentials\"><a href=\"#配置Credentials\" class=\"headerlink\" title=\"配置Credentials\"></a>配置Credentials</h2><p>配置成功后可以用ssh协议拉取git上的代码</p>\n<p><img src=\"http://s1.wailian.download/2017/12/15/1.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"持续集成是什么？\"><a href=\"#持续集成是什么？\" class=\"headerlink\" title=\"持续集成是什么？\"></a>持续集成是什么？</h1><p>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）</p>\n<h1 id=\"持续集成的目的\"><a href=\"#持续集成的目的\" class=\"headerlink\" title=\"持续集成的目的\"></a>持续集成的目的</h1><p>让产品可以快速迭代，同时还能保持高质量</p>\n<h1 id=\"Jenkins是什么？\"><a href=\"#Jenkins是什么？\" class=\"headerlink\" title=\"Jenkins是什么？\"></a>Jenkins是什么？</h1><p>Jenkins是一个用Java编写的开源的持续集成工具，因此安装Jenkins必须有Java运行环境</p>\n<h1 id=\"Jenkins安装\"><a href=\"#Jenkins安装\" class=\"headerlink\" title=\"Jenkins安装\"></a>Jenkins安装</h1><p><a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"noopener\">官网</a>下载Jenkins安装包，按照官网提示进行安装</p>\n<h2 id=\"安装常用插件\"><a href=\"#安装常用插件\" class=\"headerlink\" title=\"安装常用插件\"></a>安装常用插件</h2><p><img src=\"http://s1.wailian.download/2017/12/18/1eebae.png\" alt=\"常用插件\"></p>\n<h2 id=\"创建密码\"><a href=\"#创建密码\" class=\"headerlink\" title=\"创建密码\"></a>创建密码</h2><p><img src=\"http://s1.wailian.download/2017/12/18/2625d8.png\" alt=\"创建密码\"></p>\n<p>注意：需要防火墙打开8080端口，Jenkins默认使用8080端口</p>\n<h1 id=\"Jenkins的配置\"><a href=\"#Jenkins的配置\" class=\"headerlink\" title=\"Jenkins的配置\"></a>Jenkins的配置</h1><h2 id=\"全局工具配置\"><a href=\"#全局工具配置\" class=\"headerlink\" title=\"全局工具配置\"></a>全局工具配置</h2><ul>\n<li>配置jdk<br><img src=\"http://s1.wailian.download/2017/12/18/2ad234.png\" alt=\"\"></li>\n<li>配置maven<br><img src=\"http://s1.wailian.download/2017/12/18/3711fb.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h2><p>Jenkins有很多插件已经被安装，其中Git plugin和Maven Integration plugin，publish over SSH是部署Spring Boot项目必备的插件</p>\n<h2 id=\"配置Credentials\"><a href=\"#配置Credentials\" class=\"headerlink\" title=\"配置Credentials\"></a>配置Credentials</h2><p>配置成功后可以用ssh协议拉取git上的代码</p>\n<p><img src=\"http://s1.wailian.download/2017/12/15/1.png\" alt=\"\"></p>\n"},{"title":"Linux用户权限","date":"2017-12-20T08:10:19.000Z","_content":"\n![](http://www.wailian.work/images/2018/04/18/121.jpg)\n\nCentOS默认允许任何用户通过ssh登入，但是在企业应用中为了保证服务器的安全性一般不允许用户直接通过root用户登录，而是通过普通用户登录然后切换到root或者使用sudo权限来执行root用户命令\n\n# 创建用户\n\n## 创建普通用户\n\n```\nuseradd wangweiye\n```\n## 为普通用户设置密码\n\n```\npasswd wangweiye\n```\n\n## 将普通用户移入wheel用户组\n\n```\nusermod -G wheel wangweiye\n```\n\n> 在Linux中wheel组类似于管理员组\n\n这样就可以使用普通用户wangweiye来进行登录了,而且该用户拥有sudo权限\n\n在一般情况下，一般用户通过执行`su`命令、输入正确的root密码，可以登录为root用户来对系统进行管理员级别的配置。但是，为了更进一步加强系统的安全性，有必要建立一个管理员的组，只允许这个组的用户来执行`su`命令登录为root用户，而让其他组的用户即使执行`su`输入了正确的root密码，也无法登录为root用户。在UNIX下，这个组的名称通常为`wheel`。\n\n如何配置只有wheel组的用户才能登录root用户呢？\n\n1. 将`/etc/pam.d/su`中的`#auth required /lib/security/$ISA/pam_wheel.so use_uid`注释去掉\n\n2. 将`SU_WHEEL_ONLY yes`添加到`/etc/login.defs`文件行末\n\n# 禁止root用户ssh登录\n\n## 修改配置文件\n\n修改`/etc/ssh/sshd_config`将`PermitRootLogin`设置为no即可\n\n## 重启ssh服务\n\n`systemctl restart sshd.service`重启ssh服务\n\n# 给用户分配sudo权限\n\n如果只想给用户sudo权限而不能切换root用户登录(不加入wheel组)\n\n```\nvim /etc/sudoers\n```\n\n![](http://www.wailian.work/images/2018/04/18/121.png)\n","source":"_posts/linux-safe.md","raw":"---\ntitle: Linux用户权限\ndate: 2017-12-20 16:10:19\ntags:\n---\n\n![](http://www.wailian.work/images/2018/04/18/121.jpg)\n\nCentOS默认允许任何用户通过ssh登入，但是在企业应用中为了保证服务器的安全性一般不允许用户直接通过root用户登录，而是通过普通用户登录然后切换到root或者使用sudo权限来执行root用户命令\n\n# 创建用户\n\n## 创建普通用户\n\n```\nuseradd wangweiye\n```\n## 为普通用户设置密码\n\n```\npasswd wangweiye\n```\n\n## 将普通用户移入wheel用户组\n\n```\nusermod -G wheel wangweiye\n```\n\n> 在Linux中wheel组类似于管理员组\n\n这样就可以使用普通用户wangweiye来进行登录了,而且该用户拥有sudo权限\n\n在一般情况下，一般用户通过执行`su`命令、输入正确的root密码，可以登录为root用户来对系统进行管理员级别的配置。但是，为了更进一步加强系统的安全性，有必要建立一个管理员的组，只允许这个组的用户来执行`su`命令登录为root用户，而让其他组的用户即使执行`su`输入了正确的root密码，也无法登录为root用户。在UNIX下，这个组的名称通常为`wheel`。\n\n如何配置只有wheel组的用户才能登录root用户呢？\n\n1. 将`/etc/pam.d/su`中的`#auth required /lib/security/$ISA/pam_wheel.so use_uid`注释去掉\n\n2. 将`SU_WHEEL_ONLY yes`添加到`/etc/login.defs`文件行末\n\n# 禁止root用户ssh登录\n\n## 修改配置文件\n\n修改`/etc/ssh/sshd_config`将`PermitRootLogin`设置为no即可\n\n## 重启ssh服务\n\n`systemctl restart sshd.service`重启ssh服务\n\n# 给用户分配sudo权限\n\n如果只想给用户sudo权限而不能切换root用户登录(不加入wheel组)\n\n```\nvim /etc/sudoers\n```\n\n![](http://www.wailian.work/images/2018/04/18/121.png)\n","slug":"linux-safe","published":1,"updated":"2019-12-24T02:00:57.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jw0000g0j9k4kj76u6b","content":"<p><img src=\"http://www.wailian.work/images/2018/04/18/121.jpg\" alt=\"\"></p>\n<p>CentOS默认允许任何用户通过ssh登入，但是在企业应用中为了保证服务器的安全性一般不允许用户直接通过root用户登录，而是通过普通用户登录然后切换到root或者使用sudo权限来执行root用户命令</p>\n<h1 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h1><h2 id=\"创建普通用户\"><a href=\"#创建普通用户\" class=\"headerlink\" title=\"创建普通用户\"></a>创建普通用户</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd wangweiye</span><br></pre></td></tr></table></figure>\n<h2 id=\"为普通用户设置密码\"><a href=\"#为普通用户设置密码\" class=\"headerlink\" title=\"为普通用户设置密码\"></a>为普通用户设置密码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passwd wangweiye</span><br></pre></td></tr></table></figure>\n<h2 id=\"将普通用户移入wheel用户组\"><a href=\"#将普通用户移入wheel用户组\" class=\"headerlink\" title=\"将普通用户移入wheel用户组\"></a>将普通用户移入wheel用户组</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">usermod -G wheel wangweiye</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在Linux中wheel组类似于管理员组</p>\n</blockquote>\n<p>这样就可以使用普通用户wangweiye来进行登录了,而且该用户拥有sudo权限</p>\n<p>在一般情况下，一般用户通过执行<code>su</code>命令、输入正确的root密码，可以登录为root用户来对系统进行管理员级别的配置。但是，为了更进一步加强系统的安全性，有必要建立一个管理员的组，只允许这个组的用户来执行<code>su</code>命令登录为root用户，而让其他组的用户即使执行<code>su</code>输入了正确的root密码，也无法登录为root用户。在UNIX下，这个组的名称通常为<code>wheel</code>。</p>\n<p>如何配置只有wheel组的用户才能登录root用户呢？</p>\n<ol>\n<li><p>将<code>/etc/pam.d/su</code>中的<code>#auth required /lib/security/$ISA/pam_wheel.so use_uid</code>注释去掉</p>\n</li>\n<li><p>将<code>SU_WHEEL_ONLY yes</code>添加到<code>/etc/login.defs</code>文件行末</p>\n</li>\n</ol>\n<h1 id=\"禁止root用户ssh登录\"><a href=\"#禁止root用户ssh登录\" class=\"headerlink\" title=\"禁止root用户ssh登录\"></a>禁止root用户ssh登录</h1><h2 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h2><p>修改<code>/etc/ssh/sshd_config</code>将<code>PermitRootLogin</code>设置为no即可</p>\n<h2 id=\"重启ssh服务\"><a href=\"#重启ssh服务\" class=\"headerlink\" title=\"重启ssh服务\"></a>重启ssh服务</h2><p><code>systemctl restart sshd.service</code>重启ssh服务</p>\n<h1 id=\"给用户分配sudo权限\"><a href=\"#给用户分配sudo权限\" class=\"headerlink\" title=\"给用户分配sudo权限\"></a>给用户分配sudo权限</h1><p>如果只想给用户sudo权限而不能切换root用户登录(不加入wheel组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/sudoers</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/04/18/121.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/04/18/121.jpg\" alt=\"\"></p>\n<p>CentOS默认允许任何用户通过ssh登入，但是在企业应用中为了保证服务器的安全性一般不允许用户直接通过root用户登录，而是通过普通用户登录然后切换到root或者使用sudo权限来执行root用户命令</p>\n<h1 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h1><h2 id=\"创建普通用户\"><a href=\"#创建普通用户\" class=\"headerlink\" title=\"创建普通用户\"></a>创建普通用户</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd wangweiye</span><br></pre></td></tr></table></figure>\n<h2 id=\"为普通用户设置密码\"><a href=\"#为普通用户设置密码\" class=\"headerlink\" title=\"为普通用户设置密码\"></a>为普通用户设置密码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passwd wangweiye</span><br></pre></td></tr></table></figure>\n<h2 id=\"将普通用户移入wheel用户组\"><a href=\"#将普通用户移入wheel用户组\" class=\"headerlink\" title=\"将普通用户移入wheel用户组\"></a>将普通用户移入wheel用户组</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">usermod -G wheel wangweiye</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在Linux中wheel组类似于管理员组</p>\n</blockquote>\n<p>这样就可以使用普通用户wangweiye来进行登录了,而且该用户拥有sudo权限</p>\n<p>在一般情况下，一般用户通过执行<code>su</code>命令、输入正确的root密码，可以登录为root用户来对系统进行管理员级别的配置。但是，为了更进一步加强系统的安全性，有必要建立一个管理员的组，只允许这个组的用户来执行<code>su</code>命令登录为root用户，而让其他组的用户即使执行<code>su</code>输入了正确的root密码，也无法登录为root用户。在UNIX下，这个组的名称通常为<code>wheel</code>。</p>\n<p>如何配置只有wheel组的用户才能登录root用户呢？</p>\n<ol>\n<li><p>将<code>/etc/pam.d/su</code>中的<code>#auth required /lib/security/$ISA/pam_wheel.so use_uid</code>注释去掉</p>\n</li>\n<li><p>将<code>SU_WHEEL_ONLY yes</code>添加到<code>/etc/login.defs</code>文件行末</p>\n</li>\n</ol>\n<h1 id=\"禁止root用户ssh登录\"><a href=\"#禁止root用户ssh登录\" class=\"headerlink\" title=\"禁止root用户ssh登录\"></a>禁止root用户ssh登录</h1><h2 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h2><p>修改<code>/etc/ssh/sshd_config</code>将<code>PermitRootLogin</code>设置为no即可</p>\n<h2 id=\"重启ssh服务\"><a href=\"#重启ssh服务\" class=\"headerlink\" title=\"重启ssh服务\"></a>重启ssh服务</h2><p><code>systemctl restart sshd.service</code>重启ssh服务</p>\n<h1 id=\"给用户分配sudo权限\"><a href=\"#给用户分配sudo权限\" class=\"headerlink\" title=\"给用户分配sudo权限\"></a>给用户分配sudo权限</h1><p>如果只想给用户sudo权限而不能切换root用户登录(不加入wheel组)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/sudoers</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/04/18/121.png\" alt=\"\"></p>\n"},{"title":"mac系统更新后git不可用","date":"2017-12-07T03:40:04.000Z","_content":"更新了系统后，使用git命令，提示错误如下：\n```\nxcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun\n```\n## 原因\n\n因为每次更新系统之后xcode就被卸载了，因此需要重新安装一次\n\n## 解决方案\n\n终端执行\n```\nxcode-select --install\n```\n","source":"_posts/mac-git.md","raw":"---\ntitle: mac系统更新后git不可用\ndate: 2017-12-07 11:40:04\ntags:\n---\n更新了系统后，使用git命令，提示错误如下：\n```\nxcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun\n```\n## 原因\n\n因为每次更新系统之后xcode就被卸载了，因此需要重新安装一次\n\n## 解决方案\n\n终端执行\n```\nxcode-select --install\n```\n","slug":"mac-git","published":1,"updated":"2019-12-24T02:00:57.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jw1000h0j9kk5j9h6os","content":"<p>更新了系统后，使用git命令，提示错误如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>因为每次更新系统之后xcode就被卸载了，因此需要重新安装一次</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>终端执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcode-select --install</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>更新了系统后，使用git命令，提示错误如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>因为每次更新系统之后xcode就被卸载了，因此需要重新安装一次</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>终端执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcode-select --install</span><br></pre></td></tr></table></figure></p>\n"},{"title":"MySql主从配置","date":"2018-01-26T01:07:07.000Z","_content":"![pic](http://www.wailian.work/images/2018/01/26/5d274a04c82163baf3c74ae5c97d16e80a641ed24163c7-YnTeKa_fw658.jpg)\n\nmysql版本使用的是5.7.20\n主库的IP为:47.104.71.88，从库的IP为:45.77.13.74\n\n# 读写分离(主从库)\n\n原理：让主库(master)处理事务性增改删，而从库(slave)处理查询操作\n\n# 主库创建用户\n\n```\nGRANT REPLICATION SLAVE,RELOAD,SUPER ON *.* TO synchrouser@45.77.13.74 IDENTIFIED BY 'w123456W!';\n```\n\n在主库创建一个synchrouser用户密码为w123456W!，并允许从库以synchrouser用户来登录\n\n# 配置主库\n\n在[mysqld]下增加配置\n\n```\nserver-id=88\nlog_bin=mysql-bin\nbinlog_format=mixed\n```\n\nserver-id在数据库配置中必须唯一，一般为IP最后一个节点（例如：47.104.71.88，则设置为88）设置完成后，重启mysql\n\n# 配置从库\n\n在[mysqld]增加配置\n\n```\nserver-id=74\n```\n\n设置完成后，重启mysql\n\n在主库执行:`show master status;`\n\n![](http://www.wailian.work/images/2018/01/26/WX20180126-091715.png)\n\n根据以上主库的信息设置从库\n\n```\nchange master to master_host='47.104.71.88',master_user='synchrouser',master_password='w123456W!',master_log_file='mysql-bin.000005',master_log_pos=840;\n```\n\nmaster_log_file字段对应了主库的File，master_log_pos字段对应了主库的Position\n\n# 启动主从同步\n\n从库执行\n\n```\nstart slave;\n```\n\n# 检查是否配置成功\n\n![](http://www.wailian.work/images/2018/01/26/4.png)\n\n如果Slave_IO_Running和Slave_SQL_Running都为Yes，代表配置成功\n\n# 测试主从同步\n\n主库创建一个库，一个表，观察从库是否同样创建\n\n## 设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除\n\n# 附录：\n\n到这里，全部库的主从配置就完成了，实际应用中可能会用到单个表的同步，或者部分表的同步，只需要在从库的/etc/my.cnf里加上\n\n只复制某个表replicate-do-table=dbname.tablename\n只复制某些表（可用匹配符）replicate-wild-do-table=dbname.tablename%\n只复制某个库replicate-do-db=dbname\n只复制某些库replicte-wild-do-db=dbname%\n不复制某个表replicate-ignore-table=dbname.tablename\n","source":"_posts/master-slave.md","raw":"---\ntitle: MySql主从配置\ndate: 2018-01-26 09:07:07\ntags:\n---\n![pic](http://www.wailian.work/images/2018/01/26/5d274a04c82163baf3c74ae5c97d16e80a641ed24163c7-YnTeKa_fw658.jpg)\n\nmysql版本使用的是5.7.20\n主库的IP为:47.104.71.88，从库的IP为:45.77.13.74\n\n# 读写分离(主从库)\n\n原理：让主库(master)处理事务性增改删，而从库(slave)处理查询操作\n\n# 主库创建用户\n\n```\nGRANT REPLICATION SLAVE,RELOAD,SUPER ON *.* TO synchrouser@45.77.13.74 IDENTIFIED BY 'w123456W!';\n```\n\n在主库创建一个synchrouser用户密码为w123456W!，并允许从库以synchrouser用户来登录\n\n# 配置主库\n\n在[mysqld]下增加配置\n\n```\nserver-id=88\nlog_bin=mysql-bin\nbinlog_format=mixed\n```\n\nserver-id在数据库配置中必须唯一，一般为IP最后一个节点（例如：47.104.71.88，则设置为88）设置完成后，重启mysql\n\n# 配置从库\n\n在[mysqld]增加配置\n\n```\nserver-id=74\n```\n\n设置完成后，重启mysql\n\n在主库执行:`show master status;`\n\n![](http://www.wailian.work/images/2018/01/26/WX20180126-091715.png)\n\n根据以上主库的信息设置从库\n\n```\nchange master to master_host='47.104.71.88',master_user='synchrouser',master_password='w123456W!',master_log_file='mysql-bin.000005',master_log_pos=840;\n```\n\nmaster_log_file字段对应了主库的File，master_log_pos字段对应了主库的Position\n\n# 启动主从同步\n\n从库执行\n\n```\nstart slave;\n```\n\n# 检查是否配置成功\n\n![](http://www.wailian.work/images/2018/01/26/4.png)\n\n如果Slave_IO_Running和Slave_SQL_Running都为Yes，代表配置成功\n\n# 测试主从同步\n\n主库创建一个库，一个表，观察从库是否同样创建\n\n## 设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除\n\n# 附录：\n\n到这里，全部库的主从配置就完成了，实际应用中可能会用到单个表的同步，或者部分表的同步，只需要在从库的/etc/my.cnf里加上\n\n只复制某个表replicate-do-table=dbname.tablename\n只复制某些表（可用匹配符）replicate-wild-do-table=dbname.tablename%\n只复制某个库replicate-do-db=dbname\n只复制某些库replicte-wild-do-db=dbname%\n不复制某个表replicate-ignore-table=dbname.tablename\n","slug":"master-slave","published":1,"updated":"2019-12-24T02:00:57.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jw2000i0j9khtyo3t64","content":"<p><img src=\"http://www.wailian.work/images/2018/01/26/5d274a04c82163baf3c74ae5c97d16e80a641ed24163c7-YnTeKa_fw658.jpg\" alt=\"pic\"></p>\n<p>mysql版本使用的是5.7.20<br>主库的IP为:47.104.71.88，从库的IP为:45.77.13.74</p>\n<h1 id=\"读写分离-主从库\"><a href=\"#读写分离-主从库\" class=\"headerlink\" title=\"读写分离(主从库)\"></a>读写分离(主从库)</h1><p>原理：让主库(master)处理事务性增改删，而从库(slave)处理查询操作</p>\n<h1 id=\"主库创建用户\"><a href=\"#主库创建用户\" class=\"headerlink\" title=\"主库创建用户\"></a>主库创建用户</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT REPLICATION SLAVE,RELOAD,SUPER ON *.* TO synchrouser@45.77.13.74 IDENTIFIED BY &apos;w123456W!&apos;;</span><br></pre></td></tr></table></figure>\n<p>在主库创建一个synchrouser用户密码为w123456W!，并允许从库以synchrouser用户来登录</p>\n<h1 id=\"配置主库\"><a href=\"#配置主库\" class=\"headerlink\" title=\"配置主库\"></a>配置主库</h1><p>在[mysqld]下增加配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server-id=88</span><br><span class=\"line\">log_bin=mysql-bin</span><br><span class=\"line\">binlog_format=mixed</span><br></pre></td></tr></table></figure>\n<p>server-id在数据库配置中必须唯一，一般为IP最后一个节点（例如：47.104.71.88，则设置为88）设置完成后，重启mysql</p>\n<h1 id=\"配置从库\"><a href=\"#配置从库\" class=\"headerlink\" title=\"配置从库\"></a>配置从库</h1><p>在[mysqld]增加配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server-id=74</span><br></pre></td></tr></table></figure>\n<p>设置完成后，重启mysql</p>\n<p>在主库执行:<code>show master status;</code></p>\n<p><img src=\"http://www.wailian.work/images/2018/01/26/WX20180126-091715.png\" alt=\"\"></p>\n<p>根据以上主库的信息设置从库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">change master to master_host=&apos;47.104.71.88&apos;,master_user=&apos;synchrouser&apos;,master_password=&apos;w123456W!&apos;,master_log_file=&apos;mysql-bin.000005&apos;,master_log_pos=840;</span><br></pre></td></tr></table></figure>\n<p>master_log_file字段对应了主库的File，master_log_pos字段对应了主库的Position</p>\n<h1 id=\"启动主从同步\"><a href=\"#启动主从同步\" class=\"headerlink\" title=\"启动主从同步\"></a>启动主从同步</h1><p>从库执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start slave;</span><br></pre></td></tr></table></figure>\n<h1 id=\"检查是否配置成功\"><a href=\"#检查是否配置成功\" class=\"headerlink\" title=\"检查是否配置成功\"></a>检查是否配置成功</h1><p><img src=\"http://www.wailian.work/images/2018/01/26/4.png\" alt=\"\"></p>\n<p>如果Slave_IO_Running和Slave_SQL_Running都为Yes，代表配置成功</p>\n<h1 id=\"测试主从同步\"><a href=\"#测试主从同步\" class=\"headerlink\" title=\"测试主从同步\"></a>测试主从同步</h1><p>主库创建一个库，一个表，观察从库是否同样创建</p>\n<h2 id=\"设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除\"><a href=\"#设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除\" class=\"headerlink\" title=\"设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除\"></a>设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除</h2><h1 id=\"附录：\"><a href=\"#附录：\" class=\"headerlink\" title=\"附录：\"></a>附录：</h1><p>到这里，全部库的主从配置就完成了，实际应用中可能会用到单个表的同步，或者部分表的同步，只需要在从库的/etc/my.cnf里加上</p>\n<p>只复制某个表replicate-do-table=dbname.tablename<br>只复制某些表（可用匹配符）replicate-wild-do-table=dbname.tablename%<br>只复制某个库replicate-do-db=dbname<br>只复制某些库replicte-wild-do-db=dbname%<br>不复制某个表replicate-ignore-table=dbname.tablename</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/01/26/5d274a04c82163baf3c74ae5c97d16e80a641ed24163c7-YnTeKa_fw658.jpg\" alt=\"pic\"></p>\n<p>mysql版本使用的是5.7.20<br>主库的IP为:47.104.71.88，从库的IP为:45.77.13.74</p>\n<h1 id=\"读写分离-主从库\"><a href=\"#读写分离-主从库\" class=\"headerlink\" title=\"读写分离(主从库)\"></a>读写分离(主从库)</h1><p>原理：让主库(master)处理事务性增改删，而从库(slave)处理查询操作</p>\n<h1 id=\"主库创建用户\"><a href=\"#主库创建用户\" class=\"headerlink\" title=\"主库创建用户\"></a>主库创建用户</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT REPLICATION SLAVE,RELOAD,SUPER ON *.* TO synchrouser@45.77.13.74 IDENTIFIED BY &apos;w123456W!&apos;;</span><br></pre></td></tr></table></figure>\n<p>在主库创建一个synchrouser用户密码为w123456W!，并允许从库以synchrouser用户来登录</p>\n<h1 id=\"配置主库\"><a href=\"#配置主库\" class=\"headerlink\" title=\"配置主库\"></a>配置主库</h1><p>在[mysqld]下增加配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server-id=88</span><br><span class=\"line\">log_bin=mysql-bin</span><br><span class=\"line\">binlog_format=mixed</span><br></pre></td></tr></table></figure>\n<p>server-id在数据库配置中必须唯一，一般为IP最后一个节点（例如：47.104.71.88，则设置为88）设置完成后，重启mysql</p>\n<h1 id=\"配置从库\"><a href=\"#配置从库\" class=\"headerlink\" title=\"配置从库\"></a>配置从库</h1><p>在[mysqld]增加配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server-id=74</span><br></pre></td></tr></table></figure>\n<p>设置完成后，重启mysql</p>\n<p>在主库执行:<code>show master status;</code></p>\n<p><img src=\"http://www.wailian.work/images/2018/01/26/WX20180126-091715.png\" alt=\"\"></p>\n<p>根据以上主库的信息设置从库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">change master to master_host=&apos;47.104.71.88&apos;,master_user=&apos;synchrouser&apos;,master_password=&apos;w123456W!&apos;,master_log_file=&apos;mysql-bin.000005&apos;,master_log_pos=840;</span><br></pre></td></tr></table></figure>\n<p>master_log_file字段对应了主库的File，master_log_pos字段对应了主库的Position</p>\n<h1 id=\"启动主从同步\"><a href=\"#启动主从同步\" class=\"headerlink\" title=\"启动主从同步\"></a>启动主从同步</h1><p>从库执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start slave;</span><br></pre></td></tr></table></figure>\n<h1 id=\"检查是否配置成功\"><a href=\"#检查是否配置成功\" class=\"headerlink\" title=\"检查是否配置成功\"></a>检查是否配置成功</h1><p><img src=\"http://www.wailian.work/images/2018/01/26/4.png\" alt=\"\"></p>\n<p>如果Slave_IO_Running和Slave_SQL_Running都为Yes，代表配置成功</p>\n<h1 id=\"测试主从同步\"><a href=\"#测试主从同步\" class=\"headerlink\" title=\"测试主从同步\"></a>测试主从同步</h1><p>主库创建一个库，一个表，观察从库是否同样创建</p>\n<h2 id=\"设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除\"><a href=\"#设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除\" class=\"headerlink\" title=\"设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除\"></a>设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除</h2><h1 id=\"附录：\"><a href=\"#附录：\" class=\"headerlink\" title=\"附录：\"></a>附录：</h1><p>到这里，全部库的主从配置就完成了，实际应用中可能会用到单个表的同步，或者部分表的同步，只需要在从库的/etc/my.cnf里加上</p>\n<p>只复制某个表replicate-do-table=dbname.tablename<br>只复制某些表（可用匹配符）replicate-wild-do-table=dbname.tablename%<br>只复制某个库replicate-do-db=dbname<br>只复制某些库replicte-wild-do-db=dbname%<br>不复制某个表replicate-ignore-table=dbname.tablename</p>\n"},{"title":"maven构建Spring Boot多模块项目以及打包方法","date":"2018-03-26T07:06:22.000Z","_content":"![](http://www.wailian.work/images/2018/03/28/f5462f69549047be1b086629e548eefc8d74eca329bea-IiKAbw_fw658.jpg)\n\n> 比起传统复杂的单体工程，使用Maven的多模块配置，可以帮助项目划分模块，鼓励重用，防止POM变得过于庞大，方便某个模块的构建，而不用每次都构建整个项目，并且使得针对某个模块的特殊控制更为方便\n\n# 构建项目\n\n## 创建空的maven主项目\n\n![create](http://www.wailian.work/images/2018/03/26/1.png)\n\n![mvn](http://www.wailian.work/images/2018/03/26/2.png)\n\n## 删除src目录\n\n![src](http://www.wailian.work/images/2018/03/26/3.png)\n\n## 修改pom文件\n\n添加`<packaging>pom</packaging>`\n\n![](http://www.wailian.work/images/2018/03/26/4.png)\n\n# 创建Spring Boot项目模块 \n\n在主项目上点击右键，选择New-Module\n\n![](http://www.wailian.work/images/2018/03/26/5.png)\n\n选择Spring Initializr\n\n![](http://www.wailian.work/images/2018/03/26/6.png)\n\n填写基本信息之后完成模块项目创建\n\n![](http://www.wailian.work/images/2018/03/26/7.png)\n\n采用相同方式再创建一个模块\n\n![](http://www.wailian.work/images/2018/03/26/8.png)\n\n# 修改主项目pom文件\n\n将两个子模块pom中的spring boot父依赖剪切到主项目中的pom文件中\n\n![](http://www.wailian.work/images/2018/03/26/9.png)\n\n在两个子模块pom中添加对父项目的依赖\n\n![](http://www.wailian.work/images/2018/03/26/10.png)\n\n在主项目pom中添加所有的子模块\n\n![](http://www.wailian.work/images/2018/03/26/11.png)\n\n# 测试依赖\n\nutils中添加方法，并在api模块中引入依赖，即可使用\n\n# 打包\n\n注意：多模块项目仅仅需要在启动类所在的模块添加打包插件即可！！不要在父类添加打包插件\n\n删除启动类以外模块中pom文件的build插件,然后在主目录下执行`mvn clean package`即可\n\n[代码地址](https://github.com/wangweiye01/maven)\n","source":"_posts/maven.md","raw":"---\ntitle: maven构建Spring Boot多模块项目以及打包方法\ndate: 2018-03-26 15:06:22\ntags:\n---\n![](http://www.wailian.work/images/2018/03/28/f5462f69549047be1b086629e548eefc8d74eca329bea-IiKAbw_fw658.jpg)\n\n> 比起传统复杂的单体工程，使用Maven的多模块配置，可以帮助项目划分模块，鼓励重用，防止POM变得过于庞大，方便某个模块的构建，而不用每次都构建整个项目，并且使得针对某个模块的特殊控制更为方便\n\n# 构建项目\n\n## 创建空的maven主项目\n\n![create](http://www.wailian.work/images/2018/03/26/1.png)\n\n![mvn](http://www.wailian.work/images/2018/03/26/2.png)\n\n## 删除src目录\n\n![src](http://www.wailian.work/images/2018/03/26/3.png)\n\n## 修改pom文件\n\n添加`<packaging>pom</packaging>`\n\n![](http://www.wailian.work/images/2018/03/26/4.png)\n\n# 创建Spring Boot项目模块 \n\n在主项目上点击右键，选择New-Module\n\n![](http://www.wailian.work/images/2018/03/26/5.png)\n\n选择Spring Initializr\n\n![](http://www.wailian.work/images/2018/03/26/6.png)\n\n填写基本信息之后完成模块项目创建\n\n![](http://www.wailian.work/images/2018/03/26/7.png)\n\n采用相同方式再创建一个模块\n\n![](http://www.wailian.work/images/2018/03/26/8.png)\n\n# 修改主项目pom文件\n\n将两个子模块pom中的spring boot父依赖剪切到主项目中的pom文件中\n\n![](http://www.wailian.work/images/2018/03/26/9.png)\n\n在两个子模块pom中添加对父项目的依赖\n\n![](http://www.wailian.work/images/2018/03/26/10.png)\n\n在主项目pom中添加所有的子模块\n\n![](http://www.wailian.work/images/2018/03/26/11.png)\n\n# 测试依赖\n\nutils中添加方法，并在api模块中引入依赖，即可使用\n\n# 打包\n\n注意：多模块项目仅仅需要在启动类所在的模块添加打包插件即可！！不要在父类添加打包插件\n\n删除启动类以外模块中pom文件的build插件,然后在主目录下执行`mvn clean package`即可\n\n[代码地址](https://github.com/wangweiye01/maven)\n","slug":"maven","published":1,"updated":"2019-12-24T02:00:57.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jw3000j0j9khmskkeec","content":"<p><img src=\"http://www.wailian.work/images/2018/03/28/f5462f69549047be1b086629e548eefc8d74eca329bea-IiKAbw_fw658.jpg\" alt=\"\"></p>\n<blockquote>\n<p>比起传统复杂的单体工程，使用Maven的多模块配置，可以帮助项目划分模块，鼓励重用，防止POM变得过于庞大，方便某个模块的构建，而不用每次都构建整个项目，并且使得针对某个模块的特殊控制更为方便</p>\n</blockquote>\n<h1 id=\"构建项目\"><a href=\"#构建项目\" class=\"headerlink\" title=\"构建项目\"></a>构建项目</h1><h2 id=\"创建空的maven主项目\"><a href=\"#创建空的maven主项目\" class=\"headerlink\" title=\"创建空的maven主项目\"></a>创建空的maven主项目</h2><p><img src=\"http://www.wailian.work/images/2018/03/26/1.png\" alt=\"create\"></p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/2.png\" alt=\"mvn\"></p>\n<h2 id=\"删除src目录\"><a href=\"#删除src目录\" class=\"headerlink\" title=\"删除src目录\"></a>删除src目录</h2><p><img src=\"http://www.wailian.work/images/2018/03/26/3.png\" alt=\"src\"></p>\n<h2 id=\"修改pom文件\"><a href=\"#修改pom文件\" class=\"headerlink\" title=\"修改pom文件\"></a>修改pom文件</h2><p>添加<code>&lt;packaging&gt;pom&lt;/packaging&gt;</code></p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/4.png\" alt=\"\"></p>\n<h1 id=\"创建Spring-Boot项目模块\"><a href=\"#创建Spring-Boot项目模块\" class=\"headerlink\" title=\"创建Spring Boot项目模块\"></a>创建Spring Boot项目模块</h1><p>在主项目上点击右键，选择New-Module</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/5.png\" alt=\"\"></p>\n<p>选择Spring Initializr</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/6.png\" alt=\"\"></p>\n<p>填写基本信息之后完成模块项目创建</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/7.png\" alt=\"\"></p>\n<p>采用相同方式再创建一个模块</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/8.png\" alt=\"\"></p>\n<h1 id=\"修改主项目pom文件\"><a href=\"#修改主项目pom文件\" class=\"headerlink\" title=\"修改主项目pom文件\"></a>修改主项目pom文件</h1><p>将两个子模块pom中的spring boot父依赖剪切到主项目中的pom文件中</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/9.png\" alt=\"\"></p>\n<p>在两个子模块pom中添加对父项目的依赖</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/10.png\" alt=\"\"></p>\n<p>在主项目pom中添加所有的子模块</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/11.png\" alt=\"\"></p>\n<h1 id=\"测试依赖\"><a href=\"#测试依赖\" class=\"headerlink\" title=\"测试依赖\"></a>测试依赖</h1><p>utils中添加方法，并在api模块中引入依赖，即可使用</p>\n<h1 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h1><p>注意：多模块项目仅仅需要在启动类所在的模块添加打包插件即可！！不要在父类添加打包插件</p>\n<p>删除启动类以外模块中pom文件的build插件,然后在主目录下执行<code>mvn clean package</code>即可</p>\n<p><a href=\"https://github.com/wangweiye01/maven\" target=\"_blank\" rel=\"noopener\">代码地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/03/28/f5462f69549047be1b086629e548eefc8d74eca329bea-IiKAbw_fw658.jpg\" alt=\"\"></p>\n<blockquote>\n<p>比起传统复杂的单体工程，使用Maven的多模块配置，可以帮助项目划分模块，鼓励重用，防止POM变得过于庞大，方便某个模块的构建，而不用每次都构建整个项目，并且使得针对某个模块的特殊控制更为方便</p>\n</blockquote>\n<h1 id=\"构建项目\"><a href=\"#构建项目\" class=\"headerlink\" title=\"构建项目\"></a>构建项目</h1><h2 id=\"创建空的maven主项目\"><a href=\"#创建空的maven主项目\" class=\"headerlink\" title=\"创建空的maven主项目\"></a>创建空的maven主项目</h2><p><img src=\"http://www.wailian.work/images/2018/03/26/1.png\" alt=\"create\"></p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/2.png\" alt=\"mvn\"></p>\n<h2 id=\"删除src目录\"><a href=\"#删除src目录\" class=\"headerlink\" title=\"删除src目录\"></a>删除src目录</h2><p><img src=\"http://www.wailian.work/images/2018/03/26/3.png\" alt=\"src\"></p>\n<h2 id=\"修改pom文件\"><a href=\"#修改pom文件\" class=\"headerlink\" title=\"修改pom文件\"></a>修改pom文件</h2><p>添加<code>&lt;packaging&gt;pom&lt;/packaging&gt;</code></p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/4.png\" alt=\"\"></p>\n<h1 id=\"创建Spring-Boot项目模块\"><a href=\"#创建Spring-Boot项目模块\" class=\"headerlink\" title=\"创建Spring Boot项目模块\"></a>创建Spring Boot项目模块</h1><p>在主项目上点击右键，选择New-Module</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/5.png\" alt=\"\"></p>\n<p>选择Spring Initializr</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/6.png\" alt=\"\"></p>\n<p>填写基本信息之后完成模块项目创建</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/7.png\" alt=\"\"></p>\n<p>采用相同方式再创建一个模块</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/8.png\" alt=\"\"></p>\n<h1 id=\"修改主项目pom文件\"><a href=\"#修改主项目pom文件\" class=\"headerlink\" title=\"修改主项目pom文件\"></a>修改主项目pom文件</h1><p>将两个子模块pom中的spring boot父依赖剪切到主项目中的pom文件中</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/9.png\" alt=\"\"></p>\n<p>在两个子模块pom中添加对父项目的依赖</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/10.png\" alt=\"\"></p>\n<p>在主项目pom中添加所有的子模块</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/26/11.png\" alt=\"\"></p>\n<h1 id=\"测试依赖\"><a href=\"#测试依赖\" class=\"headerlink\" title=\"测试依赖\"></a>测试依赖</h1><p>utils中添加方法，并在api模块中引入依赖，即可使用</p>\n<h1 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h1><p>注意：多模块项目仅仅需要在启动类所在的模块添加打包插件即可！！不要在父类添加打包插件</p>\n<p>删除启动类以外模块中pom文件的build插件,然后在主目录下执行<code>mvn clean package</code>即可</p>\n<p><a href=\"https://github.com/wangweiye01/maven\" target=\"_blank\" rel=\"noopener\">代码地址</a></p>\n"},{"title":"mybatis Integer类型，0的问题","date":"2017-12-14T02:17:34.000Z","_content":"\n问题：在mybatis中，0被认为是空字符串\n解决：普通判断1. != null 2. != ''。当类型为Integer类型时只进行方式1的判断\n","source":"_posts/mybatis.md","raw":"---\ntitle: mybatis Integer类型，0的问题\ndate: 2017-12-14 10:17:34\ntags:\n---\n\n问题：在mybatis中，0被认为是空字符串\n解决：普通判断1. != null 2. != ''。当类型为Integer类型时只进行方式1的判断\n","slug":"mybatis","published":1,"updated":"2019-12-24T02:00:57.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jw4000k0j9ka1n5r715","content":"<p>问题：在mybatis中，0被认为是空字符串<br>解决：普通判断1. != null 2. != ‘’。当类型为Integer类型时只进行方式1的判断</p>\n","site":{"data":{}},"excerpt":"","more":"<p>问题：在mybatis中，0被认为是空字符串<br>解决：普通判断1. != null 2. != ‘’。当类型为Integer类型时只进行方式1的判断</p>\n"},{"title":"逻辑备份mysql数据库","date":"2017-12-13T07:51:47.000Z","_content":"# 数据安全高于一切\n\n有时我们为了节省开支，并不会购买云数据库而是选择自建数据库，这时数据安全就极为重要。数据备份是保证安全最有效的方式\n\n# 编写数据备份脚本\n\n```\n# /bin/bash\nDB_NAME=\"exchange\"\nDB_USER=\"root\"\nDB_PASSWORD=\"abc123\"\nBIN_DIR=\"/usr/bin\"\nBACK_DIR=\"/root/data\"\nDATE=\"mysql-`date +'%Y%m%d-%H:%M:%S'`\"\nLogFile=\"$BACK_DIR\"/dbbakup.log\nBackNewFile=$DATE.sql\n\n$BIN_DIR/mysqldump -u$DB_USER -p$DB_PASSWORD $DB_NAME > $BACK_DIR/$DATE.sql\n\necho -----------------\"$(date +\"%y-%m-%d %H:%M:%S\")\"------------------ >> $LogFile\n\necho  createFile:\"$BackNewFile\" >> $LogFile\n\nfind \"/root/data/\" -ctime +0 -type f -name \"*.sql\" -print > deleted.txt\n\necho -e \"delete files:\\n\" >> $LogFile\n\ncat deleted.txt | while read LINE\ndo\n    rm -rf $LINE\n    echo $LINE>> $LogFile\ndone\n\necho \"---------------------------------------------------------------\" >> $LogFile\n```\n\n# 利用cron定时执行\n\n利用cron服务定时执行数据备份脚本。该脚本会自动删除过期的sql文件\n例如 每天12:50定时执行mysqlback.sh脚本：\n```\n50 12 * * * /root/mysqlback.sh\n```\n","source":"_posts/mysql-back.md","raw":"---\ntitle: 逻辑备份mysql数据库\ndate: 2017-12-13 15:51:47\ntags:\n---\n# 数据安全高于一切\n\n有时我们为了节省开支，并不会购买云数据库而是选择自建数据库，这时数据安全就极为重要。数据备份是保证安全最有效的方式\n\n# 编写数据备份脚本\n\n```\n# /bin/bash\nDB_NAME=\"exchange\"\nDB_USER=\"root\"\nDB_PASSWORD=\"abc123\"\nBIN_DIR=\"/usr/bin\"\nBACK_DIR=\"/root/data\"\nDATE=\"mysql-`date +'%Y%m%d-%H:%M:%S'`\"\nLogFile=\"$BACK_DIR\"/dbbakup.log\nBackNewFile=$DATE.sql\n\n$BIN_DIR/mysqldump -u$DB_USER -p$DB_PASSWORD $DB_NAME > $BACK_DIR/$DATE.sql\n\necho -----------------\"$(date +\"%y-%m-%d %H:%M:%S\")\"------------------ >> $LogFile\n\necho  createFile:\"$BackNewFile\" >> $LogFile\n\nfind \"/root/data/\" -ctime +0 -type f -name \"*.sql\" -print > deleted.txt\n\necho -e \"delete files:\\n\" >> $LogFile\n\ncat deleted.txt | while read LINE\ndo\n    rm -rf $LINE\n    echo $LINE>> $LogFile\ndone\n\necho \"---------------------------------------------------------------\" >> $LogFile\n```\n\n# 利用cron定时执行\n\n利用cron服务定时执行数据备份脚本。该脚本会自动删除过期的sql文件\n例如 每天12:50定时执行mysqlback.sh脚本：\n```\n50 12 * * * /root/mysqlback.sh\n```\n","slug":"mysql-back","published":1,"updated":"2019-12-24T02:00:57.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jw6000l0j9kkfbf7qc5","content":"<h1 id=\"数据安全高于一切\"><a href=\"#数据安全高于一切\" class=\"headerlink\" title=\"数据安全高于一切\"></a>数据安全高于一切</h1><p>有时我们为了节省开支，并不会购买云数据库而是选择自建数据库，这时数据安全就极为重要。数据备份是保证安全最有效的方式</p>\n<h1 id=\"编写数据备份脚本\"><a href=\"#编写数据备份脚本\" class=\"headerlink\" title=\"编写数据备份脚本\"></a>编写数据备份脚本</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># /bin/bash</span><br><span class=\"line\">DB_NAME=&quot;exchange&quot;</span><br><span class=\"line\">DB_USER=&quot;root&quot;</span><br><span class=\"line\">DB_PASSWORD=&quot;abc123&quot;</span><br><span class=\"line\">BIN_DIR=&quot;/usr/bin&quot;</span><br><span class=\"line\">BACK_DIR=&quot;/root/data&quot;</span><br><span class=\"line\">DATE=&quot;mysql-`date +&apos;%Y%m%d-%H:%M:%S&apos;`&quot;</span><br><span class=\"line\">LogFile=&quot;$BACK_DIR&quot;/dbbakup.log</span><br><span class=\"line\">BackNewFile=$DATE.sql</span><br><span class=\"line\"></span><br><span class=\"line\">$BIN_DIR/mysqldump -u$DB_USER -p$DB_PASSWORD $DB_NAME &gt; $BACK_DIR/$DATE.sql</span><br><span class=\"line\"></span><br><span class=\"line\">echo -----------------&quot;$(date +&quot;%y-%m-%d %H:%M:%S&quot;)&quot;------------------ &gt;&gt; $LogFile</span><br><span class=\"line\"></span><br><span class=\"line\">echo  createFile:&quot;$BackNewFile&quot; &gt;&gt; $LogFile</span><br><span class=\"line\"></span><br><span class=\"line\">find &quot;/root/data/&quot; -ctime +0 -type f -name &quot;*.sql&quot; -print &gt; deleted.txt</span><br><span class=\"line\"></span><br><span class=\"line\">echo -e &quot;delete files:\\n&quot; &gt;&gt; $LogFile</span><br><span class=\"line\"></span><br><span class=\"line\">cat deleted.txt | while read LINE</span><br><span class=\"line\">do</span><br><span class=\"line\">    rm -rf $LINE</span><br><span class=\"line\">    echo $LINE&gt;&gt; $LogFile</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;---------------------------------------------------------------&quot; &gt;&gt; $LogFile</span><br></pre></td></tr></table></figure>\n<h1 id=\"利用cron定时执行\"><a href=\"#利用cron定时执行\" class=\"headerlink\" title=\"利用cron定时执行\"></a>利用cron定时执行</h1><p>利用cron服务定时执行数据备份脚本。该脚本会自动删除过期的sql文件<br>例如 每天12:50定时执行mysqlback.sh脚本：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">50 12 * * * /root/mysqlback.sh</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数据安全高于一切\"><a href=\"#数据安全高于一切\" class=\"headerlink\" title=\"数据安全高于一切\"></a>数据安全高于一切</h1><p>有时我们为了节省开支，并不会购买云数据库而是选择自建数据库，这时数据安全就极为重要。数据备份是保证安全最有效的方式</p>\n<h1 id=\"编写数据备份脚本\"><a href=\"#编写数据备份脚本\" class=\"headerlink\" title=\"编写数据备份脚本\"></a>编写数据备份脚本</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># /bin/bash</span><br><span class=\"line\">DB_NAME=&quot;exchange&quot;</span><br><span class=\"line\">DB_USER=&quot;root&quot;</span><br><span class=\"line\">DB_PASSWORD=&quot;abc123&quot;</span><br><span class=\"line\">BIN_DIR=&quot;/usr/bin&quot;</span><br><span class=\"line\">BACK_DIR=&quot;/root/data&quot;</span><br><span class=\"line\">DATE=&quot;mysql-`date +&apos;%Y%m%d-%H:%M:%S&apos;`&quot;</span><br><span class=\"line\">LogFile=&quot;$BACK_DIR&quot;/dbbakup.log</span><br><span class=\"line\">BackNewFile=$DATE.sql</span><br><span class=\"line\"></span><br><span class=\"line\">$BIN_DIR/mysqldump -u$DB_USER -p$DB_PASSWORD $DB_NAME &gt; $BACK_DIR/$DATE.sql</span><br><span class=\"line\"></span><br><span class=\"line\">echo -----------------&quot;$(date +&quot;%y-%m-%d %H:%M:%S&quot;)&quot;------------------ &gt;&gt; $LogFile</span><br><span class=\"line\"></span><br><span class=\"line\">echo  createFile:&quot;$BackNewFile&quot; &gt;&gt; $LogFile</span><br><span class=\"line\"></span><br><span class=\"line\">find &quot;/root/data/&quot; -ctime +0 -type f -name &quot;*.sql&quot; -print &gt; deleted.txt</span><br><span class=\"line\"></span><br><span class=\"line\">echo -e &quot;delete files:\\n&quot; &gt;&gt; $LogFile</span><br><span class=\"line\"></span><br><span class=\"line\">cat deleted.txt | while read LINE</span><br><span class=\"line\">do</span><br><span class=\"line\">    rm -rf $LINE</span><br><span class=\"line\">    echo $LINE&gt;&gt; $LogFile</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;---------------------------------------------------------------&quot; &gt;&gt; $LogFile</span><br></pre></td></tr></table></figure>\n<h1 id=\"利用cron定时执行\"><a href=\"#利用cron定时执行\" class=\"headerlink\" title=\"利用cron定时执行\"></a>利用cron定时执行</h1><p>利用cron服务定时执行数据备份脚本。该脚本会自动删除过期的sql文件<br>例如 每天12:50定时执行mysqlback.sh脚本：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">50 12 * * * /root/mysqlback.sh</span><br></pre></td></tr></table></figure></p>\n"},{"title":"linux导入导出mysql数据","date":"2017-12-08T05:55:18.000Z","_content":"## linux导入sql\n\n```\nmysql -h [host] -u [userName] -p [databaseName] < [data].sql\n```\n\n## linux导出库\n\n```\nmysqldump -h [host] -u [username] -p --databases [databasename] > [fileName].sql\n```\n\n## linux导出单表\n\n```\nmysqldump -h [host] -u [username] -p [dabaseName] [tableName] > [fileName].sql\n```\n","source":"_posts/mysql-linux.md","raw":"---\ntitle: linux导入导出mysql数据\ndate: 2017-12-08 13:55:18\ntags:\n---\n## linux导入sql\n\n```\nmysql -h [host] -u [userName] -p [databaseName] < [data].sql\n```\n\n## linux导出库\n\n```\nmysqldump -h [host] -u [username] -p --databases [databasename] > [fileName].sql\n```\n\n## linux导出单表\n\n```\nmysqldump -h [host] -u [username] -p [dabaseName] [tableName] > [fileName].sql\n```\n","slug":"mysql-linux","published":1,"updated":"2019-12-24T02:00:57.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jw7000m0j9kor6bddyl","content":"<h2 id=\"linux导入sql\"><a href=\"#linux导入sql\" class=\"headerlink\" title=\"linux导入sql\"></a>linux导入sql</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -h [host] -u [userName] -p [databaseName] &lt; [data].sql</span><br></pre></td></tr></table></figure>\n<h2 id=\"linux导出库\"><a href=\"#linux导出库\" class=\"headerlink\" title=\"linux导出库\"></a>linux导出库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldump -h [host] -u [username] -p --databases [databasename] &gt; [fileName].sql</span><br></pre></td></tr></table></figure>\n<h2 id=\"linux导出单表\"><a href=\"#linux导出单表\" class=\"headerlink\" title=\"linux导出单表\"></a>linux导出单表</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldump -h [host] -u [username] -p [dabaseName] [tableName] &gt; [fileName].sql</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"linux导入sql\"><a href=\"#linux导入sql\" class=\"headerlink\" title=\"linux导入sql\"></a>linux导入sql</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -h [host] -u [userName] -p [databaseName] &lt; [data].sql</span><br></pre></td></tr></table></figure>\n<h2 id=\"linux导出库\"><a href=\"#linux导出库\" class=\"headerlink\" title=\"linux导出库\"></a>linux导出库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldump -h [host] -u [username] -p --databases [databasename] &gt; [fileName].sql</span><br></pre></td></tr></table></figure>\n<h2 id=\"linux导出单表\"><a href=\"#linux导出单表\" class=\"headerlink\" title=\"linux导出单表\"></a>linux导出单表</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldump -h [host] -u [username] -p [dabaseName] [tableName] &gt; [fileName].sql</span><br></pre></td></tr></table></figure>\n"},{"title":"mysql设置外部访问","date":"2017-12-21T08:45:54.000Z","_content":"![pic](http://s1.wailian.download/2018/01/18/3ce570ed091e852cd203a1e621362585d16831a072ccc-m7zSKp_fw658.jpg)\nmysql5.7设置允许外网登录数据库\n\n# 创建host\n\n## 进入mysql数据库，修改user表\n\n```\nuse mysql\n```\n\n```\nupdate user set host='%' where user='root'\n```\n\n## 刷新权限\n```\nflush privileges\n```\n\n# 授权用户\n\n## 任意主机以用户root和密码mypwd连接到mysql数据库\n\n```\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%'  IDENTIFIED BY 'mypwd'  WITH GRANT OPTION\n```\n\n## IP为192.168.1.11的主机以用户myuser和密码mypwd连接到mysql数据库\n\n```\nGRANT ALL PRIVILEGES ON *.* TO 'myuser'@'192.168.1.11' IDENTIFIED BY 'mypwd' WITH GRANT OPTION\n```\n\n## 刷新权限\n```\nflush privileges\n```\n\n# 可能遇到的问题\n\n- 设置后仍不能访问：防火墙放开mysql的tcp端口\n- 如果是阿里ECS用户：配置安全组规则放开mysql端口\n","source":"_posts/mysql-out.md","raw":"---\ntitle: mysql设置外部访问\ndate: 2017-12-21 16:45:54\ntags:\n---\n![pic](http://s1.wailian.download/2018/01/18/3ce570ed091e852cd203a1e621362585d16831a072ccc-m7zSKp_fw658.jpg)\nmysql5.7设置允许外网登录数据库\n\n# 创建host\n\n## 进入mysql数据库，修改user表\n\n```\nuse mysql\n```\n\n```\nupdate user set host='%' where user='root'\n```\n\n## 刷新权限\n```\nflush privileges\n```\n\n# 授权用户\n\n## 任意主机以用户root和密码mypwd连接到mysql数据库\n\n```\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%'  IDENTIFIED BY 'mypwd'  WITH GRANT OPTION\n```\n\n## IP为192.168.1.11的主机以用户myuser和密码mypwd连接到mysql数据库\n\n```\nGRANT ALL PRIVILEGES ON *.* TO 'myuser'@'192.168.1.11' IDENTIFIED BY 'mypwd' WITH GRANT OPTION\n```\n\n## 刷新权限\n```\nflush privileges\n```\n\n# 可能遇到的问题\n\n- 设置后仍不能访问：防火墙放开mysql的tcp端口\n- 如果是阿里ECS用户：配置安全组规则放开mysql端口\n","slug":"mysql-out","published":1,"updated":"2019-12-24T02:00:57.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jw8000n0j9kcdz2eua3","content":"<p><img src=\"http://s1.wailian.download/2018/01/18/3ce570ed091e852cd203a1e621362585d16831a072ccc-m7zSKp_fw658.jpg\" alt=\"pic\"><br>mysql5.7设置允许外网登录数据库</p>\n<h1 id=\"创建host\"><a href=\"#创建host\" class=\"headerlink\" title=\"创建host\"></a>创建host</h1><h2 id=\"进入mysql数据库，修改user表\"><a href=\"#进入mysql数据库，修改user表\" class=\"headerlink\" title=\"进入mysql数据库，修改user表\"></a>进入mysql数据库，修改user表</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use mysql</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update user set host=&apos;%&apos; where user=&apos;root&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"刷新权限\"><a href=\"#刷新权限\" class=\"headerlink\" title=\"刷新权限\"></a>刷新权限</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flush privileges</span><br></pre></td></tr></table></figure>\n<h1 id=\"授权用户\"><a href=\"#授权用户\" class=\"headerlink\" title=\"授权用户\"></a>授权用户</h1><h2 id=\"任意主机以用户root和密码mypwd连接到mysql数据库\"><a href=\"#任意主机以用户root和密码mypwd连接到mysql数据库\" class=\"headerlink\" title=\"任意主机以用户root和密码mypwd连接到mysql数据库\"></a>任意主机以用户root和密码mypwd连接到mysql数据库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos;  IDENTIFIED BY &apos;mypwd&apos;  WITH GRANT OPTION</span><br></pre></td></tr></table></figure>\n<h2 id=\"IP为192-168-1-11的主机以用户myuser和密码mypwd连接到mysql数据库\"><a href=\"#IP为192-168-1-11的主机以用户myuser和密码mypwd连接到mysql数据库\" class=\"headerlink\" title=\"IP为192.168.1.11的主机以用户myuser和密码mypwd连接到mysql数据库\"></a>IP为192.168.1.11的主机以用户myuser和密码mypwd连接到mysql数据库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT ALL PRIVILEGES ON *.* TO &apos;myuser&apos;@&apos;192.168.1.11&apos; IDENTIFIED BY &apos;mypwd&apos; WITH GRANT OPTION</span><br></pre></td></tr></table></figure>\n<h2 id=\"刷新权限-1\"><a href=\"#刷新权限-1\" class=\"headerlink\" title=\"刷新权限\"></a>刷新权限</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flush privileges</span><br></pre></td></tr></table></figure>\n<h1 id=\"可能遇到的问题\"><a href=\"#可能遇到的问题\" class=\"headerlink\" title=\"可能遇到的问题\"></a>可能遇到的问题</h1><ul>\n<li>设置后仍不能访问：防火墙放开mysql的tcp端口</li>\n<li>如果是阿里ECS用户：配置安全组规则放开mysql端口</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://s1.wailian.download/2018/01/18/3ce570ed091e852cd203a1e621362585d16831a072ccc-m7zSKp_fw658.jpg\" alt=\"pic\"><br>mysql5.7设置允许外网登录数据库</p>\n<h1 id=\"创建host\"><a href=\"#创建host\" class=\"headerlink\" title=\"创建host\"></a>创建host</h1><h2 id=\"进入mysql数据库，修改user表\"><a href=\"#进入mysql数据库，修改user表\" class=\"headerlink\" title=\"进入mysql数据库，修改user表\"></a>进入mysql数据库，修改user表</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use mysql</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update user set host=&apos;%&apos; where user=&apos;root&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"刷新权限\"><a href=\"#刷新权限\" class=\"headerlink\" title=\"刷新权限\"></a>刷新权限</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flush privileges</span><br></pre></td></tr></table></figure>\n<h1 id=\"授权用户\"><a href=\"#授权用户\" class=\"headerlink\" title=\"授权用户\"></a>授权用户</h1><h2 id=\"任意主机以用户root和密码mypwd连接到mysql数据库\"><a href=\"#任意主机以用户root和密码mypwd连接到mysql数据库\" class=\"headerlink\" title=\"任意主机以用户root和密码mypwd连接到mysql数据库\"></a>任意主机以用户root和密码mypwd连接到mysql数据库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos;  IDENTIFIED BY &apos;mypwd&apos;  WITH GRANT OPTION</span><br></pre></td></tr></table></figure>\n<h2 id=\"IP为192-168-1-11的主机以用户myuser和密码mypwd连接到mysql数据库\"><a href=\"#IP为192-168-1-11的主机以用户myuser和密码mypwd连接到mysql数据库\" class=\"headerlink\" title=\"IP为192.168.1.11的主机以用户myuser和密码mypwd连接到mysql数据库\"></a>IP为192.168.1.11的主机以用户myuser和密码mypwd连接到mysql数据库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT ALL PRIVILEGES ON *.* TO &apos;myuser&apos;@&apos;192.168.1.11&apos; IDENTIFIED BY &apos;mypwd&apos; WITH GRANT OPTION</span><br></pre></td></tr></table></figure>\n<h2 id=\"刷新权限-1\"><a href=\"#刷新权限-1\" class=\"headerlink\" title=\"刷新权限\"></a>刷新权限</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flush privileges</span><br></pre></td></tr></table></figure>\n<h1 id=\"可能遇到的问题\"><a href=\"#可能遇到的问题\" class=\"headerlink\" title=\"可能遇到的问题\"></a>可能遇到的问题</h1><ul>\n<li>设置后仍不能访问：防火墙放开mysql的tcp端口</li>\n<li>如果是阿里ECS用户：配置安全组规则放开mysql端口</li>\n</ul>\n"},{"title":"nginx配置CORS实现跨域","date":"2018-04-10T06:58:37.000Z","top":99,"_content":"\n![toutu](http://www.wailian.work/images/2018/04/11/502af7eae3feeb1e4b5c376c2f24e9b206182f1b187f73-7ntUXd_fw658.jpg)\n\n> 单服务器应用不用nginx代理时在Java中都是在Filter中实现的跨域设置，如何在请求到达应用服务器之前实现跨域的设置呢？使用nginx配置实现\n\n# 什么是CORS\n\nCORS是一个W3C标准，全称是跨域资源共享(Cross-origin resource sharing)。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。\n\n# 实现方法\n\n```\nserver {\n    listen       80;\n    server_name  agent.bater.top;\n\n    root /var/www/html/api_agent/public;\n\n    location / {\n\n        if ($request_method = 'OPTIONS') {\n            add_header Access-Control-Allow-Origin $http_origin;\n            add_header Access-Control-Allow-Credentials true;\n            add_header Access-Control-Allow-Methods 'GET,POST,PUT,DELETE,OPTIONS';\n            add_header Access-Control-Allow-Headers 'Authorization,X-Requested-With,Content-Type,Origin,Accept,Cookie';\n            add_header Access-Control-Max-Age 3600;\n            add_header Content-Length 0;\n            return 202;\n        }\n\n        add_header Access-Control-Allow-Origin $http_origin;\n        add_header Access-Control-Allow-Credentials true;\n        add_header Access-Control-Allow-Methods 'GET,POST,PUT,DELETE,OPTIONS';\n        add_header Access-Control-Allow-Headers 'Authorization,X-Requested-With,Content-Type,Origin,Accept,Cookie';\n        \n        proxy_pass http://localhost:8080/;\n    }\n}\n```\n\n`Access-Control-Allow-Origin`: 它是W3C标准里用来检查该跨域请求是否可以被通过(Access Control Check)。如果需要跨域，解决方法就是在资源的头中加入Access-Control-Allow-Origin 指定你授权的域。\n\n`Access-Control-Allow-Credentials`: 它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 \n\n`Access-Control-Allow-Methods`: 它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法\n\n`Access-Control-Allow-Headers`: 它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段\n\n`Access-Control-Max-Age`: 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是1小时（3600秒），即允许缓存该条回应3600秒，在此期间，不用发出另一条预检请求\n\n`Content-Length`: 用于描述HTTP消息实体的传输长度\n","source":"_posts/nginx-cores.md","raw":"---\ntitle: nginx配置CORS实现跨域\ndate: 2018-04-10 14:58:37\ntags:\ntop: 99\n---\n\n![toutu](http://www.wailian.work/images/2018/04/11/502af7eae3feeb1e4b5c376c2f24e9b206182f1b187f73-7ntUXd_fw658.jpg)\n\n> 单服务器应用不用nginx代理时在Java中都是在Filter中实现的跨域设置，如何在请求到达应用服务器之前实现跨域的设置呢？使用nginx配置实现\n\n# 什么是CORS\n\nCORS是一个W3C标准，全称是跨域资源共享(Cross-origin resource sharing)。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。\n\n# 实现方法\n\n```\nserver {\n    listen       80;\n    server_name  agent.bater.top;\n\n    root /var/www/html/api_agent/public;\n\n    location / {\n\n        if ($request_method = 'OPTIONS') {\n            add_header Access-Control-Allow-Origin $http_origin;\n            add_header Access-Control-Allow-Credentials true;\n            add_header Access-Control-Allow-Methods 'GET,POST,PUT,DELETE,OPTIONS';\n            add_header Access-Control-Allow-Headers 'Authorization,X-Requested-With,Content-Type,Origin,Accept,Cookie';\n            add_header Access-Control-Max-Age 3600;\n            add_header Content-Length 0;\n            return 202;\n        }\n\n        add_header Access-Control-Allow-Origin $http_origin;\n        add_header Access-Control-Allow-Credentials true;\n        add_header Access-Control-Allow-Methods 'GET,POST,PUT,DELETE,OPTIONS';\n        add_header Access-Control-Allow-Headers 'Authorization,X-Requested-With,Content-Type,Origin,Accept,Cookie';\n        \n        proxy_pass http://localhost:8080/;\n    }\n}\n```\n\n`Access-Control-Allow-Origin`: 它是W3C标准里用来检查该跨域请求是否可以被通过(Access Control Check)。如果需要跨域，解决方法就是在资源的头中加入Access-Control-Allow-Origin 指定你授权的域。\n\n`Access-Control-Allow-Credentials`: 它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 \n\n`Access-Control-Allow-Methods`: 它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法\n\n`Access-Control-Allow-Headers`: 它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段\n\n`Access-Control-Max-Age`: 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是1小时（3600秒），即允许缓存该条回应3600秒，在此期间，不用发出另一条预检请求\n\n`Content-Length`: 用于描述HTTP消息实体的传输长度\n","slug":"nginx-cores","published":1,"updated":"2019-12-24T02:00:57.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jw9000o0j9k8ga9w48q","content":"<p><img src=\"http://www.wailian.work/images/2018/04/11/502af7eae3feeb1e4b5c376c2f24e9b206182f1b187f73-7ntUXd_fw658.jpg\" alt=\"toutu\"></p>\n<blockquote>\n<p>单服务器应用不用nginx代理时在Java中都是在Filter中实现的跨域设置，如何在请求到达应用服务器之前实现跨域的设置呢？使用nginx配置实现</p>\n</blockquote>\n<h1 id=\"什么是CORS\"><a href=\"#什么是CORS\" class=\"headerlink\" title=\"什么是CORS\"></a>什么是CORS</h1><p>CORS是一个W3C标准，全称是跨域资源共享(Cross-origin resource sharing)。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>\n<h1 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a>实现方法</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  agent.bater.top;</span><br><span class=\"line\"></span><br><span class=\"line\">    root /var/www/html/api_agent/public;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        if ($request_method = &apos;OPTIONS&apos;) &#123;</span><br><span class=\"line\">            add_header Access-Control-Allow-Origin $http_origin;</span><br><span class=\"line\">            add_header Access-Control-Allow-Credentials true;</span><br><span class=\"line\">            add_header Access-Control-Allow-Methods &apos;GET,POST,PUT,DELETE,OPTIONS&apos;;</span><br><span class=\"line\">            add_header Access-Control-Allow-Headers &apos;Authorization,X-Requested-With,Content-Type,Origin,Accept,Cookie&apos;;</span><br><span class=\"line\">            add_header Access-Control-Max-Age 3600;</span><br><span class=\"line\">            add_header Content-Length 0;</span><br><span class=\"line\">            return 202;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        add_header Access-Control-Allow-Origin $http_origin;</span><br><span class=\"line\">        add_header Access-Control-Allow-Credentials true;</span><br><span class=\"line\">        add_header Access-Control-Allow-Methods &apos;GET,POST,PUT,DELETE,OPTIONS&apos;;</span><br><span class=\"line\">        add_header Access-Control-Allow-Headers &apos;Authorization,X-Requested-With,Content-Type,Origin,Accept,Cookie&apos;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        proxy_pass http://localhost:8080/;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Access-Control-Allow-Origin</code>: 它是W3C标准里用来检查该跨域请求是否可以被通过(Access Control Check)。如果需要跨域，解决方法就是在资源的头中加入Access-Control-Allow-Origin 指定你授权的域。</p>\n<p><code>Access-Control-Allow-Credentials</code>: 它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 </p>\n<p><code>Access-Control-Allow-Methods</code>: 它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法</p>\n<p><code>Access-Control-Allow-Headers</code>: 它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段</p>\n<p><code>Access-Control-Max-Age</code>: 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是1小时（3600秒），即允许缓存该条回应3600秒，在此期间，不用发出另一条预检请求</p>\n<p><code>Content-Length</code>: 用于描述HTTP消息实体的传输长度</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/04/11/502af7eae3feeb1e4b5c376c2f24e9b206182f1b187f73-7ntUXd_fw658.jpg\" alt=\"toutu\"></p>\n<blockquote>\n<p>单服务器应用不用nginx代理时在Java中都是在Filter中实现的跨域设置，如何在请求到达应用服务器之前实现跨域的设置呢？使用nginx配置实现</p>\n</blockquote>\n<h1 id=\"什么是CORS\"><a href=\"#什么是CORS\" class=\"headerlink\" title=\"什么是CORS\"></a>什么是CORS</h1><p>CORS是一个W3C标准，全称是跨域资源共享(Cross-origin resource sharing)。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>\n<h1 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a>实现方法</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  agent.bater.top;</span><br><span class=\"line\"></span><br><span class=\"line\">    root /var/www/html/api_agent/public;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        if ($request_method = &apos;OPTIONS&apos;) &#123;</span><br><span class=\"line\">            add_header Access-Control-Allow-Origin $http_origin;</span><br><span class=\"line\">            add_header Access-Control-Allow-Credentials true;</span><br><span class=\"line\">            add_header Access-Control-Allow-Methods &apos;GET,POST,PUT,DELETE,OPTIONS&apos;;</span><br><span class=\"line\">            add_header Access-Control-Allow-Headers &apos;Authorization,X-Requested-With,Content-Type,Origin,Accept,Cookie&apos;;</span><br><span class=\"line\">            add_header Access-Control-Max-Age 3600;</span><br><span class=\"line\">            add_header Content-Length 0;</span><br><span class=\"line\">            return 202;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        add_header Access-Control-Allow-Origin $http_origin;</span><br><span class=\"line\">        add_header Access-Control-Allow-Credentials true;</span><br><span class=\"line\">        add_header Access-Control-Allow-Methods &apos;GET,POST,PUT,DELETE,OPTIONS&apos;;</span><br><span class=\"line\">        add_header Access-Control-Allow-Headers &apos;Authorization,X-Requested-With,Content-Type,Origin,Accept,Cookie&apos;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        proxy_pass http://localhost:8080/;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Access-Control-Allow-Origin</code>: 它是W3C标准里用来检查该跨域请求是否可以被通过(Access Control Check)。如果需要跨域，解决方法就是在资源的头中加入Access-Control-Allow-Origin 指定你授权的域。</p>\n<p><code>Access-Control-Allow-Credentials</code>: 它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 </p>\n<p><code>Access-Control-Allow-Methods</code>: 它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法</p>\n<p><code>Access-Control-Allow-Headers</code>: 它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段</p>\n<p><code>Access-Control-Max-Age</code>: 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是1小时（3600秒），即允许缓存该条回应3600秒，在此期间，不用发出另一条预检请求</p>\n<p><code>Content-Length</code>: 用于描述HTTP消息实体的传输长度</p>\n"},{"title":"nginx负载均衡策略","date":"2017-11-29T00:50:05.000Z","_content":"# 轮询（默认策略）\n\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除\n\n# 指定权重\n\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n```\nupstream servername { \n    server 192.168.0.1 weight=1; \n    server 192.168.0.2 weight=12; \n} \n```\n\n# IP绑定 ip_hash\n每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n```\nupstream backserver { \n    ip_hash; \n    server 192.168.0.14:88; \n    server 192.168.0.15:80; \n} \n```\n\n# fair（第三方）\n\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n```\nupstream backserver { \n    server server1; \n    server server2; \n    fair; \n} \n```\n这种策略具有很强的自适应性，但是实际的网络环境往往不是那么简单，因此须慎用。\n\n# url_hash（第三方）\n\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\n```\nupstream backserver { \n    server squid1:3128; \n    server squid2:3128; \n    hash $request_uri; \n    hash_method crc32; \n} \n```\n","source":"_posts/nginx-strategy.md","raw":"---\ntitle: nginx负载均衡策略\ndate: 2017-11-29 08:50:05\ntags:\n---\n# 轮询（默认策略）\n\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除\n\n# 指定权重\n\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n```\nupstream servername { \n    server 192.168.0.1 weight=1; \n    server 192.168.0.2 weight=12; \n} \n```\n\n# IP绑定 ip_hash\n每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n```\nupstream backserver { \n    ip_hash; \n    server 192.168.0.14:88; \n    server 192.168.0.15:80; \n} \n```\n\n# fair（第三方）\n\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n```\nupstream backserver { \n    server server1; \n    server server2; \n    fair; \n} \n```\n这种策略具有很强的自适应性，但是实际的网络环境往往不是那么简单，因此须慎用。\n\n# url_hash（第三方）\n\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\n```\nupstream backserver { \n    server squid1:3128; \n    server squid2:3128; \n    hash $request_uri; \n    hash_method crc32; \n} \n```\n","slug":"nginx-strategy","published":1,"updated":"2019-12-24T02:00:57.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jwa000p0j9kzdkmkdcj","content":"<h1 id=\"轮询（默认策略）\"><a href=\"#轮询（默认策略）\" class=\"headerlink\" title=\"轮询（默认策略）\"></a>轮询（默认策略）</h1><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除</p>\n<h1 id=\"指定权重\"><a href=\"#指定权重\" class=\"headerlink\" title=\"指定权重\"></a>指定权重</h1><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream servername &#123; </span><br><span class=\"line\">    server 192.168.0.1 weight=1; </span><br><span class=\"line\">    server 192.168.0.2 weight=12; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"IP绑定-ip-hash\"><a href=\"#IP绑定-ip-hash\" class=\"headerlink\" title=\"IP绑定 ip_hash\"></a>IP绑定 ip_hash</h1><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backserver &#123; </span><br><span class=\"line\">    ip_hash; </span><br><span class=\"line\">    server 192.168.0.14:88; </span><br><span class=\"line\">    server 192.168.0.15:80; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"fair（第三方）\"><a href=\"#fair（第三方）\" class=\"headerlink\" title=\"fair（第三方）\"></a>fair（第三方）</h1><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backserver &#123; </span><br><span class=\"line\">    server server1; </span><br><span class=\"line\">    server server2; </span><br><span class=\"line\">    fair; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这种策略具有很强的自适应性，但是实际的网络环境往往不是那么简单，因此须慎用。</p>\n<h1 id=\"url-hash（第三方）\"><a href=\"#url-hash（第三方）\" class=\"headerlink\" title=\"url_hash（第三方）\"></a>url_hash（第三方）</h1><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backserver &#123; </span><br><span class=\"line\">    server squid1:3128; </span><br><span class=\"line\">    server squid2:3128; </span><br><span class=\"line\">    hash $request_uri; </span><br><span class=\"line\">    hash_method crc32; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"轮询（默认策略）\"><a href=\"#轮询（默认策略）\" class=\"headerlink\" title=\"轮询（默认策略）\"></a>轮询（默认策略）</h1><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除</p>\n<h1 id=\"指定权重\"><a href=\"#指定权重\" class=\"headerlink\" title=\"指定权重\"></a>指定权重</h1><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream servername &#123; </span><br><span class=\"line\">    server 192.168.0.1 weight=1; </span><br><span class=\"line\">    server 192.168.0.2 weight=12; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"IP绑定-ip-hash\"><a href=\"#IP绑定-ip-hash\" class=\"headerlink\" title=\"IP绑定 ip_hash\"></a>IP绑定 ip_hash</h1><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backserver &#123; </span><br><span class=\"line\">    ip_hash; </span><br><span class=\"line\">    server 192.168.0.14:88; </span><br><span class=\"line\">    server 192.168.0.15:80; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"fair（第三方）\"><a href=\"#fair（第三方）\" class=\"headerlink\" title=\"fair（第三方）\"></a>fair（第三方）</h1><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backserver &#123; </span><br><span class=\"line\">    server server1; </span><br><span class=\"line\">    server server2; </span><br><span class=\"line\">    fair; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这种策略具有很强的自适应性，但是实际的网络环境往往不是那么简单，因此须慎用。</p>\n<h1 id=\"url-hash（第三方）\"><a href=\"#url-hash（第三方）\" class=\"headerlink\" title=\"url_hash（第三方）\"></a>url_hash（第三方）</h1><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backserver &#123; </span><br><span class=\"line\">    server squid1:3128; </span><br><span class=\"line\">    server squid2:3128; </span><br><span class=\"line\">    hash $request_uri; </span><br><span class=\"line\">    hash_method crc32; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Spring Boot后台启动不打印nohup.out","date":"2017-11-29T03:31:35.000Z","_content":"```\nnohup java -jar yatai_pro-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod >/dev/null &\n```\n>/dev/null 表示将标准输出信息重定向到”黑洞”\n","source":"_posts/nohup.md","raw":"---\ntitle: Spring Boot后台启动不打印nohup.out\ndate: 2017-11-29 11:31:35\ntags:\n---\n```\nnohup java -jar yatai_pro-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod >/dev/null &\n```\n>/dev/null 表示将标准输出信息重定向到”黑洞”\n","slug":"nohup","published":1,"updated":"2019-12-24T02:00:57.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jwc000q0j9k9edifxnc","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup java -jar yatai_pro-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod &gt;/dev/null &amp;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>/dev/null 表示将标准输出信息重定向到”黑洞”</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup java -jar yatai_pro-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod &gt;/dev/null &amp;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>/dev/null 表示将标准输出信息重定向到”黑洞”</p>\n</blockquote>\n"},{"title":"设计模式-模板方法模式","date":"2018-06-16T07:47:39.000Z","_content":"\n# 什么是模板方法模式\n\n定义一个操作中算法的骨架，而将这些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤\n\n好抽象的概念啊，文绉绉的东西就是不讨人喜欢，下面我用一个生活中常见的例子来举例说明吧\n\n饮料自动售卖机，生产饮料的过程大致分为四个步骤\n\n1. 烧水\n2. 冲泡饮料\n3. 把饮料倒入杯中\n4. 加入调料\n\n例如：\n咖啡：烧开开水->加入咖啡粉冲泡->把饮料倒入杯中->加入少许糖\n奶茶：烧开开水->加入奶茶粉冲泡->把饮料倒入杯中->加入珍珠\n\n不难发现，饮料制作过程中的步骤中的1烧水、3把饮料倒入杯中是重复工作，制泡哪种饮料都一样，那么也就是重复工作，我们可以把它设定为通用性操作\n\n我们只需要去关心步骤2和步骤4即可\n\n由于制泡饮料的步骤就是这4步，所以我们可以把它抽象成一个\"制作饮料模板\"出来，下面就以上面这个例子，我用代码来说明\n\nDrinkTemplate.java（模板类）\n\n由于避免继承它的子类去修改整体制作架构，所以这个方法用了final修饰符来修饰\n\n```\npublic abstract class DrinkTemplate {\n    public final void drinkTemplate() {\n        // 烧水\n        boilWater();\n        // 冲泡饮料\n        brew();\n        // 把饮料倒入杯中\n        pourInCup();\n        // 加调料\n        addCondiments();\n    }\n\n    // 加调料\n    protected abstract void addCondiments();\n\n    protected void pourInCup() {\n        System.out.println(\"把饮料倒入杯中\");\n    }\n\n    // 冲泡饮料\n    protected abstract void brew();\n\n    protected void boilWater() {\n        System.out.println(\"烧水中...\");\n    }\n}\n```\n\n抽象类中的抽象方法必须重写，抽象类中的非抽象方法可以选择重写\n\nMakeCoffee.java（制作咖啡）\n\n```\npublic class MakeCoffee extends DrinkTemplate{\n    @Override\n    protected void addCondiments() {\n        System.out.println(\"加糖...\");\n    }\n\n    @Override\n    protected void brew() {\n        System.out.println(\"加入咖啡粉冲泡...\");\n    }\n}\n```\n\n\nMakeOrange.java（制作橙汁）\n\n```\npublic class MakeOrange extends DrinkTemplate{\n    @Override\n    protected void addCondiments() {\n        System.out.println(\"加柠檬...\");\n    }\n\n    @Override\n    protected void brew() {\n        System.out.println(\"加入橘子粉冲泡...\");\n    }\n\n    protected void pourInCup() {\n        System.out.println(\"慢慢倒入\");\n    }\n}\n```\n\n这样只需要复写必须复写的方法，选择复写方法即可，大大提高了代码的复用性`\n","source":"_posts/pattern-template.md","raw":"---\ntitle: 设计模式-模板方法模式\ndate: 2018-06-16 15:47:39\ntags:\ncategories: 设计模式\n---\n\n# 什么是模板方法模式\n\n定义一个操作中算法的骨架，而将这些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤\n\n好抽象的概念啊，文绉绉的东西就是不讨人喜欢，下面我用一个生活中常见的例子来举例说明吧\n\n饮料自动售卖机，生产饮料的过程大致分为四个步骤\n\n1. 烧水\n2. 冲泡饮料\n3. 把饮料倒入杯中\n4. 加入调料\n\n例如：\n咖啡：烧开开水->加入咖啡粉冲泡->把饮料倒入杯中->加入少许糖\n奶茶：烧开开水->加入奶茶粉冲泡->把饮料倒入杯中->加入珍珠\n\n不难发现，饮料制作过程中的步骤中的1烧水、3把饮料倒入杯中是重复工作，制泡哪种饮料都一样，那么也就是重复工作，我们可以把它设定为通用性操作\n\n我们只需要去关心步骤2和步骤4即可\n\n由于制泡饮料的步骤就是这4步，所以我们可以把它抽象成一个\"制作饮料模板\"出来，下面就以上面这个例子，我用代码来说明\n\nDrinkTemplate.java（模板类）\n\n由于避免继承它的子类去修改整体制作架构，所以这个方法用了final修饰符来修饰\n\n```\npublic abstract class DrinkTemplate {\n    public final void drinkTemplate() {\n        // 烧水\n        boilWater();\n        // 冲泡饮料\n        brew();\n        // 把饮料倒入杯中\n        pourInCup();\n        // 加调料\n        addCondiments();\n    }\n\n    // 加调料\n    protected abstract void addCondiments();\n\n    protected void pourInCup() {\n        System.out.println(\"把饮料倒入杯中\");\n    }\n\n    // 冲泡饮料\n    protected abstract void brew();\n\n    protected void boilWater() {\n        System.out.println(\"烧水中...\");\n    }\n}\n```\n\n抽象类中的抽象方法必须重写，抽象类中的非抽象方法可以选择重写\n\nMakeCoffee.java（制作咖啡）\n\n```\npublic class MakeCoffee extends DrinkTemplate{\n    @Override\n    protected void addCondiments() {\n        System.out.println(\"加糖...\");\n    }\n\n    @Override\n    protected void brew() {\n        System.out.println(\"加入咖啡粉冲泡...\");\n    }\n}\n```\n\n\nMakeOrange.java（制作橙汁）\n\n```\npublic class MakeOrange extends DrinkTemplate{\n    @Override\n    protected void addCondiments() {\n        System.out.println(\"加柠檬...\");\n    }\n\n    @Override\n    protected void brew() {\n        System.out.println(\"加入橘子粉冲泡...\");\n    }\n\n    protected void pourInCup() {\n        System.out.println(\"慢慢倒入\");\n    }\n}\n```\n\n这样只需要复写必须复写的方法，选择复写方法即可，大大提高了代码的复用性`\n","slug":"pattern-template","published":1,"updated":"2019-12-24T02:00:57.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jwd000r0j9ksaqynoez","content":"<h1 id=\"什么是模板方法模式\"><a href=\"#什么是模板方法模式\" class=\"headerlink\" title=\"什么是模板方法模式\"></a>什么是模板方法模式</h1><p>定义一个操作中算法的骨架，而将这些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤</p>\n<p>好抽象的概念啊，文绉绉的东西就是不讨人喜欢，下面我用一个生活中常见的例子来举例说明吧</p>\n<p>饮料自动售卖机，生产饮料的过程大致分为四个步骤</p>\n<ol>\n<li>烧水</li>\n<li>冲泡饮料</li>\n<li>把饮料倒入杯中</li>\n<li>加入调料</li>\n</ol>\n<p>例如：<br>咖啡：烧开开水-&gt;加入咖啡粉冲泡-&gt;把饮料倒入杯中-&gt;加入少许糖<br>奶茶：烧开开水-&gt;加入奶茶粉冲泡-&gt;把饮料倒入杯中-&gt;加入珍珠</p>\n<p>不难发现，饮料制作过程中的步骤中的1烧水、3把饮料倒入杯中是重复工作，制泡哪种饮料都一样，那么也就是重复工作，我们可以把它设定为通用性操作</p>\n<p>我们只需要去关心步骤2和步骤4即可</p>\n<p>由于制泡饮料的步骤就是这4步，所以我们可以把它抽象成一个”制作饮料模板”出来，下面就以上面这个例子，我用代码来说明</p>\n<p>DrinkTemplate.java（模板类）</p>\n<p>由于避免继承它的子类去修改整体制作架构，所以这个方法用了final修饰符来修饰</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class DrinkTemplate &#123;</span><br><span class=\"line\">    public final void drinkTemplate() &#123;</span><br><span class=\"line\">        // 烧水</span><br><span class=\"line\">        boilWater();</span><br><span class=\"line\">        // 冲泡饮料</span><br><span class=\"line\">        brew();</span><br><span class=\"line\">        // 把饮料倒入杯中</span><br><span class=\"line\">        pourInCup();</span><br><span class=\"line\">        // 加调料</span><br><span class=\"line\">        addCondiments();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 加调料</span><br><span class=\"line\">    protected abstract void addCondiments();</span><br><span class=\"line\"></span><br><span class=\"line\">    protected void pourInCup() &#123;</span><br><span class=\"line\">        System.out.println(&quot;把饮料倒入杯中&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 冲泡饮料</span><br><span class=\"line\">    protected abstract void brew();</span><br><span class=\"line\"></span><br><span class=\"line\">    protected void boilWater() &#123;</span><br><span class=\"line\">        System.out.println(&quot;烧水中...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抽象类中的抽象方法必须重写，抽象类中的非抽象方法可以选择重写</p>\n<p>MakeCoffee.java（制作咖啡）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MakeCoffee extends DrinkTemplate&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void addCondiments() &#123;</span><br><span class=\"line\">        System.out.println(&quot;加糖...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void brew() &#123;</span><br><span class=\"line\">        System.out.println(&quot;加入咖啡粉冲泡...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MakeOrange.java（制作橙汁）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MakeOrange extends DrinkTemplate&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void addCondiments() &#123;</span><br><span class=\"line\">        System.out.println(&quot;加柠檬...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void brew() &#123;</span><br><span class=\"line\">        System.out.println(&quot;加入橘子粉冲泡...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected void pourInCup() &#123;</span><br><span class=\"line\">        System.out.println(&quot;慢慢倒入&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样只需要复写必须复写的方法，选择复写方法即可，大大提高了代码的复用性`</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是模板方法模式\"><a href=\"#什么是模板方法模式\" class=\"headerlink\" title=\"什么是模板方法模式\"></a>什么是模板方法模式</h1><p>定义一个操作中算法的骨架，而将这些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤</p>\n<p>好抽象的概念啊，文绉绉的东西就是不讨人喜欢，下面我用一个生活中常见的例子来举例说明吧</p>\n<p>饮料自动售卖机，生产饮料的过程大致分为四个步骤</p>\n<ol>\n<li>烧水</li>\n<li>冲泡饮料</li>\n<li>把饮料倒入杯中</li>\n<li>加入调料</li>\n</ol>\n<p>例如：<br>咖啡：烧开开水-&gt;加入咖啡粉冲泡-&gt;把饮料倒入杯中-&gt;加入少许糖<br>奶茶：烧开开水-&gt;加入奶茶粉冲泡-&gt;把饮料倒入杯中-&gt;加入珍珠</p>\n<p>不难发现，饮料制作过程中的步骤中的1烧水、3把饮料倒入杯中是重复工作，制泡哪种饮料都一样，那么也就是重复工作，我们可以把它设定为通用性操作</p>\n<p>我们只需要去关心步骤2和步骤4即可</p>\n<p>由于制泡饮料的步骤就是这4步，所以我们可以把它抽象成一个”制作饮料模板”出来，下面就以上面这个例子，我用代码来说明</p>\n<p>DrinkTemplate.java（模板类）</p>\n<p>由于避免继承它的子类去修改整体制作架构，所以这个方法用了final修饰符来修饰</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class DrinkTemplate &#123;</span><br><span class=\"line\">    public final void drinkTemplate() &#123;</span><br><span class=\"line\">        // 烧水</span><br><span class=\"line\">        boilWater();</span><br><span class=\"line\">        // 冲泡饮料</span><br><span class=\"line\">        brew();</span><br><span class=\"line\">        // 把饮料倒入杯中</span><br><span class=\"line\">        pourInCup();</span><br><span class=\"line\">        // 加调料</span><br><span class=\"line\">        addCondiments();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 加调料</span><br><span class=\"line\">    protected abstract void addCondiments();</span><br><span class=\"line\"></span><br><span class=\"line\">    protected void pourInCup() &#123;</span><br><span class=\"line\">        System.out.println(&quot;把饮料倒入杯中&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 冲泡饮料</span><br><span class=\"line\">    protected abstract void brew();</span><br><span class=\"line\"></span><br><span class=\"line\">    protected void boilWater() &#123;</span><br><span class=\"line\">        System.out.println(&quot;烧水中...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抽象类中的抽象方法必须重写，抽象类中的非抽象方法可以选择重写</p>\n<p>MakeCoffee.java（制作咖啡）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MakeCoffee extends DrinkTemplate&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void addCondiments() &#123;</span><br><span class=\"line\">        System.out.println(&quot;加糖...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void brew() &#123;</span><br><span class=\"line\">        System.out.println(&quot;加入咖啡粉冲泡...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MakeOrange.java（制作橙汁）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MakeOrange extends DrinkTemplate&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void addCondiments() &#123;</span><br><span class=\"line\">        System.out.println(&quot;加柠檬...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void brew() &#123;</span><br><span class=\"line\">        System.out.println(&quot;加入橘子粉冲泡...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected void pourInCup() &#123;</span><br><span class=\"line\">        System.out.println(&quot;慢慢倒入&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样只需要复写必须复写的方法，选择复写方法即可，大大提高了代码的复用性`</p>\n"},{"title":"axios使用Promise刷新token","date":"2019-12-24T01:18:50.000Z","_content":"![](http://s1.wailian.download/2019/12/24/snow-ball-4708528_1280.jpg)\n\n# 问题\n\n最近遇到个需求：前端登录后，后端返回`token`和`refreshToken`，当`token`过期时需要使用`refreshToken`去获取新的`token`和新的`refreshToken`，前端需要做到无感知刷新`token`\n\n# 方法\n\n利用 axios 的拦截器，拦截返回后的数据。当接口返回`token`过期后，先刷新`token`然后重试\n\n# 难点\n\n由于发起网络请求是异步的，当同时发起多个请求，而刷新 token 的接口还没有返回时，如何让这些请求等待刷新接口的返回，然后使用返回的新 token 重新发起请求呢？\n\n# 实现\n\n```javascript\nimport axios from \"axios\";\n\n// 创建一个axios实例\nconst instance = axios.create({\n  baseURL: \"/api\",\n  timeout: 300000,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    \"X-Token\": getLocalToken() // headers塞token\n  }\n});\n\n// 从localStorage中获取token\nfunction getLocalToken() {\n  const token = window.localStorage.getItem(\"token\");\n  return token;\n}\n\n// 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中\ninstance.setToken = token => {\n  instance.defaults.headers[\"X-Token\"] = token;\n  window.localStorage.setItem(\"token\", token);\n};\n\nfunction refreshToken() {\n  // instance是当前request.js中已创建的axios实例\n  return instance.post(\"/refreshtoken\").then(res => res.data);\n}\n\n// 是否正在刷新的标记\nlet isRefreshing = false;\n// 重试队列，每一项将是一个待执行的函数形式\nlet retryRequests = [];\n// 请求后拦截 axios.interceptors.request.use()\ninstance.interceptors.response.use(\n  response => {\n    const { code } = response.data;\n    // 约定当code === 4001时，为token过期\n    if (code === 4001) {\n      // config是为请求提供的配置信息\n      const config = response.config;\n      if (!isRefreshing) {\n        isRefreshing = true;\n        return refreshToken().then(res => {\n            const { token } = res.data;\n            instance.setToken(token);\n            config.headers[\"X-Token\"] = token;\n            // 注意： 原请求已经将baseURL进行拼接，此处不要重复拼接\n            config.baseURL = \"\";\n            // 将队列中的请求进行重试\n            retryRequests.forEach(cb => cb(token));\n            retryRequests = [];\n            return instance(config);\n          }).catch(res => {\n            console.error(\"refreshtoken error =>\", res);\n            window.location.href = \"/\";\n          }).finally(() => {\n            // 保证下次刷新能够正常进入\n            isRefreshing = false;\n          });\n      } else {\n        // 正在刷新token，将返回一个未执行resolve的promise\n        return new Promise(resolve => {\n          // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行\n          retryRequests.push(token => {\n            config.baseURL = \"\";\n            config.headers[\"X-Token\"] = token;\n            resolve(instance(config));\n          });\n        });\n      }\n    }\n    return response;\n  },\n  error => {\n    return Promise.reject(error);\n  }\n);\n\nexport default instance;\n```\n","source":"_posts/promise-to-refreshtoken.md","raw":"---\ntitle: axios使用Promise刷新token\ndate: 2019-12-24 09:18:50\ntags: 前端\n---\n![](http://s1.wailian.download/2019/12/24/snow-ball-4708528_1280.jpg)\n\n# 问题\n\n最近遇到个需求：前端登录后，后端返回`token`和`refreshToken`，当`token`过期时需要使用`refreshToken`去获取新的`token`和新的`refreshToken`，前端需要做到无感知刷新`token`\n\n# 方法\n\n利用 axios 的拦截器，拦截返回后的数据。当接口返回`token`过期后，先刷新`token`然后重试\n\n# 难点\n\n由于发起网络请求是异步的，当同时发起多个请求，而刷新 token 的接口还没有返回时，如何让这些请求等待刷新接口的返回，然后使用返回的新 token 重新发起请求呢？\n\n# 实现\n\n```javascript\nimport axios from \"axios\";\n\n// 创建一个axios实例\nconst instance = axios.create({\n  baseURL: \"/api\",\n  timeout: 300000,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    \"X-Token\": getLocalToken() // headers塞token\n  }\n});\n\n// 从localStorage中获取token\nfunction getLocalToken() {\n  const token = window.localStorage.getItem(\"token\");\n  return token;\n}\n\n// 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中\ninstance.setToken = token => {\n  instance.defaults.headers[\"X-Token\"] = token;\n  window.localStorage.setItem(\"token\", token);\n};\n\nfunction refreshToken() {\n  // instance是当前request.js中已创建的axios实例\n  return instance.post(\"/refreshtoken\").then(res => res.data);\n}\n\n// 是否正在刷新的标记\nlet isRefreshing = false;\n// 重试队列，每一项将是一个待执行的函数形式\nlet retryRequests = [];\n// 请求后拦截 axios.interceptors.request.use()\ninstance.interceptors.response.use(\n  response => {\n    const { code } = response.data;\n    // 约定当code === 4001时，为token过期\n    if (code === 4001) {\n      // config是为请求提供的配置信息\n      const config = response.config;\n      if (!isRefreshing) {\n        isRefreshing = true;\n        return refreshToken().then(res => {\n            const { token } = res.data;\n            instance.setToken(token);\n            config.headers[\"X-Token\"] = token;\n            // 注意： 原请求已经将baseURL进行拼接，此处不要重复拼接\n            config.baseURL = \"\";\n            // 将队列中的请求进行重试\n            retryRequests.forEach(cb => cb(token));\n            retryRequests = [];\n            return instance(config);\n          }).catch(res => {\n            console.error(\"refreshtoken error =>\", res);\n            window.location.href = \"/\";\n          }).finally(() => {\n            // 保证下次刷新能够正常进入\n            isRefreshing = false;\n          });\n      } else {\n        // 正在刷新token，将返回一个未执行resolve的promise\n        return new Promise(resolve => {\n          // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行\n          retryRequests.push(token => {\n            config.baseURL = \"\";\n            config.headers[\"X-Token\"] = token;\n            resolve(instance(config));\n          });\n        });\n      }\n    }\n    return response;\n  },\n  error => {\n    return Promise.reject(error);\n  }\n);\n\nexport default instance;\n```\n","slug":"promise-to-refreshtoken","published":1,"updated":"2019-12-24T02:14:59.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jwe000s0j9k30riapwx","content":"<p><img src=\"http://s1.wailian.download/2019/12/24/snow-ball-4708528_1280.jpg\" alt=\"\"></p>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>最近遇到个需求：前端登录后，后端返回<code>token</code>和<code>refreshToken</code>，当<code>token</code>过期时需要使用<code>refreshToken</code>去获取新的<code>token</code>和新的<code>refreshToken</code>，前端需要做到无感知刷新<code>token</code></p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>利用 axios 的拦截器，拦截返回后的数据。当接口返回<code>token</code>过期后，先刷新<code>token</code>然后重试</p>\n<h1 id=\"难点\"><a href=\"#难点\" class=\"headerlink\" title=\"难点\"></a>难点</h1><p>由于发起网络请求是异步的，当同时发起多个请求，而刷新 token 的接口还没有返回时，如何让这些请求等待刷新接口的返回，然后使用返回的新 token 重新发起请求呢？</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">\"axios\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个axios实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> instance = axios.create(&#123;</span><br><span class=\"line\">  baseURL: <span class=\"string\">\"/api\"</span>,</span><br><span class=\"line\">  timeout: <span class=\"number\">300000</span>,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"application/json\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"X-Token\"</span>: getLocalToken() <span class=\"comment\">// headers塞token</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从localStorage中获取token</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getLocalToken</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> token = <span class=\"built_in\">window</span>.localStorage.getItem(<span class=\"string\">\"token\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中</span></span><br><span class=\"line\">instance.setToken = <span class=\"function\"><span class=\"params\">token</span> =&gt;</span> &#123;</span><br><span class=\"line\">  instance.defaults.headers[<span class=\"string\">\"X-Token\"</span>] = token;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.localStorage.setItem(<span class=\"string\">\"token\"</span>, token);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">refreshToken</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// instance是当前request.js中已创建的axios实例</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance.post(<span class=\"string\">\"/refreshtoken\"</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否正在刷新的标记</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isRefreshing = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">// 重试队列，每一项将是一个待执行的函数形式</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> retryRequests = [];</span><br><span class=\"line\"><span class=\"comment\">// 请求后拦截 axios.interceptors.request.use()</span></span><br><span class=\"line\">instance.interceptors.response.use(</span><br><span class=\"line\">  response =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; code &#125; = response.data;</span><br><span class=\"line\">    <span class=\"comment\">// 约定当code === 4001时，为token过期</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (code === <span class=\"number\">4001</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// config是为请求提供的配置信息</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> config = response.config;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isRefreshing) &#123;</span><br><span class=\"line\">        isRefreshing = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> refreshToken().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123; token &#125; = res.data;</span><br><span class=\"line\">            instance.setToken(token);</span><br><span class=\"line\">            config.headers[<span class=\"string\">\"X-Token\"</span>] = token;</span><br><span class=\"line\">            <span class=\"comment\">// 注意： 原请求已经将baseURL进行拼接，此处不要重复拼接</span></span><br><span class=\"line\">            config.baseURL = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 将队列中的请求进行重试</span></span><br><span class=\"line\">            retryRequests.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb(token));</span><br><span class=\"line\">            retryRequests = [];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance(config);</span><br><span class=\"line\">          &#125;).catch(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.error(<span class=\"string\">\"refreshtoken error =&gt;\"</span>, res);</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.location.href = <span class=\"string\">\"/\"</span>;</span><br><span class=\"line\">          &#125;).finally(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 保证下次刷新能够正常进入</span></span><br><span class=\"line\">            isRefreshing = <span class=\"literal\">false</span>;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 正在刷新token，将返回一个未执行resolve的promise</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行</span></span><br><span class=\"line\">          retryRequests.push(<span class=\"function\"><span class=\"params\">token</span> =&gt;</span> &#123;</span><br><span class=\"line\">            config.baseURL = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            config.headers[<span class=\"string\">\"X-Token\"</span>] = token;</span><br><span class=\"line\">            resolve(instance(config));</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> instance;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://s1.wailian.download/2019/12/24/snow-ball-4708528_1280.jpg\" alt=\"\"></p>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>最近遇到个需求：前端登录后，后端返回<code>token</code>和<code>refreshToken</code>，当<code>token</code>过期时需要使用<code>refreshToken</code>去获取新的<code>token</code>和新的<code>refreshToken</code>，前端需要做到无感知刷新<code>token</code></p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>利用 axios 的拦截器，拦截返回后的数据。当接口返回<code>token</code>过期后，先刷新<code>token</code>然后重试</p>\n<h1 id=\"难点\"><a href=\"#难点\" class=\"headerlink\" title=\"难点\"></a>难点</h1><p>由于发起网络请求是异步的，当同时发起多个请求，而刷新 token 的接口还没有返回时，如何让这些请求等待刷新接口的返回，然后使用返回的新 token 重新发起请求呢？</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">\"axios\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个axios实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> instance = axios.create(&#123;</span><br><span class=\"line\">  baseURL: <span class=\"string\">\"/api\"</span>,</span><br><span class=\"line\">  timeout: <span class=\"number\">300000</span>,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"application/json\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"X-Token\"</span>: getLocalToken() <span class=\"comment\">// headers塞token</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从localStorage中获取token</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getLocalToken</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> token = <span class=\"built_in\">window</span>.localStorage.getItem(<span class=\"string\">\"token\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中</span></span><br><span class=\"line\">instance.setToken = <span class=\"function\"><span class=\"params\">token</span> =&gt;</span> &#123;</span><br><span class=\"line\">  instance.defaults.headers[<span class=\"string\">\"X-Token\"</span>] = token;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.localStorage.setItem(<span class=\"string\">\"token\"</span>, token);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">refreshToken</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// instance是当前request.js中已创建的axios实例</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance.post(<span class=\"string\">\"/refreshtoken\"</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否正在刷新的标记</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isRefreshing = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">// 重试队列，每一项将是一个待执行的函数形式</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> retryRequests = [];</span><br><span class=\"line\"><span class=\"comment\">// 请求后拦截 axios.interceptors.request.use()</span></span><br><span class=\"line\">instance.interceptors.response.use(</span><br><span class=\"line\">  response =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; code &#125; = response.data;</span><br><span class=\"line\">    <span class=\"comment\">// 约定当code === 4001时，为token过期</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (code === <span class=\"number\">4001</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// config是为请求提供的配置信息</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> config = response.config;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isRefreshing) &#123;</span><br><span class=\"line\">        isRefreshing = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> refreshToken().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123; token &#125; = res.data;</span><br><span class=\"line\">            instance.setToken(token);</span><br><span class=\"line\">            config.headers[<span class=\"string\">\"X-Token\"</span>] = token;</span><br><span class=\"line\">            <span class=\"comment\">// 注意： 原请求已经将baseURL进行拼接，此处不要重复拼接</span></span><br><span class=\"line\">            config.baseURL = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 将队列中的请求进行重试</span></span><br><span class=\"line\">            retryRequests.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb(token));</span><br><span class=\"line\">            retryRequests = [];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance(config);</span><br><span class=\"line\">          &#125;).catch(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.error(<span class=\"string\">\"refreshtoken error =&gt;\"</span>, res);</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.location.href = <span class=\"string\">\"/\"</span>;</span><br><span class=\"line\">          &#125;).finally(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 保证下次刷新能够正常进入</span></span><br><span class=\"line\">            isRefreshing = <span class=\"literal\">false</span>;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 正在刷新token，将返回一个未执行resolve的promise</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行</span></span><br><span class=\"line\">          retryRequests.push(<span class=\"function\"><span class=\"params\">token</span> =&gt;</span> &#123;</span><br><span class=\"line\">            config.baseURL = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            config.headers[<span class=\"string\">\"X-Token\"</span>] = token;</span><br><span class=\"line\">            resolve(instance(config));</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> instance;</span><br></pre></td></tr></table></figure>\n"},{"title":"接口限流的令牌桶算法以及使用方法","date":"2020-07-03T02:11:12.000Z","_content":"\n在开发高并发系统时，有三把利器来保护系统：**缓存** **降级** **限流**\n\n## 限流目的\n\n限流的目的是通过对并发请求进行限速，一旦达到限制速率则可以拒绝服务或者排队等待等处理\n\n## 限流算法\n\n常用的限流算法有**令牌桶算法**和**漏桶算法** \n\n漏桶算法要求处理请求以一个恒定的速率，不能允许突发请求的快速处理，而令牌桶算法就比较适合\n\n令牌桶算法的原理就是系统以恒定的速率产生令牌放入令牌桶中。令牌桶有容量，当满时，再放入的令牌就会被丢弃。当想处理一个请求的时候，需要从令牌桶中取出一个令牌，如果没有，则拒绝（非阻塞式）或者等待（阻塞式）\n\n![4179645397-5b6e4903ec371_articlex.png](http://s1.wailian.download/2020/07/03/4179645397-5b6e4903ec371_articlex.png)\n\nGoogle开源项目Guava中RateLimiter使用的就是令牌桶算法，下面实例是使用自定义注解实现限制接口流量\n\n\n定义一个注解\n\n```java\n@Inherited\n@Documented\n@Target({ElementType.METHOD, ElementType.FIELD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RateLimitAspect {\n\n}\n```\n\n定义切面\n\n```java\n@Component\n@Scope\n@Aspect\npublic class RateLimitAop {\n    @Autowired(required = false)\n    private HttpServletResponse response;\n\n    private RateLimiter rateLimiter = RateLimiter.create(5); //比如说，我这里设置\"并发数\"为5\n\n    @Pointcut(\"@annotation(cc.wangweiye.ratelimit.RateLimitAspect)\")\n    public void serviceLimit() {\n\n    }\n\n    @Around(\"serviceLimit()\")\n    public Object around(ProceedingJoinPoint joinPoint) {\n        Boolean flag = rateLimiter.tryAcquire();\n        Object obj = \"无返回\";\n        try {\n            if (flag) {\n                obj = joinPoint.proceed();\n            } else {\n                String result = \"failure\";\n\n                output(response, result);\n            }\n        } catch (Throwable e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"flag=\" + flag + \",obj=\" + obj);\n        return obj;\n    }\n\n    public void output(HttpServletResponse response, String msg) throws IOException {\n        response.setContentType(\"application/json;charset=UTF-8\");\n        ServletOutputStream outputStream = null;\n        try {\n            outputStream = response.getOutputStream();\n            outputStream.write(msg.getBytes(\"UTF-8\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            outputStream.flush();\n            outputStream.close();\n        }\n    }\n}\n```\n\n[源码地址](https://github.com/wangweiye01/ratelimit)","source":"_posts/ratelimit.md","raw":"---\ntitle: 接口限流的令牌桶算法以及使用方法\ndate: 2020-07-03 10:11:12\ntags:\n---\n\n在开发高并发系统时，有三把利器来保护系统：**缓存** **降级** **限流**\n\n## 限流目的\n\n限流的目的是通过对并发请求进行限速，一旦达到限制速率则可以拒绝服务或者排队等待等处理\n\n## 限流算法\n\n常用的限流算法有**令牌桶算法**和**漏桶算法** \n\n漏桶算法要求处理请求以一个恒定的速率，不能允许突发请求的快速处理，而令牌桶算法就比较适合\n\n令牌桶算法的原理就是系统以恒定的速率产生令牌放入令牌桶中。令牌桶有容量，当满时，再放入的令牌就会被丢弃。当想处理一个请求的时候，需要从令牌桶中取出一个令牌，如果没有，则拒绝（非阻塞式）或者等待（阻塞式）\n\n![4179645397-5b6e4903ec371_articlex.png](http://s1.wailian.download/2020/07/03/4179645397-5b6e4903ec371_articlex.png)\n\nGoogle开源项目Guava中RateLimiter使用的就是令牌桶算法，下面实例是使用自定义注解实现限制接口流量\n\n\n定义一个注解\n\n```java\n@Inherited\n@Documented\n@Target({ElementType.METHOD, ElementType.FIELD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RateLimitAspect {\n\n}\n```\n\n定义切面\n\n```java\n@Component\n@Scope\n@Aspect\npublic class RateLimitAop {\n    @Autowired(required = false)\n    private HttpServletResponse response;\n\n    private RateLimiter rateLimiter = RateLimiter.create(5); //比如说，我这里设置\"并发数\"为5\n\n    @Pointcut(\"@annotation(cc.wangweiye.ratelimit.RateLimitAspect)\")\n    public void serviceLimit() {\n\n    }\n\n    @Around(\"serviceLimit()\")\n    public Object around(ProceedingJoinPoint joinPoint) {\n        Boolean flag = rateLimiter.tryAcquire();\n        Object obj = \"无返回\";\n        try {\n            if (flag) {\n                obj = joinPoint.proceed();\n            } else {\n                String result = \"failure\";\n\n                output(response, result);\n            }\n        } catch (Throwable e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"flag=\" + flag + \",obj=\" + obj);\n        return obj;\n    }\n\n    public void output(HttpServletResponse response, String msg) throws IOException {\n        response.setContentType(\"application/json;charset=UTF-8\");\n        ServletOutputStream outputStream = null;\n        try {\n            outputStream = response.getOutputStream();\n            outputStream.write(msg.getBytes(\"UTF-8\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            outputStream.flush();\n            outputStream.close();\n        }\n    }\n}\n```\n\n[源码地址](https://github.com/wangweiye01/ratelimit)","slug":"ratelimit","published":1,"updated":"2020-07-03T03:08:51.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jwu000u0j9kv3jvqiz2","content":"<p>在开发高并发系统时，有三把利器来保护系统：<strong>缓存</strong> <strong>降级</strong> <strong>限流</strong></p>\n<h2 id=\"限流目的\"><a href=\"#限流目的\" class=\"headerlink\" title=\"限流目的\"></a>限流目的</h2><p>限流的目的是通过对并发请求进行限速，一旦达到限制速率则可以拒绝服务或者排队等待等处理</p>\n<h2 id=\"限流算法\"><a href=\"#限流算法\" class=\"headerlink\" title=\"限流算法\"></a>限流算法</h2><p>常用的限流算法有<strong>令牌桶算法</strong>和<strong>漏桶算法</strong> </p>\n<p>漏桶算法要求处理请求以一个恒定的速率，不能允许突发请求的快速处理，而令牌桶算法就比较适合</p>\n<p>令牌桶算法的原理就是系统以恒定的速率产生令牌放入令牌桶中。令牌桶有容量，当满时，再放入的令牌就会被丢弃。当想处理一个请求的时候，需要从令牌桶中取出一个令牌，如果没有，则拒绝（非阻塞式）或者等待（阻塞式）</p>\n<p><img src=\"http://s1.wailian.download/2020/07/03/4179645397-5b6e4903ec371_articlex.png\" alt=\"4179645397-5b6e4903ec371_articlex.png\"></p>\n<p>Google开源项目Guava中RateLimiter使用的就是令牌桶算法，下面实例是使用自定义注解实现限制接口流量</p>\n<p>定义一个注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RateLimitAspect &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义切面</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RateLimitAop</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>(required = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HttpServletResponse response;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RateLimiter rateLimiter = RateLimiter.create(<span class=\"number\">5</span>); <span class=\"comment\">//比如说，我这里设置\"并发数\"为5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@annotation(cc.wangweiye.ratelimit.RateLimitAspect)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">serviceLimit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around</span>(<span class=\"string\">\"serviceLimit()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class=\"line\">        Boolean flag = rateLimiter.tryAcquire();</span><br><span class=\"line\">        Object obj = <span class=\"string\">\"无返回\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">                obj = joinPoint.proceed();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                String result = <span class=\"string\">\"failure\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                output(response, result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"flag=\"</span> + flag + <span class=\"string\">\",obj=\"</span> + obj);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">output</span><span class=\"params\">(HttpServletResponse response, String msg)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">\"application/json;charset=UTF-8\"</span>);</span><br><span class=\"line\">        ServletOutputStream outputStream = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            outputStream = response.getOutputStream();</span><br><span class=\"line\">            outputStream.write(msg.getBytes(<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            outputStream.flush();</span><br><span class=\"line\">            outputStream.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/wangweiye01/ratelimit\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在开发高并发系统时，有三把利器来保护系统：<strong>缓存</strong> <strong>降级</strong> <strong>限流</strong></p>\n<h2 id=\"限流目的\"><a href=\"#限流目的\" class=\"headerlink\" title=\"限流目的\"></a>限流目的</h2><p>限流的目的是通过对并发请求进行限速，一旦达到限制速率则可以拒绝服务或者排队等待等处理</p>\n<h2 id=\"限流算法\"><a href=\"#限流算法\" class=\"headerlink\" title=\"限流算法\"></a>限流算法</h2><p>常用的限流算法有<strong>令牌桶算法</strong>和<strong>漏桶算法</strong> </p>\n<p>漏桶算法要求处理请求以一个恒定的速率，不能允许突发请求的快速处理，而令牌桶算法就比较适合</p>\n<p>令牌桶算法的原理就是系统以恒定的速率产生令牌放入令牌桶中。令牌桶有容量，当满时，再放入的令牌就会被丢弃。当想处理一个请求的时候，需要从令牌桶中取出一个令牌，如果没有，则拒绝（非阻塞式）或者等待（阻塞式）</p>\n<p><img src=\"http://s1.wailian.download/2020/07/03/4179645397-5b6e4903ec371_articlex.png\" alt=\"4179645397-5b6e4903ec371_articlex.png\"></p>\n<p>Google开源项目Guava中RateLimiter使用的就是令牌桶算法，下面实例是使用自定义注解实现限制接口流量</p>\n<p>定义一个注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RateLimitAspect &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义切面</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RateLimitAop</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>(required = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HttpServletResponse response;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RateLimiter rateLimiter = RateLimiter.create(<span class=\"number\">5</span>); <span class=\"comment\">//比如说，我这里设置\"并发数\"为5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@annotation(cc.wangweiye.ratelimit.RateLimitAspect)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">serviceLimit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around</span>(<span class=\"string\">\"serviceLimit()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class=\"line\">        Boolean flag = rateLimiter.tryAcquire();</span><br><span class=\"line\">        Object obj = <span class=\"string\">\"无返回\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">                obj = joinPoint.proceed();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                String result = <span class=\"string\">\"failure\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                output(response, result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"flag=\"</span> + flag + <span class=\"string\">\",obj=\"</span> + obj);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">output</span><span class=\"params\">(HttpServletResponse response, String msg)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">\"application/json;charset=UTF-8\"</span>);</span><br><span class=\"line\">        ServletOutputStream outputStream = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            outputStream = response.getOutputStream();</span><br><span class=\"line\">            outputStream.write(msg.getBytes(<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            outputStream.flush();</span><br><span class=\"line\">            outputStream.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/wangweiye01/ratelimit\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>\n"},{"title":"mysql计算两个坐标的距离","date":"2017-12-05T10:04:35.000Z","_content":"```\nround(6378.138*2*asin(sqrt(pow(sin( (lat1*pi()/180-lat2*pi()/180)/2),2)+cos(lat1*pi()/180)*cos(lat2*pi()/180)* pow(sin( (lng1*pi()/180-lng2*pi()/180)/2),2)))*1000)\n```\n","source":"_posts/round.md","raw":"---\ntitle: mysql计算两个坐标的距离\ndate: 2017-12-05 18:04:35\ntags:\n---\n```\nround(6378.138*2*asin(sqrt(pow(sin( (lat1*pi()/180-lat2*pi()/180)/2),2)+cos(lat1*pi()/180)*cos(lat2*pi()/180)* pow(sin( (lng1*pi()/180-lng2*pi()/180)/2),2)))*1000)\n```\n","slug":"round","published":1,"updated":"2019-12-24T02:00:57.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jww000w0j9kcwt1fa13","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">round(6378.138*2*asin(sqrt(pow(sin( (lat1*pi()/180-lat2*pi()/180)/2),2)+cos(lat1*pi()/180)*cos(lat2*pi()/180)* pow(sin( (lng1*pi()/180-lng2*pi()/180)/2),2)))*1000)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">round(6378.138*2*asin(sqrt(pow(sin( (lat1*pi()/180-lat2*pi()/180)/2),2)+cos(lat1*pi()/180)*cos(lat2*pi()/180)* pow(sin( (lng1*pi()/180-lng2*pi()/180)/2),2)))*1000)</span><br></pre></td></tr></table></figure>\n"},{"title":"扫描二维码（登录，支付）后立即通知","date":"2018-03-05T02:48:42.000Z","top":1000,"_content":"\n![](http://www.wailian.work/images/2018/03/05/1211.jpg)\n\n> 最近在做微信的扫码支付，遇到一个问题：如何在用户扫码支付完成之后，客户端立即得到通知，进行下一步的跳转？\n\n首先想到的策略可能是客户端轮询查询订单状态，根据返回结果进行跳转\n\n这个方式有明显的缺点，轮询时间设置短，频繁发送请求，对服务器以及数据库都会产生压力；轮询时间过长，用户等待时间长，体验很差；\n\n针对这个问题想到了微信网页版的扫码登录（扫码完成后，立即登录），现在研究一下它的原理并实现相同的功能\n\n# 微信扫码登录原理\n\n![pengding](http://www.wailian.work/images/2018/03/05/pending.png)\n\n根据图片中，前端二维码页面发送一个网络请求，但是这个请求并没有立即返回\n\n![408](http://www.wailian.work/images/2018/03/05/408.png)\n\n一段时间没有扫描后，后端返回408，前端重新发起一个相同的网络请求，并继续pending\n\n据此猜测大概实现原理如下：\n\n1. 进入网站-生成一个唯一标识(比如UUID)\n2. 跳转到二维码页面（二维码中的链接包含次UUID）\n3. 二维码页面向服务端发起请求，查询二维码是被扫登录\n4. 服务器收到请求，查询。如果未扫登录，进入等待(wait)，不立即返回\n5. 一旦被扫，立即返回(notify)\n6. 页面收到结果，做后续处理\n\n步骤大概就是如此，但是有个问题，步骤3如果请求超时，如何处理？处理方式是，一段固定时间后，返回408（timeout）\n\n# UUID缓存\n\n```\npublic static Map<String, ScanPool> cacheMap = new ConcurrentHashMap<String, ScanPool>();\n```\n\n一定要使用ConcurrentHashMap否则多线程操作集合会报错ConcurrentModificationException\n\n单线程中出现该异常的原因是，对一个集合遍历的同时，又对该集合进行了增删的操作\n\n多线程中更易出现该异常，当你在一个线程中对一数据集合进行遍历，正赶上另外一个线程对该数据集合进行增删操作时便会出现该异常\n\n缓存还要设置自动清理功能，防止增长过大\n\n# 生成二维码\n\n```\n@RequestMapping(\"/qrcode/{uuid}\")\n@ResponseBody\nString createQRCode(@PathVariable String uuid, HttpServletResponse response) {\n    System.out.println(\"生成二维码\");\n\n    String text = \"http://2b082e46.ngrok.io/login/\" + uuid;\n    int width = 300;\n    int height = 300;\n    String format = \"png\";\n    //将UUID放入缓存\n    ScanPool pool = new ScanPool();\n    PoolCache.cacheMap.put(uuid, pool);\n    try {\n        Map<EncodeHintType, Object> hints = new HashMap<EncodeHintType, Object>();\n        hints.put(EncodeHintType.CHARACTER_SET, \"utf-8\");\n        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); //容错率\n        BitMatrix bitMatrix = new MultiFormatWriter().encode(text, BarcodeFormat.QR_CODE, width, height, hints);\n        MatrixToImageWriter.writeToStream(bitMatrix, format, response.getOutputStream());\n    } catch (WriterException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n```\n\n生成二维码，并将UUID放入缓存中\n\n此处需要注意，二维码url必须是外网可以访问地址，此处可以使用[内网穿透工具](https://ngrok.com/)\n\n\n# 验证是否登录\n\n前端发起请求，验证该二维码是否已经被扫登录\n\n```\n@RequestMapping(\"/pool\")\n@ResponseBody\nString pool(String uuid) {\n    System.out.println(\"检测[\" + uuid + \"]是否登录\");\n\n    ScanPool pool = PoolCache.cacheMap.get(uuid);\n\n    if (pool == null) {\n        return \"timeout\";\n    }\n\n    //使用计时器，固定时间后不再等待扫描结果--防止页面访问超时\n    new Thread(new ScanCounter(pool)).start();\n\n    boolean scanFlag = pool.getScanStatus();\n\n    if (scanFlag) {\n        return \"success\";\n    } else {\n        return \"fail\";\n    }\n}\n```\n\n获得状态\n\n```\npublic synchronized boolean getScanStatus() {\n    try {\n        if (!isScan()) { //如果还未扫描，则等待\n            this.wait();\n        }\n        if (isScan()) {\n            return true;\n        }\n    } catch (InterruptedException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    return false;\n}\n\npublic synchronized void notifyPool() {\n    try {\n        this.notifyAll();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n新开线程防止页面访问超时\n\n```\nclass ScanCounter implements Runnable {\n\n    public Long timeout = 27000L;\n\n    //传入的对象\n    private ScanPool scanPool;\n\n    public ScanCounter(ScanPool scanPool) {\n        this.scanPool = scanPool;\n    }\n\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(timeout);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        notifyPool(scanPool);\n    }\n\n    public synchronized void notifyPool(ScanPool scanPool) {\n        scanPool.notifyPool();\n    }\n}\n```\n\n![verify](http://www.wailian.work/images/2018/03/05/code4c40c.png)\n\n# 定时清理uuid\n\n为防止cacheMap不断增加的问题，需要在静态代码块中开启线程定时清理\n\n```\npublic class PoolCache {\n    //缓存超时时间 80秒\n    private static Long timeOutSecond = 80L;\n\n    //每1分钟清理一次缓存\n    private static Long cleanIntervalSecond = 60L;\n\n    public static Map<String, ScanPool> cacheMap = new ConcurrentHashMap<String, ScanPool>();\n\n    static {\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                while (true) {\n                    try {\n                        Thread.sleep(cleanIntervalSecond * 1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    clean();\n                }\n            }\n\n            public void clean() {\n                System.out.println(\"缓存清理...\");\n\n                if (cacheMap.keySet().size() > 0) {\n                    Iterator<String> iterator = cacheMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        String key = iterator.next();\n                        ScanPool pool = cacheMap.get(key);\n                        if (System.currentTimeMillis() - pool.getCreateTime() > timeOutSecond * 1000) {\n                            cacheMap.remove(key);\n                            // 这一行很关键！用于当清理完成，前端请求还在pending时，立即返回结果\n                            pool.notifyPool();\n                        }\n                    }\n                }\n            }\n        }).start();\n    }\n\n}\n```\n\n\n# 扫码\n\n```\n@RequestMapping(\"/login/{uuid}\")\n@ResponseBody\nString login(@PathVariable String uuid) {\n\n    ScanPool pool = PoolCache.cacheMap.get(uuid);\n\n    if (pool == null) {\n        return \"timeout,scan fail\";\n    }\n    \n    // 设置被扫状态，唤起线程\n    pool.scanSuccess();\n\n    return \"扫码完成，登录成功\";\n}\n```\n\n扫码成功，设置扫码状态，唤起线程\n\n```\npublic synchronized void scanSuccess() {\n    try {\n        setScan(true);\n        this.notifyAll();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n![](http://www.wailian.work/images/2018/03/05/ok.png)\n\n手机扫码后\n\n![](http://www.wailian.work/images/2018/03/05/mobile.jpg)\n\n\n对比[完整代码](https://github.com/wangweiye01/scan_login)很容易看实现原理\n","source":"_posts/scan-notify.md","raw":"---\ntitle: 扫描二维码（登录，支付）后立即通知\ndate: 2018-03-05 10:48:42\ntags:\ntop: 1000\n---\n\n![](http://www.wailian.work/images/2018/03/05/1211.jpg)\n\n> 最近在做微信的扫码支付，遇到一个问题：如何在用户扫码支付完成之后，客户端立即得到通知，进行下一步的跳转？\n\n首先想到的策略可能是客户端轮询查询订单状态，根据返回结果进行跳转\n\n这个方式有明显的缺点，轮询时间设置短，频繁发送请求，对服务器以及数据库都会产生压力；轮询时间过长，用户等待时间长，体验很差；\n\n针对这个问题想到了微信网页版的扫码登录（扫码完成后，立即登录），现在研究一下它的原理并实现相同的功能\n\n# 微信扫码登录原理\n\n![pengding](http://www.wailian.work/images/2018/03/05/pending.png)\n\n根据图片中，前端二维码页面发送一个网络请求，但是这个请求并没有立即返回\n\n![408](http://www.wailian.work/images/2018/03/05/408.png)\n\n一段时间没有扫描后，后端返回408，前端重新发起一个相同的网络请求，并继续pending\n\n据此猜测大概实现原理如下：\n\n1. 进入网站-生成一个唯一标识(比如UUID)\n2. 跳转到二维码页面（二维码中的链接包含次UUID）\n3. 二维码页面向服务端发起请求，查询二维码是被扫登录\n4. 服务器收到请求，查询。如果未扫登录，进入等待(wait)，不立即返回\n5. 一旦被扫，立即返回(notify)\n6. 页面收到结果，做后续处理\n\n步骤大概就是如此，但是有个问题，步骤3如果请求超时，如何处理？处理方式是，一段固定时间后，返回408（timeout）\n\n# UUID缓存\n\n```\npublic static Map<String, ScanPool> cacheMap = new ConcurrentHashMap<String, ScanPool>();\n```\n\n一定要使用ConcurrentHashMap否则多线程操作集合会报错ConcurrentModificationException\n\n单线程中出现该异常的原因是，对一个集合遍历的同时，又对该集合进行了增删的操作\n\n多线程中更易出现该异常，当你在一个线程中对一数据集合进行遍历，正赶上另外一个线程对该数据集合进行增删操作时便会出现该异常\n\n缓存还要设置自动清理功能，防止增长过大\n\n# 生成二维码\n\n```\n@RequestMapping(\"/qrcode/{uuid}\")\n@ResponseBody\nString createQRCode(@PathVariable String uuid, HttpServletResponse response) {\n    System.out.println(\"生成二维码\");\n\n    String text = \"http://2b082e46.ngrok.io/login/\" + uuid;\n    int width = 300;\n    int height = 300;\n    String format = \"png\";\n    //将UUID放入缓存\n    ScanPool pool = new ScanPool();\n    PoolCache.cacheMap.put(uuid, pool);\n    try {\n        Map<EncodeHintType, Object> hints = new HashMap<EncodeHintType, Object>();\n        hints.put(EncodeHintType.CHARACTER_SET, \"utf-8\");\n        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); //容错率\n        BitMatrix bitMatrix = new MultiFormatWriter().encode(text, BarcodeFormat.QR_CODE, width, height, hints);\n        MatrixToImageWriter.writeToStream(bitMatrix, format, response.getOutputStream());\n    } catch (WriterException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n```\n\n生成二维码，并将UUID放入缓存中\n\n此处需要注意，二维码url必须是外网可以访问地址，此处可以使用[内网穿透工具](https://ngrok.com/)\n\n\n# 验证是否登录\n\n前端发起请求，验证该二维码是否已经被扫登录\n\n```\n@RequestMapping(\"/pool\")\n@ResponseBody\nString pool(String uuid) {\n    System.out.println(\"检测[\" + uuid + \"]是否登录\");\n\n    ScanPool pool = PoolCache.cacheMap.get(uuid);\n\n    if (pool == null) {\n        return \"timeout\";\n    }\n\n    //使用计时器，固定时间后不再等待扫描结果--防止页面访问超时\n    new Thread(new ScanCounter(pool)).start();\n\n    boolean scanFlag = pool.getScanStatus();\n\n    if (scanFlag) {\n        return \"success\";\n    } else {\n        return \"fail\";\n    }\n}\n```\n\n获得状态\n\n```\npublic synchronized boolean getScanStatus() {\n    try {\n        if (!isScan()) { //如果还未扫描，则等待\n            this.wait();\n        }\n        if (isScan()) {\n            return true;\n        }\n    } catch (InterruptedException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    return false;\n}\n\npublic synchronized void notifyPool() {\n    try {\n        this.notifyAll();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n新开线程防止页面访问超时\n\n```\nclass ScanCounter implements Runnable {\n\n    public Long timeout = 27000L;\n\n    //传入的对象\n    private ScanPool scanPool;\n\n    public ScanCounter(ScanPool scanPool) {\n        this.scanPool = scanPool;\n    }\n\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(timeout);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        notifyPool(scanPool);\n    }\n\n    public synchronized void notifyPool(ScanPool scanPool) {\n        scanPool.notifyPool();\n    }\n}\n```\n\n![verify](http://www.wailian.work/images/2018/03/05/code4c40c.png)\n\n# 定时清理uuid\n\n为防止cacheMap不断增加的问题，需要在静态代码块中开启线程定时清理\n\n```\npublic class PoolCache {\n    //缓存超时时间 80秒\n    private static Long timeOutSecond = 80L;\n\n    //每1分钟清理一次缓存\n    private static Long cleanIntervalSecond = 60L;\n\n    public static Map<String, ScanPool> cacheMap = new ConcurrentHashMap<String, ScanPool>();\n\n    static {\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                while (true) {\n                    try {\n                        Thread.sleep(cleanIntervalSecond * 1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    clean();\n                }\n            }\n\n            public void clean() {\n                System.out.println(\"缓存清理...\");\n\n                if (cacheMap.keySet().size() > 0) {\n                    Iterator<String> iterator = cacheMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        String key = iterator.next();\n                        ScanPool pool = cacheMap.get(key);\n                        if (System.currentTimeMillis() - pool.getCreateTime() > timeOutSecond * 1000) {\n                            cacheMap.remove(key);\n                            // 这一行很关键！用于当清理完成，前端请求还在pending时，立即返回结果\n                            pool.notifyPool();\n                        }\n                    }\n                }\n            }\n        }).start();\n    }\n\n}\n```\n\n\n# 扫码\n\n```\n@RequestMapping(\"/login/{uuid}\")\n@ResponseBody\nString login(@PathVariable String uuid) {\n\n    ScanPool pool = PoolCache.cacheMap.get(uuid);\n\n    if (pool == null) {\n        return \"timeout,scan fail\";\n    }\n    \n    // 设置被扫状态，唤起线程\n    pool.scanSuccess();\n\n    return \"扫码完成，登录成功\";\n}\n```\n\n扫码成功，设置扫码状态，唤起线程\n\n```\npublic synchronized void scanSuccess() {\n    try {\n        setScan(true);\n        this.notifyAll();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n![](http://www.wailian.work/images/2018/03/05/ok.png)\n\n手机扫码后\n\n![](http://www.wailian.work/images/2018/03/05/mobile.jpg)\n\n\n对比[完整代码](https://github.com/wangweiye01/scan_login)很容易看实现原理\n","slug":"scan-notify","published":1,"updated":"2020-10-10T02:12:01.870Z","_id":"ckc5n3jwx000x0j9k8b7g8meb","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"http://www.wailian.work/images/2018/03/05/1211.jpg\" alt=\"\"></p>\n<blockquote>\n<p>最近在做微信的扫码支付，遇到一个问题：如何在用户扫码支付完成之后，客户端立即得到通知，进行下一步的跳转？</p>\n</blockquote>\n<p>首先想到的策略可能是客户端轮询查询订单状态，根据返回结果进行跳转</p>\n<p>这个方式有明显的缺点，轮询时间设置短，频繁发送请求，对服务器以及数据库都会产生压力；轮询时间过长，用户等待时间长，体验很差；</p>\n<p>针对这个问题想到了微信网页版的扫码登录（扫码完成后，立即登录），现在研究一下它的原理并实现相同的功能</p>\n<h1 id=\"微信扫码登录原理\"><a href=\"#微信扫码登录原理\" class=\"headerlink\" title=\"微信扫码登录原理\"></a>微信扫码登录原理</h1><p><img src=\"http://www.wailian.work/images/2018/03/05/pending.png\" alt=\"pengding\"></p>\n<p>根据图片中，前端二维码页面发送一个网络请求，但是这个请求并没有立即返回</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/05/408.png\" alt=\"408\"></p>\n<p>一段时间没有扫描后，后端返回408，前端重新发起一个相同的网络请求，并继续pending</p>\n<p>据此猜测大概实现原理如下：</p>\n<ol>\n<li>进入网站-生成一个唯一标识(比如UUID)</li>\n<li>跳转到二维码页面（二维码中的链接包含次UUID）</li>\n<li>二维码页面向服务端发起请求，查询二维码是被扫登录</li>\n<li>服务器收到请求，查询。如果未扫登录，进入等待(wait)，不立即返回</li>\n<li>一旦被扫，立即返回(notify)</li>\n<li>页面收到结果，做后续处理</li>\n</ol>\n<p>步骤大概就是如此，但是有个问题，步骤3如果请求超时，如何处理？处理方式是，一段固定时间后，返回408（timeout）</p>\n<h1 id=\"UUID缓存\"><a href=\"#UUID缓存\" class=\"headerlink\" title=\"UUID缓存\"></a>UUID缓存</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Map&lt;String, ScanPool&gt; cacheMap = new ConcurrentHashMap&lt;String, ScanPool&gt;();</span><br></pre></td></tr></table></figure>\n<p>一定要使用ConcurrentHashMap否则多线程操作集合会报错ConcurrentModificationException</p>\n<p>单线程中出现该异常的原因是，对一个集合遍历的同时，又对该集合进行了增删的操作</p>\n<p>多线程中更易出现该异常，当你在一个线程中对一数据集合进行遍历，正赶上另外一个线程对该数据集合进行增删操作时便会出现该异常</p>\n<p>缓存还要设置自动清理功能，防止增长过大</p>\n<h1 id=\"生成二维码\"><a href=\"#生成二维码\" class=\"headerlink\" title=\"生成二维码\"></a>生成二维码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;/qrcode/&#123;uuid&#125;&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">String createQRCode(@PathVariable String uuid, HttpServletResponse response) &#123;</span><br><span class=\"line\">    System.out.println(&quot;生成二维码&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    String text = &quot;http://2b082e46.ngrok.io/login/&quot; + uuid;</span><br><span class=\"line\">    int width = 300;</span><br><span class=\"line\">    int height = 300;</span><br><span class=\"line\">    String format = &quot;png&quot;;</span><br><span class=\"line\">    //将UUID放入缓存</span><br><span class=\"line\">    ScanPool pool = new ScanPool();</span><br><span class=\"line\">    PoolCache.cacheMap.put(uuid, pool);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;EncodeHintType, Object&gt;();</span><br><span class=\"line\">        hints.put(EncodeHintType.CHARACTER_SET, &quot;utf-8&quot;);</span><br><span class=\"line\">        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); //容错率</span><br><span class=\"line\">        BitMatrix bitMatrix = new MultiFormatWriter().encode(text, BarcodeFormat.QR_CODE, width, height, hints);</span><br><span class=\"line\">        MatrixToImageWriter.writeToStream(bitMatrix, format, response.getOutputStream());</span><br><span class=\"line\">    &#125; catch (WriterException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; catch (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成二维码，并将UUID放入缓存中</p>\n<p>此处需要注意，二维码url必须是外网可以访问地址，此处可以使用<a href=\"https://ngrok.com/\" target=\"_blank\" rel=\"noopener\">内网穿透工具</a></p>\n<h1 id=\"验证是否登录\"><a href=\"#验证是否登录\" class=\"headerlink\" title=\"验证是否登录\"></a>验证是否登录</h1><p>前端发起请求，验证该二维码是否已经被扫登录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;/pool&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">String pool(String uuid) &#123;</span><br><span class=\"line\">    System.out.println(&quot;检测[&quot; + uuid + &quot;]是否登录&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    ScanPool pool = PoolCache.cacheMap.get(uuid);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (pool == null) &#123;</span><br><span class=\"line\">        return &quot;timeout&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //使用计时器，固定时间后不再等待扫描结果--防止页面访问超时</span><br><span class=\"line\">    new Thread(new ScanCounter(pool)).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean scanFlag = pool.getScanStatus();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (scanFlag) &#123;</span><br><span class=\"line\">        return &quot;success&quot;;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return &quot;fail&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获得状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized boolean getScanStatus() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        if (!isScan()) &#123; //如果还未扫描，则等待</span><br><span class=\"line\">            this.wait();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (isScan()) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">        // TODO Auto-generated catch block</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public synchronized void notifyPool() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        this.notifyAll();</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新开线程防止页面访问超时</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ScanCounter implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Long timeout = 27000L;</span><br><span class=\"line\"></span><br><span class=\"line\">    //传入的对象</span><br><span class=\"line\">    private ScanPool scanPool;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ScanCounter(ScanPool scanPool) &#123;</span><br><span class=\"line\">        this.scanPool = scanPool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(timeout);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notifyPool(scanPool);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void notifyPool(ScanPool scanPool) &#123;</span><br><span class=\"line\">        scanPool.notifyPool();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/03/05/code4c40c.png\" alt=\"verify\"></p>\n<h1 id=\"定时清理uuid\"><a href=\"#定时清理uuid\" class=\"headerlink\" title=\"定时清理uuid\"></a>定时清理uuid</h1><p>为防止cacheMap不断增加的问题，需要在静态代码块中开启线程定时清理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PoolCache &#123;</span><br><span class=\"line\">    //缓存超时时间 80秒</span><br><span class=\"line\">    private static Long timeOutSecond = 80L;</span><br><span class=\"line\"></span><br><span class=\"line\">    //每1分钟清理一次缓存</span><br><span class=\"line\">    private static Long cleanIntervalSecond = 60L;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Map&lt;String, ScanPool&gt; cacheMap = new ConcurrentHashMap&lt;String, ScanPool&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        new Thread(new Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                while (true) &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        Thread.sleep(cleanIntervalSecond * 1000);</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    clean();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            public void clean() &#123;</span><br><span class=\"line\">                System.out.println(&quot;缓存清理...&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">                if (cacheMap.keySet().size() &gt; 0) &#123;</span><br><span class=\"line\">                    Iterator&lt;String&gt; iterator = cacheMap.keySet().iterator();</span><br><span class=\"line\">                    while (iterator.hasNext()) &#123;</span><br><span class=\"line\">                        String key = iterator.next();</span><br><span class=\"line\">                        ScanPool pool = cacheMap.get(key);</span><br><span class=\"line\">                        if (System.currentTimeMillis() - pool.getCreateTime() &gt; timeOutSecond * 1000) &#123;</span><br><span class=\"line\">                            cacheMap.remove(key);</span><br><span class=\"line\">                            // 这一行很关键！用于当清理完成，前端请求还在pending时，立即返回结果</span><br><span class=\"line\">                            pool.notifyPool();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"扫码\"><a href=\"#扫码\" class=\"headerlink\" title=\"扫码\"></a>扫码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;/login/&#123;uuid&#125;&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">String login(@PathVariable String uuid) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ScanPool pool = PoolCache.cacheMap.get(uuid);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (pool == null) &#123;</span><br><span class=\"line\">        return &quot;timeout,scan fail&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 设置被扫状态，唤起线程</span><br><span class=\"line\">    pool.scanSuccess();</span><br><span class=\"line\"></span><br><span class=\"line\">    return &quot;扫码完成，登录成功&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>扫码成功，设置扫码状态，唤起线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized void scanSuccess() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        setScan(true);</span><br><span class=\"line\">        this.notifyAll();</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/03/05/ok.png\" alt=\"\"></p>\n<p>手机扫码后</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/05/mobile.jpg\" alt=\"\"></p>\n<p>对比<a href=\"https://github.com/wangweiye01/scan_login\" target=\"_blank\" rel=\"noopener\">完整代码</a>很容易看实现原理</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/03/05/1211.jpg\" alt=\"\"></p>\n<blockquote>\n<p>最近在做微信的扫码支付，遇到一个问题：如何在用户扫码支付完成之后，客户端立即得到通知，进行下一步的跳转？</p>\n</blockquote>\n<p>首先想到的策略可能是客户端轮询查询订单状态，根据返回结果进行跳转</p>\n<p>这个方式有明显的缺点，轮询时间设置短，频繁发送请求，对服务器以及数据库都会产生压力；轮询时间过长，用户等待时间长，体验很差；</p>\n<p>针对这个问题想到了微信网页版的扫码登录（扫码完成后，立即登录），现在研究一下它的原理并实现相同的功能</p>\n<h1 id=\"微信扫码登录原理\"><a href=\"#微信扫码登录原理\" class=\"headerlink\" title=\"微信扫码登录原理\"></a>微信扫码登录原理</h1><p><img src=\"http://www.wailian.work/images/2018/03/05/pending.png\" alt=\"pengding\"></p>\n<p>根据图片中，前端二维码页面发送一个网络请求，但是这个请求并没有立即返回</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/05/408.png\" alt=\"408\"></p>\n<p>一段时间没有扫描后，后端返回408，前端重新发起一个相同的网络请求，并继续pending</p>\n<p>据此猜测大概实现原理如下：</p>\n<ol>\n<li>进入网站-生成一个唯一标识(比如UUID)</li>\n<li>跳转到二维码页面（二维码中的链接包含次UUID）</li>\n<li>二维码页面向服务端发起请求，查询二维码是被扫登录</li>\n<li>服务器收到请求，查询。如果未扫登录，进入等待(wait)，不立即返回</li>\n<li>一旦被扫，立即返回(notify)</li>\n<li>页面收到结果，做后续处理</li>\n</ol>\n<p>步骤大概就是如此，但是有个问题，步骤3如果请求超时，如何处理？处理方式是，一段固定时间后，返回408（timeout）</p>\n<h1 id=\"UUID缓存\"><a href=\"#UUID缓存\" class=\"headerlink\" title=\"UUID缓存\"></a>UUID缓存</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Map&lt;String, ScanPool&gt; cacheMap = new ConcurrentHashMap&lt;String, ScanPool&gt;();</span><br></pre></td></tr></table></figure>\n<p>一定要使用ConcurrentHashMap否则多线程操作集合会报错ConcurrentModificationException</p>\n<p>单线程中出现该异常的原因是，对一个集合遍历的同时，又对该集合进行了增删的操作</p>\n<p>多线程中更易出现该异常，当你在一个线程中对一数据集合进行遍历，正赶上另外一个线程对该数据集合进行增删操作时便会出现该异常</p>\n<p>缓存还要设置自动清理功能，防止增长过大</p>\n<h1 id=\"生成二维码\"><a href=\"#生成二维码\" class=\"headerlink\" title=\"生成二维码\"></a>生成二维码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;/qrcode/&#123;uuid&#125;&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">String createQRCode(@PathVariable String uuid, HttpServletResponse response) &#123;</span><br><span class=\"line\">    System.out.println(&quot;生成二维码&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    String text = &quot;http://2b082e46.ngrok.io/login/&quot; + uuid;</span><br><span class=\"line\">    int width = 300;</span><br><span class=\"line\">    int height = 300;</span><br><span class=\"line\">    String format = &quot;png&quot;;</span><br><span class=\"line\">    //将UUID放入缓存</span><br><span class=\"line\">    ScanPool pool = new ScanPool();</span><br><span class=\"line\">    PoolCache.cacheMap.put(uuid, pool);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;EncodeHintType, Object&gt;();</span><br><span class=\"line\">        hints.put(EncodeHintType.CHARACTER_SET, &quot;utf-8&quot;);</span><br><span class=\"line\">        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); //容错率</span><br><span class=\"line\">        BitMatrix bitMatrix = new MultiFormatWriter().encode(text, BarcodeFormat.QR_CODE, width, height, hints);</span><br><span class=\"line\">        MatrixToImageWriter.writeToStream(bitMatrix, format, response.getOutputStream());</span><br><span class=\"line\">    &#125; catch (WriterException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; catch (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成二维码，并将UUID放入缓存中</p>\n<p>此处需要注意，二维码url必须是外网可以访问地址，此处可以使用<a href=\"https://ngrok.com/\" target=\"_blank\" rel=\"noopener\">内网穿透工具</a></p>\n<h1 id=\"验证是否登录\"><a href=\"#验证是否登录\" class=\"headerlink\" title=\"验证是否登录\"></a>验证是否登录</h1><p>前端发起请求，验证该二维码是否已经被扫登录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;/pool&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">String pool(String uuid) &#123;</span><br><span class=\"line\">    System.out.println(&quot;检测[&quot; + uuid + &quot;]是否登录&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    ScanPool pool = PoolCache.cacheMap.get(uuid);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (pool == null) &#123;</span><br><span class=\"line\">        return &quot;timeout&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //使用计时器，固定时间后不再等待扫描结果--防止页面访问超时</span><br><span class=\"line\">    new Thread(new ScanCounter(pool)).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean scanFlag = pool.getScanStatus();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (scanFlag) &#123;</span><br><span class=\"line\">        return &quot;success&quot;;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return &quot;fail&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获得状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized boolean getScanStatus() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        if (!isScan()) &#123; //如果还未扫描，则等待</span><br><span class=\"line\">            this.wait();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (isScan()) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">        // TODO Auto-generated catch block</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public synchronized void notifyPool() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        this.notifyAll();</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新开线程防止页面访问超时</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ScanCounter implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Long timeout = 27000L;</span><br><span class=\"line\"></span><br><span class=\"line\">    //传入的对象</span><br><span class=\"line\">    private ScanPool scanPool;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ScanCounter(ScanPool scanPool) &#123;</span><br><span class=\"line\">        this.scanPool = scanPool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(timeout);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notifyPool(scanPool);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void notifyPool(ScanPool scanPool) &#123;</span><br><span class=\"line\">        scanPool.notifyPool();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/03/05/code4c40c.png\" alt=\"verify\"></p>\n<h1 id=\"定时清理uuid\"><a href=\"#定时清理uuid\" class=\"headerlink\" title=\"定时清理uuid\"></a>定时清理uuid</h1><p>为防止cacheMap不断增加的问题，需要在静态代码块中开启线程定时清理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PoolCache &#123;</span><br><span class=\"line\">    //缓存超时时间 80秒</span><br><span class=\"line\">    private static Long timeOutSecond = 80L;</span><br><span class=\"line\"></span><br><span class=\"line\">    //每1分钟清理一次缓存</span><br><span class=\"line\">    private static Long cleanIntervalSecond = 60L;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Map&lt;String, ScanPool&gt; cacheMap = new ConcurrentHashMap&lt;String, ScanPool&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        new Thread(new Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                while (true) &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        Thread.sleep(cleanIntervalSecond * 1000);</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    clean();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            public void clean() &#123;</span><br><span class=\"line\">                System.out.println(&quot;缓存清理...&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">                if (cacheMap.keySet().size() &gt; 0) &#123;</span><br><span class=\"line\">                    Iterator&lt;String&gt; iterator = cacheMap.keySet().iterator();</span><br><span class=\"line\">                    while (iterator.hasNext()) &#123;</span><br><span class=\"line\">                        String key = iterator.next();</span><br><span class=\"line\">                        ScanPool pool = cacheMap.get(key);</span><br><span class=\"line\">                        if (System.currentTimeMillis() - pool.getCreateTime() &gt; timeOutSecond * 1000) &#123;</span><br><span class=\"line\">                            cacheMap.remove(key);</span><br><span class=\"line\">                            // 这一行很关键！用于当清理完成，前端请求还在pending时，立即返回结果</span><br><span class=\"line\">                            pool.notifyPool();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"扫码\"><a href=\"#扫码\" class=\"headerlink\" title=\"扫码\"></a>扫码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;/login/&#123;uuid&#125;&quot;)</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">String login(@PathVariable String uuid) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ScanPool pool = PoolCache.cacheMap.get(uuid);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (pool == null) &#123;</span><br><span class=\"line\">        return &quot;timeout,scan fail&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 设置被扫状态，唤起线程</span><br><span class=\"line\">    pool.scanSuccess();</span><br><span class=\"line\"></span><br><span class=\"line\">    return &quot;扫码完成，登录成功&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>扫码成功，设置扫码状态，唤起线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized void scanSuccess() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        setScan(true);</span><br><span class=\"line\">        this.notifyAll();</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/03/05/ok.png\" alt=\"\"></p>\n<p>手机扫码后</p>\n<p><img src=\"http://www.wailian.work/images/2018/03/05/mobile.jpg\" alt=\"\"></p>\n<p>对比<a href=\"https://github.com/wangweiye01/scan_login\" target=\"_blank\" rel=\"noopener\">完整代码</a>很容易看实现原理</p>\n"},{"title":"mysql自定义sequence","date":"2017-12-04T07:02:51.000Z","_content":"# 什么是sequence\n\n序列，在Oracle数据库中，什么是序列呢？它的用途是什么？序列(SEQUENCE)其实是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。\n\n# mysql没有内置sequence，需要自己实现\n\n## 创建sequence表\n\n```\n    CREATE TABLE sequence (\n            name VARCHAR(50) NOT NULL,\n            current_value INT NOT NULL,\n            increment INT NOT NULL DEFAULT 1,\n            PRIMARY KEY (name)\n            )\n```\n\n## 获取当前序列值\n\n```\nCREATE FUNCTION currval (seq_name VARCHAR(50))\n    RETURNS INTEGER\n    LANGUAGE SQL\n    DETERMINISTIC\n    CONTAINS SQL\n    SQL SECURITY DEFINER\n    COMMENT ''\n    BEGIN\n    DECLARE value INTEGER;\n    SET value = 0;\n    SELECT current_value INTO value\n    FROM sequence\n    WHERE name = seq_name;\n    RETURN value;\n    END\n```\n\n## 获取下一个序列\n\n```\nCREATE FUNCTION nextval (seq_name VARCHAR(50))\n    RETURNS INTEGER\n    LANGUAGE SQL\n    DETERMINISTIC\n    CONTAINS SQL\n    SQL SECURITY DEFINER\n    COMMENT ''\n    BEGIN\n    UPDATE sequence\n    SET current_value = current_value + increment\n    WHERE name = seq_name;\n    RETURN currval(seq_name);\n    END\n```\n\n## 重置序列值\n\n```\nCREATE FUNCTION setval (seq_name VARCHAR(50), value INTEGER)\n    RETURNS INTEGER\n    LANGUAGE SQL\n    DETERMINISTIC\n    CONTAINS SQL\n    SQL SECURITY DEFINER\n    COMMENT ''\n    BEGIN\n    UPDATE sequence\n    SET current_value = value\n    WHERE name = seq_name;\n    RETURN currval(seq_name);\n    END\n```\n\n## 应用\n\n```\n    // 在序列表中新建一条序列（参数依次为：序列名称、序列开始值、序列递增步长）\n    INSERT INTO sequence VALUES ('TestSeq', 0, 1);\n    // 设置序列开始值（参数依次为：序列名称、序列开始值）\n    SELECT SETVAL('TestSeq', 10);\n    SELECT CURRVAL('TestSeq');\n    // 获得下一个序列值\n    SELECT NEXTVAL('TestSeq');\n```\n\n","source":"_posts/sequence.md","raw":"---\ntitle: mysql自定义sequence\ndate: 2017-12-04 15:02:51\ntags:\n---\n# 什么是sequence\n\n序列，在Oracle数据库中，什么是序列呢？它的用途是什么？序列(SEQUENCE)其实是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。\n\n# mysql没有内置sequence，需要自己实现\n\n## 创建sequence表\n\n```\n    CREATE TABLE sequence (\n            name VARCHAR(50) NOT NULL,\n            current_value INT NOT NULL,\n            increment INT NOT NULL DEFAULT 1,\n            PRIMARY KEY (name)\n            )\n```\n\n## 获取当前序列值\n\n```\nCREATE FUNCTION currval (seq_name VARCHAR(50))\n    RETURNS INTEGER\n    LANGUAGE SQL\n    DETERMINISTIC\n    CONTAINS SQL\n    SQL SECURITY DEFINER\n    COMMENT ''\n    BEGIN\n    DECLARE value INTEGER;\n    SET value = 0;\n    SELECT current_value INTO value\n    FROM sequence\n    WHERE name = seq_name;\n    RETURN value;\n    END\n```\n\n## 获取下一个序列\n\n```\nCREATE FUNCTION nextval (seq_name VARCHAR(50))\n    RETURNS INTEGER\n    LANGUAGE SQL\n    DETERMINISTIC\n    CONTAINS SQL\n    SQL SECURITY DEFINER\n    COMMENT ''\n    BEGIN\n    UPDATE sequence\n    SET current_value = current_value + increment\n    WHERE name = seq_name;\n    RETURN currval(seq_name);\n    END\n```\n\n## 重置序列值\n\n```\nCREATE FUNCTION setval (seq_name VARCHAR(50), value INTEGER)\n    RETURNS INTEGER\n    LANGUAGE SQL\n    DETERMINISTIC\n    CONTAINS SQL\n    SQL SECURITY DEFINER\n    COMMENT ''\n    BEGIN\n    UPDATE sequence\n    SET current_value = value\n    WHERE name = seq_name;\n    RETURN currval(seq_name);\n    END\n```\n\n## 应用\n\n```\n    // 在序列表中新建一条序列（参数依次为：序列名称、序列开始值、序列递增步长）\n    INSERT INTO sequence VALUES ('TestSeq', 0, 1);\n    // 设置序列开始值（参数依次为：序列名称、序列开始值）\n    SELECT SETVAL('TestSeq', 10);\n    SELECT CURRVAL('TestSeq');\n    // 获得下一个序列值\n    SELECT NEXTVAL('TestSeq');\n```\n\n","slug":"sequence","published":1,"updated":"2019-12-24T02:00:57.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jwy000y0j9koz1d394g","content":"<h1 id=\"什么是sequence\"><a href=\"#什么是sequence\" class=\"headerlink\" title=\"什么是sequence\"></a>什么是sequence</h1><p>序列，在Oracle数据库中，什么是序列呢？它的用途是什么？序列(SEQUENCE)其实是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。</p>\n<h1 id=\"mysql没有内置sequence，需要自己实现\"><a href=\"#mysql没有内置sequence，需要自己实现\" class=\"headerlink\" title=\"mysql没有内置sequence，需要自己实现\"></a>mysql没有内置sequence，需要自己实现</h1><h2 id=\"创建sequence表\"><a href=\"#创建sequence表\" class=\"headerlink\" title=\"创建sequence表\"></a>创建sequence表</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE sequence (</span><br><span class=\"line\">        name VARCHAR(50) NOT NULL,</span><br><span class=\"line\">        current_value INT NOT NULL,</span><br><span class=\"line\">        increment INT NOT NULL DEFAULT 1,</span><br><span class=\"line\">        PRIMARY KEY (name)</span><br><span class=\"line\">        )</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取当前序列值\"><a href=\"#获取当前序列值\" class=\"headerlink\" title=\"获取当前序列值\"></a>获取当前序列值</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE FUNCTION currval (seq_name VARCHAR(50))</span><br><span class=\"line\">    RETURNS INTEGER</span><br><span class=\"line\">    LANGUAGE SQL</span><br><span class=\"line\">    DETERMINISTIC</span><br><span class=\"line\">    CONTAINS SQL</span><br><span class=\"line\">    SQL SECURITY DEFINER</span><br><span class=\"line\">    COMMENT &apos;&apos;</span><br><span class=\"line\">    BEGIN</span><br><span class=\"line\">    DECLARE value INTEGER;</span><br><span class=\"line\">    SET value = 0;</span><br><span class=\"line\">    SELECT current_value INTO value</span><br><span class=\"line\">    FROM sequence</span><br><span class=\"line\">    WHERE name = seq_name;</span><br><span class=\"line\">    RETURN value;</span><br><span class=\"line\">    END</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取下一个序列\"><a href=\"#获取下一个序列\" class=\"headerlink\" title=\"获取下一个序列\"></a>获取下一个序列</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE FUNCTION nextval (seq_name VARCHAR(50))</span><br><span class=\"line\">    RETURNS INTEGER</span><br><span class=\"line\">    LANGUAGE SQL</span><br><span class=\"line\">    DETERMINISTIC</span><br><span class=\"line\">    CONTAINS SQL</span><br><span class=\"line\">    SQL SECURITY DEFINER</span><br><span class=\"line\">    COMMENT &apos;&apos;</span><br><span class=\"line\">    BEGIN</span><br><span class=\"line\">    UPDATE sequence</span><br><span class=\"line\">    SET current_value = current_value + increment</span><br><span class=\"line\">    WHERE name = seq_name;</span><br><span class=\"line\">    RETURN currval(seq_name);</span><br><span class=\"line\">    END</span><br></pre></td></tr></table></figure>\n<h2 id=\"重置序列值\"><a href=\"#重置序列值\" class=\"headerlink\" title=\"重置序列值\"></a>重置序列值</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE FUNCTION setval (seq_name VARCHAR(50), value INTEGER)</span><br><span class=\"line\">    RETURNS INTEGER</span><br><span class=\"line\">    LANGUAGE SQL</span><br><span class=\"line\">    DETERMINISTIC</span><br><span class=\"line\">    CONTAINS SQL</span><br><span class=\"line\">    SQL SECURITY DEFINER</span><br><span class=\"line\">    COMMENT &apos;&apos;</span><br><span class=\"line\">    BEGIN</span><br><span class=\"line\">    UPDATE sequence</span><br><span class=\"line\">    SET current_value = value</span><br><span class=\"line\">    WHERE name = seq_name;</span><br><span class=\"line\">    RETURN currval(seq_name);</span><br><span class=\"line\">    END</span><br></pre></td></tr></table></figure>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在序列表中新建一条序列（参数依次为：序列名称、序列开始值、序列递增步长）</span><br><span class=\"line\">INSERT INTO sequence VALUES (&apos;TestSeq&apos;, 0, 1);</span><br><span class=\"line\">// 设置序列开始值（参数依次为：序列名称、序列开始值）</span><br><span class=\"line\">SELECT SETVAL(&apos;TestSeq&apos;, 10);</span><br><span class=\"line\">SELECT CURRVAL(&apos;TestSeq&apos;);</span><br><span class=\"line\">// 获得下一个序列值</span><br><span class=\"line\">SELECT NEXTVAL(&apos;TestSeq&apos;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是sequence\"><a href=\"#什么是sequence\" class=\"headerlink\" title=\"什么是sequence\"></a>什么是sequence</h1><p>序列，在Oracle数据库中，什么是序列呢？它的用途是什么？序列(SEQUENCE)其实是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。</p>\n<h1 id=\"mysql没有内置sequence，需要自己实现\"><a href=\"#mysql没有内置sequence，需要自己实现\" class=\"headerlink\" title=\"mysql没有内置sequence，需要自己实现\"></a>mysql没有内置sequence，需要自己实现</h1><h2 id=\"创建sequence表\"><a href=\"#创建sequence表\" class=\"headerlink\" title=\"创建sequence表\"></a>创建sequence表</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE sequence (</span><br><span class=\"line\">        name VARCHAR(50) NOT NULL,</span><br><span class=\"line\">        current_value INT NOT NULL,</span><br><span class=\"line\">        increment INT NOT NULL DEFAULT 1,</span><br><span class=\"line\">        PRIMARY KEY (name)</span><br><span class=\"line\">        )</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取当前序列值\"><a href=\"#获取当前序列值\" class=\"headerlink\" title=\"获取当前序列值\"></a>获取当前序列值</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE FUNCTION currval (seq_name VARCHAR(50))</span><br><span class=\"line\">    RETURNS INTEGER</span><br><span class=\"line\">    LANGUAGE SQL</span><br><span class=\"line\">    DETERMINISTIC</span><br><span class=\"line\">    CONTAINS SQL</span><br><span class=\"line\">    SQL SECURITY DEFINER</span><br><span class=\"line\">    COMMENT &apos;&apos;</span><br><span class=\"line\">    BEGIN</span><br><span class=\"line\">    DECLARE value INTEGER;</span><br><span class=\"line\">    SET value = 0;</span><br><span class=\"line\">    SELECT current_value INTO value</span><br><span class=\"line\">    FROM sequence</span><br><span class=\"line\">    WHERE name = seq_name;</span><br><span class=\"line\">    RETURN value;</span><br><span class=\"line\">    END</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取下一个序列\"><a href=\"#获取下一个序列\" class=\"headerlink\" title=\"获取下一个序列\"></a>获取下一个序列</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE FUNCTION nextval (seq_name VARCHAR(50))</span><br><span class=\"line\">    RETURNS INTEGER</span><br><span class=\"line\">    LANGUAGE SQL</span><br><span class=\"line\">    DETERMINISTIC</span><br><span class=\"line\">    CONTAINS SQL</span><br><span class=\"line\">    SQL SECURITY DEFINER</span><br><span class=\"line\">    COMMENT &apos;&apos;</span><br><span class=\"line\">    BEGIN</span><br><span class=\"line\">    UPDATE sequence</span><br><span class=\"line\">    SET current_value = current_value + increment</span><br><span class=\"line\">    WHERE name = seq_name;</span><br><span class=\"line\">    RETURN currval(seq_name);</span><br><span class=\"line\">    END</span><br></pre></td></tr></table></figure>\n<h2 id=\"重置序列值\"><a href=\"#重置序列值\" class=\"headerlink\" title=\"重置序列值\"></a>重置序列值</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE FUNCTION setval (seq_name VARCHAR(50), value INTEGER)</span><br><span class=\"line\">    RETURNS INTEGER</span><br><span class=\"line\">    LANGUAGE SQL</span><br><span class=\"line\">    DETERMINISTIC</span><br><span class=\"line\">    CONTAINS SQL</span><br><span class=\"line\">    SQL SECURITY DEFINER</span><br><span class=\"line\">    COMMENT &apos;&apos;</span><br><span class=\"line\">    BEGIN</span><br><span class=\"line\">    UPDATE sequence</span><br><span class=\"line\">    SET current_value = value</span><br><span class=\"line\">    WHERE name = seq_name;</span><br><span class=\"line\">    RETURN currval(seq_name);</span><br><span class=\"line\">    END</span><br></pre></td></tr></table></figure>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在序列表中新建一条序列（参数依次为：序列名称、序列开始值、序列递增步长）</span><br><span class=\"line\">INSERT INTO sequence VALUES (&apos;TestSeq&apos;, 0, 1);</span><br><span class=\"line\">// 设置序列开始值（参数依次为：序列名称、序列开始值）</span><br><span class=\"line\">SELECT SETVAL(&apos;TestSeq&apos;, 10);</span><br><span class=\"line\">SELECT CURRVAL(&apos;TestSeq&apos;);</span><br><span class=\"line\">// 获得下一个序列值</span><br><span class=\"line\">SELECT NEXTVAL(&apos;TestSeq&apos;);</span><br></pre></td></tr></table></figure>\n"},{"title":"vps搭建shadowsocks","date":"2017-11-28T02:18:55.000Z","_content":"![pic](http://s1.wailian.download/2018/01/18/3bf44e943f8d77713982edd8c8e0fa478c6bbf622633d-zCwRVd_fw658.jpg)\n# 购买vultr服务\n\n注册vultr,购买服务(建议地址选Tokyo,操作系统选择CentOS,配置选择最小配置),然后部署服务器\n\n# 安装shadowsocks\n\n> 本文安装是是使用CentOS7系统\n\n## 连接服务器\n\n## 依次执行以下命令\n\n``` bash\nwget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n\n## 等几秒钟,根据提示输入shadowsocks密码及端口号\n\n![安装ss](http://img.blog.csdn.net/20171110091659947?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 成功后出现以下页面,妥善保存信息\n\n![安装成功后](http://img.blog.csdn.net/20171110091341666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n# 配置维护Shadowsocks\n\n## 配置多用户多端口\n\n修改/etc/shadowsock.json文件\n\n```\n{\n    \"server\":\"my_server_ip\"，\n        \"local_address\": \"127.0.0.1\",\n        \"local_port\":1080,\n        \"port_password\": {\n            \"8381\": \"foobar1\",\n            \"8382\": \"foobar2\",\n            \"8383\": \"foobar3\",\n            \"8384\": \"foobar4\"\n        },\n        \"timeout\":300,\n        \"method\":\"aes-256-cfb\",\n        \"fast_open\": false\n}\n```\n\n其中，port_password就是将之前的服务器端口和对应的密码结合起来。然后通过使用以下命令，就可以启动多端口多用户了。\n\n```\n启动：systemctl start shadowsocks.service\n停止：systemctl stop shadowsocks.service\n重启：systemctl restart shadowsocks.service\n状态：systemctl status shadowsocks.service\n```\n\ncentos默认的防火墙机制，会阻隔掉我们的多端口配置。所以，解决方法就是，将这个端口打开tcp和udp通信。这里需要说明的事，在centos版本的更新迭代过程中，centos7和centos6之间的差异性较大。在centos7，采用的是最新的防火墙filewall而不是传统的iptables。\n具体操作为，先进入firewalled的配置端口目录，路径为etc/firewalled/zones打开public.xml文件进行端口的编辑.例如\n\n```\n<port protocol=\"tcp\" port=\"449\"/>   \n<portprotocol=\"udp\" port=\"443\"/>\n```\n\n即添加了tcp和udp的权限.然后systemctl restart firewalld.service 重启防火墙，端口就添加到防火墙的白名单中啦。\n\n# 下载(Shadowsocks客户端)\n\n## mac和windows\n\n访问\n\n```\nhttps://github.com/shadowsocks\n```\n\n![client](http://img.blog.csdn.net/20171110093052673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n*Shadowsocks-windows为windows客户端*\n*ShadowsocksX-NG为mac客户端*\n\n## iphone\n商店搜索super wingy\n![super_wingy](http://img.blog.csdn.net/20171110092642061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n# KCPTun加速\n\n搭建好了Shadowsocks相当于搭建成功了梯子，但是梯子太长，即时梯子带宽足够宽，线路质量也是不忍直视，此时就需要KCPTun了。\n\nKCPTun是一个使用可信UDP来加速TCP传输速度的网络软件。\n\nKCP 是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。\n\n## KCPTun服务安装\n\n```\n// 下载脚本\nwget https://raw.githubusercontent.com/kuoruan/kcptun_installer/master/kcptun.sh\n// 赋予权限\nchmod +x ./kcptun.sh\n// 执行脚本\n./kcptun.sh\n```\n\n# vultr购买推荐地址\n\n```\nhttps://www.vultr.com/?ref=7259520\n```\n","source":"_posts/shadowsocks.md","raw":"---\ntitle: vps搭建shadowsocks\ndate: 2017-11-28 10:18:55\ntags:\n---\n![pic](http://s1.wailian.download/2018/01/18/3bf44e943f8d77713982edd8c8e0fa478c6bbf622633d-zCwRVd_fw658.jpg)\n# 购买vultr服务\n\n注册vultr,购买服务(建议地址选Tokyo,操作系统选择CentOS,配置选择最小配置),然后部署服务器\n\n# 安装shadowsocks\n\n> 本文安装是是使用CentOS7系统\n\n## 连接服务器\n\n## 依次执行以下命令\n\n``` bash\nwget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n\n## 等几秒钟,根据提示输入shadowsocks密码及端口号\n\n![安装ss](http://img.blog.csdn.net/20171110091659947?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 成功后出现以下页面,妥善保存信息\n\n![安装成功后](http://img.blog.csdn.net/20171110091341666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n# 配置维护Shadowsocks\n\n## 配置多用户多端口\n\n修改/etc/shadowsock.json文件\n\n```\n{\n    \"server\":\"my_server_ip\"，\n        \"local_address\": \"127.0.0.1\",\n        \"local_port\":1080,\n        \"port_password\": {\n            \"8381\": \"foobar1\",\n            \"8382\": \"foobar2\",\n            \"8383\": \"foobar3\",\n            \"8384\": \"foobar4\"\n        },\n        \"timeout\":300,\n        \"method\":\"aes-256-cfb\",\n        \"fast_open\": false\n}\n```\n\n其中，port_password就是将之前的服务器端口和对应的密码结合起来。然后通过使用以下命令，就可以启动多端口多用户了。\n\n```\n启动：systemctl start shadowsocks.service\n停止：systemctl stop shadowsocks.service\n重启：systemctl restart shadowsocks.service\n状态：systemctl status shadowsocks.service\n```\n\ncentos默认的防火墙机制，会阻隔掉我们的多端口配置。所以，解决方法就是，将这个端口打开tcp和udp通信。这里需要说明的事，在centos版本的更新迭代过程中，centos7和centos6之间的差异性较大。在centos7，采用的是最新的防火墙filewall而不是传统的iptables。\n具体操作为，先进入firewalled的配置端口目录，路径为etc/firewalled/zones打开public.xml文件进行端口的编辑.例如\n\n```\n<port protocol=\"tcp\" port=\"449\"/>   \n<portprotocol=\"udp\" port=\"443\"/>\n```\n\n即添加了tcp和udp的权限.然后systemctl restart firewalld.service 重启防火墙，端口就添加到防火墙的白名单中啦。\n\n# 下载(Shadowsocks客户端)\n\n## mac和windows\n\n访问\n\n```\nhttps://github.com/shadowsocks\n```\n\n![client](http://img.blog.csdn.net/20171110093052673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n*Shadowsocks-windows为windows客户端*\n*ShadowsocksX-NG为mac客户端*\n\n## iphone\n商店搜索super wingy\n![super_wingy](http://img.blog.csdn.net/20171110092642061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n# KCPTun加速\n\n搭建好了Shadowsocks相当于搭建成功了梯子，但是梯子太长，即时梯子带宽足够宽，线路质量也是不忍直视，此时就需要KCPTun了。\n\nKCPTun是一个使用可信UDP来加速TCP传输速度的网络软件。\n\nKCP 是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。\n\n## KCPTun服务安装\n\n```\n// 下载脚本\nwget https://raw.githubusercontent.com/kuoruan/kcptun_installer/master/kcptun.sh\n// 赋予权限\nchmod +x ./kcptun.sh\n// 执行脚本\n./kcptun.sh\n```\n\n# vultr购买推荐地址\n\n```\nhttps://www.vultr.com/?ref=7259520\n```\n","slug":"shadowsocks","published":1,"updated":"2019-12-24T02:00:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jx000100j9kabeeklb6","content":"<p><img src=\"http://s1.wailian.download/2018/01/18/3bf44e943f8d77713982edd8c8e0fa478c6bbf622633d-zCwRVd_fw658.jpg\" alt=\"pic\"></p>\n<h1 id=\"购买vultr服务\"><a href=\"#购买vultr服务\" class=\"headerlink\" title=\"购买vultr服务\"></a>购买vultr服务</h1><p>注册vultr,购买服务(建议地址选Tokyo,操作系统选择CentOS,配置选择最小配置),然后部署服务器</p>\n<h1 id=\"安装shadowsocks\"><a href=\"#安装shadowsocks\" class=\"headerlink\" title=\"安装shadowsocks\"></a>安装shadowsocks</h1><blockquote>\n<p>本文安装是是使用CentOS7系统</p>\n</blockquote>\n<h2 id=\"连接服务器\"><a href=\"#连接服务器\" class=\"headerlink\" title=\"连接服务器\"></a>连接服务器</h2><h2 id=\"依次执行以下命令\"><a href=\"#依次执行以下命令\" class=\"headerlink\" title=\"依次执行以下命令\"></a>依次执行以下命令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class=\"line\">chmod +x shadowsocks.sh</span><br><span class=\"line\">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure>\n<h2 id=\"等几秒钟-根据提示输入shadowsocks密码及端口号\"><a href=\"#等几秒钟-根据提示输入shadowsocks密码及端口号\" class=\"headerlink\" title=\"等几秒钟,根据提示输入shadowsocks密码及端口号\"></a>等几秒钟,根据提示输入shadowsocks密码及端口号</h2><p><img src=\"http://img.blog.csdn.net/20171110091659947?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"安装ss\"></p>\n<h2 id=\"成功后出现以下页面-妥善保存信息\"><a href=\"#成功后出现以下页面-妥善保存信息\" class=\"headerlink\" title=\"成功后出现以下页面,妥善保存信息\"></a>成功后出现以下页面,妥善保存信息</h2><p><img src=\"http://img.blog.csdn.net/20171110091341666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"安装成功后\"></p>\n<h1 id=\"配置维护Shadowsocks\"><a href=\"#配置维护Shadowsocks\" class=\"headerlink\" title=\"配置维护Shadowsocks\"></a>配置维护Shadowsocks</h1><h2 id=\"配置多用户多端口\"><a href=\"#配置多用户多端口\" class=\"headerlink\" title=\"配置多用户多端口\"></a>配置多用户多端口</h2><p>修改/etc/shadowsock.json文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;server&quot;:&quot;my_server_ip&quot;，</span><br><span class=\"line\">        &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">        &quot;local_port&quot;:1080,</span><br><span class=\"line\">        &quot;port_password&quot;: &#123;</span><br><span class=\"line\">            &quot;8381&quot;: &quot;foobar1&quot;,</span><br><span class=\"line\">            &quot;8382&quot;: &quot;foobar2&quot;,</span><br><span class=\"line\">            &quot;8383&quot;: &quot;foobar3&quot;,</span><br><span class=\"line\">            &quot;8384&quot;: &quot;foobar4&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;timeout&quot;:300,</span><br><span class=\"line\">        &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class=\"line\">        &quot;fast_open&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，port_password就是将之前的服务器端口和对应的密码结合起来。然后通过使用以下命令，就可以启动多端口多用户了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">启动：systemctl start shadowsocks.service</span><br><span class=\"line\">停止：systemctl stop shadowsocks.service</span><br><span class=\"line\">重启：systemctl restart shadowsocks.service</span><br><span class=\"line\">状态：systemctl status shadowsocks.service</span><br></pre></td></tr></table></figure>\n<p>centos默认的防火墙机制，会阻隔掉我们的多端口配置。所以，解决方法就是，将这个端口打开tcp和udp通信。这里需要说明的事，在centos版本的更新迭代过程中，centos7和centos6之间的差异性较大。在centos7，采用的是最新的防火墙filewall而不是传统的iptables。<br>具体操作为，先进入firewalled的配置端口目录，路径为etc/firewalled/zones打开public.xml文件进行端口的编辑.例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;port protocol=&quot;tcp&quot; port=&quot;449&quot;/&gt;   </span><br><span class=\"line\">&lt;portprotocol=&quot;udp&quot; port=&quot;443&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>即添加了tcp和udp的权限.然后systemctl restart firewalld.service 重启防火墙，端口就添加到防火墙的白名单中啦。</p>\n<h1 id=\"下载-Shadowsocks客户端\"><a href=\"#下载-Shadowsocks客户端\" class=\"headerlink\" title=\"下载(Shadowsocks客户端)\"></a>下载(Shadowsocks客户端)</h1><h2 id=\"mac和windows\"><a href=\"#mac和windows\" class=\"headerlink\" title=\"mac和windows\"></a>mac和windows</h2><p>访问</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://github.com/shadowsocks</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.blog.csdn.net/20171110093052673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"client\"><br><em>Shadowsocks-windows为windows客户端</em><br><em>ShadowsocksX-NG为mac客户端</em></p>\n<h2 id=\"iphone\"><a href=\"#iphone\" class=\"headerlink\" title=\"iphone\"></a>iphone</h2><p>商店搜索super wingy<br><img src=\"http://img.blog.csdn.net/20171110092642061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"super_wingy\"></p>\n<h1 id=\"KCPTun加速\"><a href=\"#KCPTun加速\" class=\"headerlink\" title=\"KCPTun加速\"></a>KCPTun加速</h1><p>搭建好了Shadowsocks相当于搭建成功了梯子，但是梯子太长，即时梯子带宽足够宽，线路质量也是不忍直视，此时就需要KCPTun了。</p>\n<p>KCPTun是一个使用可信UDP来加速TCP传输速度的网络软件。</p>\n<p>KCP 是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。</p>\n<h2 id=\"KCPTun服务安装\"><a href=\"#KCPTun服务安装\" class=\"headerlink\" title=\"KCPTun服务安装\"></a>KCPTun服务安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 下载脚本</span><br><span class=\"line\">wget https://raw.githubusercontent.com/kuoruan/kcptun_installer/master/kcptun.sh</span><br><span class=\"line\">// 赋予权限</span><br><span class=\"line\">chmod +x ./kcptun.sh</span><br><span class=\"line\">// 执行脚本</span><br><span class=\"line\">./kcptun.sh</span><br></pre></td></tr></table></figure>\n<h1 id=\"vultr购买推荐地址\"><a href=\"#vultr购买推荐地址\" class=\"headerlink\" title=\"vultr购买推荐地址\"></a>vultr购买推荐地址</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.vultr.com/?ref=7259520</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://s1.wailian.download/2018/01/18/3bf44e943f8d77713982edd8c8e0fa478c6bbf622633d-zCwRVd_fw658.jpg\" alt=\"pic\"></p>\n<h1 id=\"购买vultr服务\"><a href=\"#购买vultr服务\" class=\"headerlink\" title=\"购买vultr服务\"></a>购买vultr服务</h1><p>注册vultr,购买服务(建议地址选Tokyo,操作系统选择CentOS,配置选择最小配置),然后部署服务器</p>\n<h1 id=\"安装shadowsocks\"><a href=\"#安装shadowsocks\" class=\"headerlink\" title=\"安装shadowsocks\"></a>安装shadowsocks</h1><blockquote>\n<p>本文安装是是使用CentOS7系统</p>\n</blockquote>\n<h2 id=\"连接服务器\"><a href=\"#连接服务器\" class=\"headerlink\" title=\"连接服务器\"></a>连接服务器</h2><h2 id=\"依次执行以下命令\"><a href=\"#依次执行以下命令\" class=\"headerlink\" title=\"依次执行以下命令\"></a>依次执行以下命令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class=\"line\">chmod +x shadowsocks.sh</span><br><span class=\"line\">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure>\n<h2 id=\"等几秒钟-根据提示输入shadowsocks密码及端口号\"><a href=\"#等几秒钟-根据提示输入shadowsocks密码及端口号\" class=\"headerlink\" title=\"等几秒钟,根据提示输入shadowsocks密码及端口号\"></a>等几秒钟,根据提示输入shadowsocks密码及端口号</h2><p><img src=\"http://img.blog.csdn.net/20171110091659947?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"安装ss\"></p>\n<h2 id=\"成功后出现以下页面-妥善保存信息\"><a href=\"#成功后出现以下页面-妥善保存信息\" class=\"headerlink\" title=\"成功后出现以下页面,妥善保存信息\"></a>成功后出现以下页面,妥善保存信息</h2><p><img src=\"http://img.blog.csdn.net/20171110091341666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"安装成功后\"></p>\n<h1 id=\"配置维护Shadowsocks\"><a href=\"#配置维护Shadowsocks\" class=\"headerlink\" title=\"配置维护Shadowsocks\"></a>配置维护Shadowsocks</h1><h2 id=\"配置多用户多端口\"><a href=\"#配置多用户多端口\" class=\"headerlink\" title=\"配置多用户多端口\"></a>配置多用户多端口</h2><p>修改/etc/shadowsock.json文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;server&quot;:&quot;my_server_ip&quot;，</span><br><span class=\"line\">        &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">        &quot;local_port&quot;:1080,</span><br><span class=\"line\">        &quot;port_password&quot;: &#123;</span><br><span class=\"line\">            &quot;8381&quot;: &quot;foobar1&quot;,</span><br><span class=\"line\">            &quot;8382&quot;: &quot;foobar2&quot;,</span><br><span class=\"line\">            &quot;8383&quot;: &quot;foobar3&quot;,</span><br><span class=\"line\">            &quot;8384&quot;: &quot;foobar4&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;timeout&quot;:300,</span><br><span class=\"line\">        &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class=\"line\">        &quot;fast_open&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，port_password就是将之前的服务器端口和对应的密码结合起来。然后通过使用以下命令，就可以启动多端口多用户了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">启动：systemctl start shadowsocks.service</span><br><span class=\"line\">停止：systemctl stop shadowsocks.service</span><br><span class=\"line\">重启：systemctl restart shadowsocks.service</span><br><span class=\"line\">状态：systemctl status shadowsocks.service</span><br></pre></td></tr></table></figure>\n<p>centos默认的防火墙机制，会阻隔掉我们的多端口配置。所以，解决方法就是，将这个端口打开tcp和udp通信。这里需要说明的事，在centos版本的更新迭代过程中，centos7和centos6之间的差异性较大。在centos7，采用的是最新的防火墙filewall而不是传统的iptables。<br>具体操作为，先进入firewalled的配置端口目录，路径为etc/firewalled/zones打开public.xml文件进行端口的编辑.例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;port protocol=&quot;tcp&quot; port=&quot;449&quot;/&gt;   </span><br><span class=\"line\">&lt;portprotocol=&quot;udp&quot; port=&quot;443&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>即添加了tcp和udp的权限.然后systemctl restart firewalld.service 重启防火墙，端口就添加到防火墙的白名单中啦。</p>\n<h1 id=\"下载-Shadowsocks客户端\"><a href=\"#下载-Shadowsocks客户端\" class=\"headerlink\" title=\"下载(Shadowsocks客户端)\"></a>下载(Shadowsocks客户端)</h1><h2 id=\"mac和windows\"><a href=\"#mac和windows\" class=\"headerlink\" title=\"mac和windows\"></a>mac和windows</h2><p>访问</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://github.com/shadowsocks</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.blog.csdn.net/20171110093052673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"client\"><br><em>Shadowsocks-windows为windows客户端</em><br><em>ShadowsocksX-NG为mac客户端</em></p>\n<h2 id=\"iphone\"><a href=\"#iphone\" class=\"headerlink\" title=\"iphone\"></a>iphone</h2><p>商店搜索super wingy<br><img src=\"http://img.blog.csdn.net/20171110092642061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTY3MTI2NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"super_wingy\"></p>\n<h1 id=\"KCPTun加速\"><a href=\"#KCPTun加速\" class=\"headerlink\" title=\"KCPTun加速\"></a>KCPTun加速</h1><p>搭建好了Shadowsocks相当于搭建成功了梯子，但是梯子太长，即时梯子带宽足够宽，线路质量也是不忍直视，此时就需要KCPTun了。</p>\n<p>KCPTun是一个使用可信UDP来加速TCP传输速度的网络软件。</p>\n<p>KCP 是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。</p>\n<h2 id=\"KCPTun服务安装\"><a href=\"#KCPTun服务安装\" class=\"headerlink\" title=\"KCPTun服务安装\"></a>KCPTun服务安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 下载脚本</span><br><span class=\"line\">wget https://raw.githubusercontent.com/kuoruan/kcptun_installer/master/kcptun.sh</span><br><span class=\"line\">// 赋予权限</span><br><span class=\"line\">chmod +x ./kcptun.sh</span><br><span class=\"line\">// 执行脚本</span><br><span class=\"line\">./kcptun.sh</span><br></pre></td></tr></table></figure>\n<h1 id=\"vultr购买推荐地址\"><a href=\"#vultr购买推荐地址\" class=\"headerlink\" title=\"vultr购买推荐地址\"></a>vultr购买推荐地址</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.vultr.com/?ref=7259520</span><br></pre></td></tr></table></figure>\n"},{"title":"设计模式-单例模式","date":"2018-06-11T01:36:33.000Z","_content":"\n# 定义\n\n是一种常用的软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类。一个类只有一个实例，即一个类只有一个对象的实例\n\n# 形式\n\n单例模式可以分为懒汉式和饿汉式\n\n懒汉式：在类加载时不初始化\n\n饿汉式：在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快\n\n# 懒汉式\n\n下面试最标准也是最原始的单例模式\n\n```\npublic class Singleton {\n    private static Singleton singleton;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            singleton = new Singleton();\n        }\n\n        return singleton;\n    }\n}\n```\n\n不考虑并发情况下，以上方法主要靠以下来限制实例的单一性\n\n1. 静态实例，带有static关键字的属性在每一个类中都是唯一的\n\n2. 私有化构造函数，限制了随意创造实例的可能性\n\n3. 公有获取实例的静态方法。为什么是静态？这个方法是供消费者获取对象实例的，如果是非静态的话，需要使用对象来调用，这就形成了矛盾\n\n\n## 线程安全的单例\n\n上面的方法在高并发情况下，肯定会出现有多个实例的情况-当一个线程判断为空，但是又没创建实例时，另一线程仍判断为空，这时就会出现单例模式非单例的情况\n\n解决以上问题首先可能想到的方法如下\n\n```\npublic class BadSynchronizedSingleton {\n\n    //一个静态的实例\n    private static BadSynchronizedSingleton synchronizedSingleton;\n    //私有化构造函数\n    private BadSynchronizedSingleton(){}\n    //给出一个公共的静态方法返回一个单一实例\n    public synchronized static BadSynchronizedSingleton getInstance(){\n        if (synchronizedSingleton == null) {\n            synchronizedSingleton = new BadSynchronizedSingleton();\n        }\n        return synchronizedSingleton;\n    }\n}\n```\n\n上面的做法很简单，就是将整个获取实例的方法同步，这样在一个线程访问这个方法时，其它所有的线程都要处于挂起等待状态，倒是避免了刚才同步访问创造出多个实例的危险，但是我只想说，这样的设计实在是糟糕透了，这样会造成很多无谓的等待\n\n其实我们同步的地方只是需要发生在单例的实例还未创建的时候，在实例创建以后，获取实例的方法就没必要再进行同步控制了。下面我们将上面的示例修改一下，变成标准版的单例模式，也称为双重加锁\n\n```\npublic class SynchronizedSingleton {\n\n    //一个静态的实例\n    private static SynchronizedSingleton synchronizedSingleton;\n    //私有化构造函数\n    private SynchronizedSingleton(){}\n    //给出一个公共的静态方法返回一个单一实例\n    public static SynchronizedSingleton getInstance(){\n        if (synchronizedSingleton == null) {\n            synchronized (SynchronizedSingleton.class) {\n                if (synchronizedSingleton == null) {\n                    synchronizedSingleton = new SynchronizedSingleton();\n                }\n            }\n        }\n        return synchronizedSingleton;\n    }\n}\n```\n\n这种做法与上面那种最无脑的同步做法相比就要好很多了，因为我们只是在当前实例为null，也就是实例还未创建时才进行同步，否则就直接返回，这样就节省了很多无谓的线程等待时间，值得注意的是在同步块中，我们再次判断了synchronizedSingleton是否为null，解释下为什么要这样做。\n\n假设我们去掉同步块中的是否为null的判断，有这样一种情况，假设A线程和B线程都在同步块外面判断了synchronizedSingleton为null，结果A线程首先获得了线程锁，进入了同步块，然后A线程会创造一个实例，此时synchronizedSingleton已经被赋予了实例，A线程退出同步块，直接返回了第一个创造的实例，此时B线程获得线程锁，也进入同步块，此时A线程其实已经创造好了实例，B线程正常情况应该直接返回的，但是因为同步块里没有判断是否为null，直接就是一条创建实例的语句，所以B线程也会创造一个实例返回，此时就造成创造了多个实例的情况。\n\n\n# 饿汉式\n\n```\npublic class SingletonDemo {\n    private static SingletonDemo instance = new SingletonDemo();\n\n    private SingletonDemo () {}\n\n    public static SingletonDemo getInstance() {\n        return instance;\n    }\n}\n```\n\n这种方式基于类加载机制避免了多线程同步问题\n","source":"_posts/singleton.md","raw":"---\ntitle: 设计模式-单例模式\ndate: 2018-06-11 09:36:33\ntags:\ncategories: 设计模式\n---\n\n# 定义\n\n是一种常用的软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类。一个类只有一个实例，即一个类只有一个对象的实例\n\n# 形式\n\n单例模式可以分为懒汉式和饿汉式\n\n懒汉式：在类加载时不初始化\n\n饿汉式：在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快\n\n# 懒汉式\n\n下面试最标准也是最原始的单例模式\n\n```\npublic class Singleton {\n    private static Singleton singleton;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            singleton = new Singleton();\n        }\n\n        return singleton;\n    }\n}\n```\n\n不考虑并发情况下，以上方法主要靠以下来限制实例的单一性\n\n1. 静态实例，带有static关键字的属性在每一个类中都是唯一的\n\n2. 私有化构造函数，限制了随意创造实例的可能性\n\n3. 公有获取实例的静态方法。为什么是静态？这个方法是供消费者获取对象实例的，如果是非静态的话，需要使用对象来调用，这就形成了矛盾\n\n\n## 线程安全的单例\n\n上面的方法在高并发情况下，肯定会出现有多个实例的情况-当一个线程判断为空，但是又没创建实例时，另一线程仍判断为空，这时就会出现单例模式非单例的情况\n\n解决以上问题首先可能想到的方法如下\n\n```\npublic class BadSynchronizedSingleton {\n\n    //一个静态的实例\n    private static BadSynchronizedSingleton synchronizedSingleton;\n    //私有化构造函数\n    private BadSynchronizedSingleton(){}\n    //给出一个公共的静态方法返回一个单一实例\n    public synchronized static BadSynchronizedSingleton getInstance(){\n        if (synchronizedSingleton == null) {\n            synchronizedSingleton = new BadSynchronizedSingleton();\n        }\n        return synchronizedSingleton;\n    }\n}\n```\n\n上面的做法很简单，就是将整个获取实例的方法同步，这样在一个线程访问这个方法时，其它所有的线程都要处于挂起等待状态，倒是避免了刚才同步访问创造出多个实例的危险，但是我只想说，这样的设计实在是糟糕透了，这样会造成很多无谓的等待\n\n其实我们同步的地方只是需要发生在单例的实例还未创建的时候，在实例创建以后，获取实例的方法就没必要再进行同步控制了。下面我们将上面的示例修改一下，变成标准版的单例模式，也称为双重加锁\n\n```\npublic class SynchronizedSingleton {\n\n    //一个静态的实例\n    private static SynchronizedSingleton synchronizedSingleton;\n    //私有化构造函数\n    private SynchronizedSingleton(){}\n    //给出一个公共的静态方法返回一个单一实例\n    public static SynchronizedSingleton getInstance(){\n        if (synchronizedSingleton == null) {\n            synchronized (SynchronizedSingleton.class) {\n                if (synchronizedSingleton == null) {\n                    synchronizedSingleton = new SynchronizedSingleton();\n                }\n            }\n        }\n        return synchronizedSingleton;\n    }\n}\n```\n\n这种做法与上面那种最无脑的同步做法相比就要好很多了，因为我们只是在当前实例为null，也就是实例还未创建时才进行同步，否则就直接返回，这样就节省了很多无谓的线程等待时间，值得注意的是在同步块中，我们再次判断了synchronizedSingleton是否为null，解释下为什么要这样做。\n\n假设我们去掉同步块中的是否为null的判断，有这样一种情况，假设A线程和B线程都在同步块外面判断了synchronizedSingleton为null，结果A线程首先获得了线程锁，进入了同步块，然后A线程会创造一个实例，此时synchronizedSingleton已经被赋予了实例，A线程退出同步块，直接返回了第一个创造的实例，此时B线程获得线程锁，也进入同步块，此时A线程其实已经创造好了实例，B线程正常情况应该直接返回的，但是因为同步块里没有判断是否为null，直接就是一条创建实例的语句，所以B线程也会创造一个实例返回，此时就造成创造了多个实例的情况。\n\n\n# 饿汉式\n\n```\npublic class SingletonDemo {\n    private static SingletonDemo instance = new SingletonDemo();\n\n    private SingletonDemo () {}\n\n    public static SingletonDemo getInstance() {\n        return instance;\n    }\n}\n```\n\n这种方式基于类加载机制避免了多线程同步问题\n","slug":"singleton","published":1,"updated":"2019-12-24T02:00:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jx100120j9kkglfh2f6","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>是一种常用的软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类。一个类只有一个实例，即一个类只有一个对象的实例</p>\n<h1 id=\"形式\"><a href=\"#形式\" class=\"headerlink\" title=\"形式\"></a>形式</h1><p>单例模式可以分为懒汉式和饿汉式</p>\n<p>懒汉式：在类加载时不初始化</p>\n<p>饿汉式：在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快</p>\n<h1 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h1><p>下面试最标准也是最原始的单例模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;</span><br><span class=\"line\">    private static Singleton singleton;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Singleton() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Singleton getInstance() &#123;</span><br><span class=\"line\">        if (singleton == null) &#123;</span><br><span class=\"line\">            singleton = new Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不考虑并发情况下，以上方法主要靠以下来限制实例的单一性</p>\n<ol>\n<li><p>静态实例，带有static关键字的属性在每一个类中都是唯一的</p>\n</li>\n<li><p>私有化构造函数，限制了随意创造实例的可能性</p>\n</li>\n<li><p>公有获取实例的静态方法。为什么是静态？这个方法是供消费者获取对象实例的，如果是非静态的话，需要使用对象来调用，这就形成了矛盾</p>\n</li>\n</ol>\n<h2 id=\"线程安全的单例\"><a href=\"#线程安全的单例\" class=\"headerlink\" title=\"线程安全的单例\"></a>线程安全的单例</h2><p>上面的方法在高并发情况下，肯定会出现有多个实例的情况-当一个线程判断为空，但是又没创建实例时，另一线程仍判断为空，这时就会出现单例模式非单例的情况</p>\n<p>解决以上问题首先可能想到的方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BadSynchronizedSingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //一个静态的实例</span><br><span class=\"line\">    private static BadSynchronizedSingleton synchronizedSingleton;</span><br><span class=\"line\">    //私有化构造函数</span><br><span class=\"line\">    private BadSynchronizedSingleton()&#123;&#125;</span><br><span class=\"line\">    //给出一个公共的静态方法返回一个单一实例</span><br><span class=\"line\">    public synchronized static BadSynchronizedSingleton getInstance()&#123;</span><br><span class=\"line\">        if (synchronizedSingleton == null) &#123;</span><br><span class=\"line\">            synchronizedSingleton = new BadSynchronizedSingleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return synchronizedSingleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的做法很简单，就是将整个获取实例的方法同步，这样在一个线程访问这个方法时，其它所有的线程都要处于挂起等待状态，倒是避免了刚才同步访问创造出多个实例的危险，但是我只想说，这样的设计实在是糟糕透了，这样会造成很多无谓的等待</p>\n<p>其实我们同步的地方只是需要发生在单例的实例还未创建的时候，在实例创建以后，获取实例的方法就没必要再进行同步控制了。下面我们将上面的示例修改一下，变成标准版的单例模式，也称为双重加锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SynchronizedSingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //一个静态的实例</span><br><span class=\"line\">    private static SynchronizedSingleton synchronizedSingleton;</span><br><span class=\"line\">    //私有化构造函数</span><br><span class=\"line\">    private SynchronizedSingleton()&#123;&#125;</span><br><span class=\"line\">    //给出一个公共的静态方法返回一个单一实例</span><br><span class=\"line\">    public static SynchronizedSingleton getInstance()&#123;</span><br><span class=\"line\">        if (synchronizedSingleton == null) &#123;</span><br><span class=\"line\">            synchronized (SynchronizedSingleton.class) &#123;</span><br><span class=\"line\">                if (synchronizedSingleton == null) &#123;</span><br><span class=\"line\">                    synchronizedSingleton = new SynchronizedSingleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return synchronizedSingleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种做法与上面那种最无脑的同步做法相比就要好很多了，因为我们只是在当前实例为null，也就是实例还未创建时才进行同步，否则就直接返回，这样就节省了很多无谓的线程等待时间，值得注意的是在同步块中，我们再次判断了synchronizedSingleton是否为null，解释下为什么要这样做。</p>\n<p>假设我们去掉同步块中的是否为null的判断，有这样一种情况，假设A线程和B线程都在同步块外面判断了synchronizedSingleton为null，结果A线程首先获得了线程锁，进入了同步块，然后A线程会创造一个实例，此时synchronizedSingleton已经被赋予了实例，A线程退出同步块，直接返回了第一个创造的实例，此时B线程获得线程锁，也进入同步块，此时A线程其实已经创造好了实例，B线程正常情况应该直接返回的，但是因为同步块里没有判断是否为null，直接就是一条创建实例的语句，所以B线程也会创造一个实例返回，此时就造成创造了多个实例的情况。</p>\n<h1 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingletonDemo &#123;</span><br><span class=\"line\">    private static SingletonDemo instance = new SingletonDemo();</span><br><span class=\"line\"></span><br><span class=\"line\">    private SingletonDemo () &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SingletonDemo getInstance() &#123;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式基于类加载机制避免了多线程同步问题</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>是一种常用的软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类。一个类只有一个实例，即一个类只有一个对象的实例</p>\n<h1 id=\"形式\"><a href=\"#形式\" class=\"headerlink\" title=\"形式\"></a>形式</h1><p>单例模式可以分为懒汉式和饿汉式</p>\n<p>懒汉式：在类加载时不初始化</p>\n<p>饿汉式：在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快</p>\n<h1 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h1><p>下面试最标准也是最原始的单例模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;</span><br><span class=\"line\">    private static Singleton singleton;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Singleton() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Singleton getInstance() &#123;</span><br><span class=\"line\">        if (singleton == null) &#123;</span><br><span class=\"line\">            singleton = new Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不考虑并发情况下，以上方法主要靠以下来限制实例的单一性</p>\n<ol>\n<li><p>静态实例，带有static关键字的属性在每一个类中都是唯一的</p>\n</li>\n<li><p>私有化构造函数，限制了随意创造实例的可能性</p>\n</li>\n<li><p>公有获取实例的静态方法。为什么是静态？这个方法是供消费者获取对象实例的，如果是非静态的话，需要使用对象来调用，这就形成了矛盾</p>\n</li>\n</ol>\n<h2 id=\"线程安全的单例\"><a href=\"#线程安全的单例\" class=\"headerlink\" title=\"线程安全的单例\"></a>线程安全的单例</h2><p>上面的方法在高并发情况下，肯定会出现有多个实例的情况-当一个线程判断为空，但是又没创建实例时，另一线程仍判断为空，这时就会出现单例模式非单例的情况</p>\n<p>解决以上问题首先可能想到的方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BadSynchronizedSingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //一个静态的实例</span><br><span class=\"line\">    private static BadSynchronizedSingleton synchronizedSingleton;</span><br><span class=\"line\">    //私有化构造函数</span><br><span class=\"line\">    private BadSynchronizedSingleton()&#123;&#125;</span><br><span class=\"line\">    //给出一个公共的静态方法返回一个单一实例</span><br><span class=\"line\">    public synchronized static BadSynchronizedSingleton getInstance()&#123;</span><br><span class=\"line\">        if (synchronizedSingleton == null) &#123;</span><br><span class=\"line\">            synchronizedSingleton = new BadSynchronizedSingleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return synchronizedSingleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的做法很简单，就是将整个获取实例的方法同步，这样在一个线程访问这个方法时，其它所有的线程都要处于挂起等待状态，倒是避免了刚才同步访问创造出多个实例的危险，但是我只想说，这样的设计实在是糟糕透了，这样会造成很多无谓的等待</p>\n<p>其实我们同步的地方只是需要发生在单例的实例还未创建的时候，在实例创建以后，获取实例的方法就没必要再进行同步控制了。下面我们将上面的示例修改一下，变成标准版的单例模式，也称为双重加锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SynchronizedSingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //一个静态的实例</span><br><span class=\"line\">    private static SynchronizedSingleton synchronizedSingleton;</span><br><span class=\"line\">    //私有化构造函数</span><br><span class=\"line\">    private SynchronizedSingleton()&#123;&#125;</span><br><span class=\"line\">    //给出一个公共的静态方法返回一个单一实例</span><br><span class=\"line\">    public static SynchronizedSingleton getInstance()&#123;</span><br><span class=\"line\">        if (synchronizedSingleton == null) &#123;</span><br><span class=\"line\">            synchronized (SynchronizedSingleton.class) &#123;</span><br><span class=\"line\">                if (synchronizedSingleton == null) &#123;</span><br><span class=\"line\">                    synchronizedSingleton = new SynchronizedSingleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return synchronizedSingleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种做法与上面那种最无脑的同步做法相比就要好很多了，因为我们只是在当前实例为null，也就是实例还未创建时才进行同步，否则就直接返回，这样就节省了很多无谓的线程等待时间，值得注意的是在同步块中，我们再次判断了synchronizedSingleton是否为null，解释下为什么要这样做。</p>\n<p>假设我们去掉同步块中的是否为null的判断，有这样一种情况，假设A线程和B线程都在同步块外面判断了synchronizedSingleton为null，结果A线程首先获得了线程锁，进入了同步块，然后A线程会创造一个实例，此时synchronizedSingleton已经被赋予了实例，A线程退出同步块，直接返回了第一个创造的实例，此时B线程获得线程锁，也进入同步块，此时A线程其实已经创造好了实例，B线程正常情况应该直接返回的，但是因为同步块里没有判断是否为null，直接就是一条创建实例的语句，所以B线程也会创造一个实例返回，此时就造成创造了多个实例的情况。</p>\n<h1 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SingletonDemo &#123;</span><br><span class=\"line\">    private static SingletonDemo instance = new SingletonDemo();</span><br><span class=\"line\"></span><br><span class=\"line\">    private SingletonDemo () &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SingletonDemo getInstance() &#123;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式基于类加载机制避免了多线程同步问题</p>\n"},{"title":"twitter的雪花算法实现","date":"2018-01-30T00:38:03.000Z","_content":"![](http://www.wailian.work/images/2018/01/30/f0cada473c10b0fcfae9784875af64050052c1d2195d47-eEEC79_fw658.jpg)\n\n# 概述\n\nSnowFlake算法是Twitter设计的一个可以在分布式系统中生成唯一的ID的算法，它可以满足Twitter每秒上万条消息ID分配的请求，这些消息ID是唯一的且有大致的递增顺序。\n\nSnowFlake算法生成的ID大致上是按照时间递增的，用在分布式系统中时，需要注意数据中心标识和机器标识必须唯一，这样就能保证每个节点生成的ID都是唯一的。\n\n# 原理\n\nSnowFlake算法产生的ID是一个64位的整型，结构如下（每一部分用“-”符号分隔）：\n\n![](http://www.wailian.work/images/2018/01/30/WX20180130-084624.png)\n\n## 1位标识部分\n\n在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以为0；\n\n## 41位时间戳部分\n\n这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69年；\n\n## 10位节点部分\n\nTwitter实现中使用前5位作为数据中心标识，后5位作为机器标识，可以部署1024个节点；\n\n## 12位序列号部分\n\n支持同一毫秒内同一个节点可以生成4096个ID；\n\nSnowFlake算法生成的ID大致上是按照时间递增的，用在分布式系统中时，需要注意数据中心标识和机器标识必须唯一，这样就能保证每个节点生成的ID都是唯一的。或许我们不一定都需要像上面那样使用5位作为数据中心标识，5位作为机器标识，可以根据我们业务的需要，灵活分配节点部分，如：若不需要数据中心，完全可以使用全部10位作为机器标识；若数据中心不多，也可以只使用3位作为数据中心，7位作为机器标识。\n\n# 源码\n\n```\npackage com.wang.snow;\n\npublic class SnowFlake {\n    /**\n     * 起始的时间戳\n     */\n    private final static long START_STMP = 1480166465631L;\n\n    /**\n     * 每一部分占用的位数\n     */\n    private final static long SEQUENCE_BIT = 12; //序列号占用的位数\n    private final static long MACHINE_BIT = 5;  //机器标识占用的位数\n    private final static long DATACENTER_BIT = 5;//数据中心占用的位数\n\n    /**\n     * 每一部分的最大值\n     */\n    private final static long MAX_DATACENTER_NUM = -1L ^ (-1L << DATACENTER_BIT);\n    private final static long MAX_MACHINE_NUM = -1L ^ (-1L << MACHINE_BIT);\n    private final static long MAX_SEQUENCE = -1L ^ (-1L << SEQUENCE_BIT);\n\n    /**\n     * 每一部分向左的位移\n     */\n    private final static long MACHINE_LEFT = SEQUENCE_BIT;\n    private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;\n    private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT;\n\n    private long datacenterId;  //数据中心\n    private long machineId;    //机器标识\n    private long sequence = 0L; //序列号\n    private long lastStmp = -1L;//上一次时间戳\n\n    public SnowFlake(long datacenterId, long machineId) {\n        if (datacenterId > MAX_DATACENTER_NUM || datacenterId < 0) {\n            throw new IllegalArgumentException(\"datacenterId can't be greater than MAX_DATACENTER_NUM or less than 0\");\n        }\n        if (machineId > MAX_MACHINE_NUM || machineId < 0) {\n            throw new IllegalArgumentException(\"machineId can't be greater than MAX_MACHINE_NUM or less than 0\");\n        }\n        this.datacenterId = datacenterId;\n        this.machineId = machineId;\n    }\n\n    /**\n     * 产生下一个ID\n     *\n     * @return\n     */\n    public synchronized long nextId() {\n        long currStmp = getNewstmp();\n        if (currStmp < lastStmp) {\n            throw new RuntimeException(\"Clock moved backwards.  Refusing to generate id\");\n        }\n\n        if (currStmp == lastStmp) {\n            //相同毫秒内，序列号自增\n            sequence = (sequence + 1) & MAX_SEQUENCE;\n            //同一毫秒的序列数已经达到最大\n            if (sequence == 0L) {\n                currStmp = getNextMill();\n            }\n        } else {\n            //不同毫秒内，序列号置为0\n            sequence = 0L;\n        }\n\n        lastStmp = currStmp;\n\n        return (currStmp - START_STMP) << TIMESTMP_LEFT //时间戳部分\n                | datacenterId << DATACENTER_LEFT      //数据中心部分\n                | machineId << MACHINE_LEFT            //机器标识部分\n                | sequence;                            //序列号部分\n    }\n\n    private long getNextMill() {\n        long mill = getNewstmp();\n        while (mill <= lastStmp) {\n            mill = getNewstmp();\n        }\n        return mill;\n    }\n\n    private long getNewstmp() {\n        return System.currentTimeMillis();\n    }\n}\n\n```\n\n# 测试代码\n\n```\n@Test\npublic void snow() {\n    SnowFlake snowFlake = new SnowFlake(2, 3);\n    for (int i = 0; i < (1 << 12); i++) {\n        System.out.println(snowFlake.nextId());\n    }\n}\n```\n\n# 结果\n\n```\n155632577921953792\n155632577921953793\n155632577921953794\n155632577921953795\n155632577921953796\n155632577921953797\n155632577921953798\n155632577921953799\n155632577921953800\n155632577921953801\n155632577921953802\n155632577921953803\n155632577921953804\n...\n```\n","source":"_posts/snow-flake.md","raw":"---\ntitle: twitter的雪花算法实现\ndate: 2018-01-30 08:38:03\ntags:\n---\n![](http://www.wailian.work/images/2018/01/30/f0cada473c10b0fcfae9784875af64050052c1d2195d47-eEEC79_fw658.jpg)\n\n# 概述\n\nSnowFlake算法是Twitter设计的一个可以在分布式系统中生成唯一的ID的算法，它可以满足Twitter每秒上万条消息ID分配的请求，这些消息ID是唯一的且有大致的递增顺序。\n\nSnowFlake算法生成的ID大致上是按照时间递增的，用在分布式系统中时，需要注意数据中心标识和机器标识必须唯一，这样就能保证每个节点生成的ID都是唯一的。\n\n# 原理\n\nSnowFlake算法产生的ID是一个64位的整型，结构如下（每一部分用“-”符号分隔）：\n\n![](http://www.wailian.work/images/2018/01/30/WX20180130-084624.png)\n\n## 1位标识部分\n\n在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以为0；\n\n## 41位时间戳部分\n\n这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69年；\n\n## 10位节点部分\n\nTwitter实现中使用前5位作为数据中心标识，后5位作为机器标识，可以部署1024个节点；\n\n## 12位序列号部分\n\n支持同一毫秒内同一个节点可以生成4096个ID；\n\nSnowFlake算法生成的ID大致上是按照时间递增的，用在分布式系统中时，需要注意数据中心标识和机器标识必须唯一，这样就能保证每个节点生成的ID都是唯一的。或许我们不一定都需要像上面那样使用5位作为数据中心标识，5位作为机器标识，可以根据我们业务的需要，灵活分配节点部分，如：若不需要数据中心，完全可以使用全部10位作为机器标识；若数据中心不多，也可以只使用3位作为数据中心，7位作为机器标识。\n\n# 源码\n\n```\npackage com.wang.snow;\n\npublic class SnowFlake {\n    /**\n     * 起始的时间戳\n     */\n    private final static long START_STMP = 1480166465631L;\n\n    /**\n     * 每一部分占用的位数\n     */\n    private final static long SEQUENCE_BIT = 12; //序列号占用的位数\n    private final static long MACHINE_BIT = 5;  //机器标识占用的位数\n    private final static long DATACENTER_BIT = 5;//数据中心占用的位数\n\n    /**\n     * 每一部分的最大值\n     */\n    private final static long MAX_DATACENTER_NUM = -1L ^ (-1L << DATACENTER_BIT);\n    private final static long MAX_MACHINE_NUM = -1L ^ (-1L << MACHINE_BIT);\n    private final static long MAX_SEQUENCE = -1L ^ (-1L << SEQUENCE_BIT);\n\n    /**\n     * 每一部分向左的位移\n     */\n    private final static long MACHINE_LEFT = SEQUENCE_BIT;\n    private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;\n    private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT;\n\n    private long datacenterId;  //数据中心\n    private long machineId;    //机器标识\n    private long sequence = 0L; //序列号\n    private long lastStmp = -1L;//上一次时间戳\n\n    public SnowFlake(long datacenterId, long machineId) {\n        if (datacenterId > MAX_DATACENTER_NUM || datacenterId < 0) {\n            throw new IllegalArgumentException(\"datacenterId can't be greater than MAX_DATACENTER_NUM or less than 0\");\n        }\n        if (machineId > MAX_MACHINE_NUM || machineId < 0) {\n            throw new IllegalArgumentException(\"machineId can't be greater than MAX_MACHINE_NUM or less than 0\");\n        }\n        this.datacenterId = datacenterId;\n        this.machineId = machineId;\n    }\n\n    /**\n     * 产生下一个ID\n     *\n     * @return\n     */\n    public synchronized long nextId() {\n        long currStmp = getNewstmp();\n        if (currStmp < lastStmp) {\n            throw new RuntimeException(\"Clock moved backwards.  Refusing to generate id\");\n        }\n\n        if (currStmp == lastStmp) {\n            //相同毫秒内，序列号自增\n            sequence = (sequence + 1) & MAX_SEQUENCE;\n            //同一毫秒的序列数已经达到最大\n            if (sequence == 0L) {\n                currStmp = getNextMill();\n            }\n        } else {\n            //不同毫秒内，序列号置为0\n            sequence = 0L;\n        }\n\n        lastStmp = currStmp;\n\n        return (currStmp - START_STMP) << TIMESTMP_LEFT //时间戳部分\n                | datacenterId << DATACENTER_LEFT      //数据中心部分\n                | machineId << MACHINE_LEFT            //机器标识部分\n                | sequence;                            //序列号部分\n    }\n\n    private long getNextMill() {\n        long mill = getNewstmp();\n        while (mill <= lastStmp) {\n            mill = getNewstmp();\n        }\n        return mill;\n    }\n\n    private long getNewstmp() {\n        return System.currentTimeMillis();\n    }\n}\n\n```\n\n# 测试代码\n\n```\n@Test\npublic void snow() {\n    SnowFlake snowFlake = new SnowFlake(2, 3);\n    for (int i = 0; i < (1 << 12); i++) {\n        System.out.println(snowFlake.nextId());\n    }\n}\n```\n\n# 结果\n\n```\n155632577921953792\n155632577921953793\n155632577921953794\n155632577921953795\n155632577921953796\n155632577921953797\n155632577921953798\n155632577921953799\n155632577921953800\n155632577921953801\n155632577921953802\n155632577921953803\n155632577921953804\n...\n```\n","slug":"snow-flake","published":1,"updated":"2019-12-24T02:00:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jx300130j9k8uzggrpo","content":"<p><img src=\"http://www.wailian.work/images/2018/01/30/f0cada473c10b0fcfae9784875af64050052c1d2195d47-eEEC79_fw658.jpg\" alt=\"\"></p>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>SnowFlake算法是Twitter设计的一个可以在分布式系统中生成唯一的ID的算法，它可以满足Twitter每秒上万条消息ID分配的请求，这些消息ID是唯一的且有大致的递增顺序。</p>\n<p>SnowFlake算法生成的ID大致上是按照时间递增的，用在分布式系统中时，需要注意数据中心标识和机器标识必须唯一，这样就能保证每个节点生成的ID都是唯一的。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>SnowFlake算法产生的ID是一个64位的整型，结构如下（每一部分用“-”符号分隔）：</p>\n<p><img src=\"http://www.wailian.work/images/2018/01/30/WX20180130-084624.png\" alt=\"\"></p>\n<h2 id=\"1位标识部分\"><a href=\"#1位标识部分\" class=\"headerlink\" title=\"1位标识部分\"></a>1位标识部分</h2><p>在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以为0；</p>\n<h2 id=\"41位时间戳部分\"><a href=\"#41位时间戳部分\" class=\"headerlink\" title=\"41位时间戳部分\"></a>41位时间戳部分</h2><p>这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L <em> 60 </em> 60 <em> 24 </em> 365) = 69年；</p>\n<h2 id=\"10位节点部分\"><a href=\"#10位节点部分\" class=\"headerlink\" title=\"10位节点部分\"></a>10位节点部分</h2><p>Twitter实现中使用前5位作为数据中心标识，后5位作为机器标识，可以部署1024个节点；</p>\n<h2 id=\"12位序列号部分\"><a href=\"#12位序列号部分\" class=\"headerlink\" title=\"12位序列号部分\"></a>12位序列号部分</h2><p>支持同一毫秒内同一个节点可以生成4096个ID；</p>\n<p>SnowFlake算法生成的ID大致上是按照时间递增的，用在分布式系统中时，需要注意数据中心标识和机器标识必须唯一，这样就能保证每个节点生成的ID都是唯一的。或许我们不一定都需要像上面那样使用5位作为数据中心标识，5位作为机器标识，可以根据我们业务的需要，灵活分配节点部分，如：若不需要数据中心，完全可以使用全部10位作为机器标识；若数据中心不多，也可以只使用3位作为数据中心，7位作为机器标识。</p>\n<h1 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.wang.snow;</span><br><span class=\"line\"></span><br><span class=\"line\">public class SnowFlake &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 起始的时间戳</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private final static long START_STMP = 1480166465631L;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 每一部分占用的位数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private final static long SEQUENCE_BIT = 12; //序列号占用的位数</span><br><span class=\"line\">    private final static long MACHINE_BIT = 5;  //机器标识占用的位数</span><br><span class=\"line\">    private final static long DATACENTER_BIT = 5;//数据中心占用的位数</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 每一部分的最大值</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private final static long MAX_DATACENTER_NUM = -1L ^ (-1L &lt;&lt; DATACENTER_BIT);</span><br><span class=\"line\">    private final static long MAX_MACHINE_NUM = -1L ^ (-1L &lt;&lt; MACHINE_BIT);</span><br><span class=\"line\">    private final static long MAX_SEQUENCE = -1L ^ (-1L &lt;&lt; SEQUENCE_BIT);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 每一部分向左的位移</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private final static long MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class=\"line\">    private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class=\"line\">    private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT;</span><br><span class=\"line\"></span><br><span class=\"line\">    private long datacenterId;  //数据中心</span><br><span class=\"line\">    private long machineId;    //机器标识</span><br><span class=\"line\">    private long sequence = 0L; //序列号</span><br><span class=\"line\">    private long lastStmp = -1L;//上一次时间戳</span><br><span class=\"line\"></span><br><span class=\"line\">    public SnowFlake(long datacenterId, long machineId) &#123;</span><br><span class=\"line\">        if (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; 0) &#123;</span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;datacenterId can&apos;t be greater than MAX_DATACENTER_NUM or less than 0&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) &#123;</span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;machineId can&apos;t be greater than MAX_MACHINE_NUM or less than 0&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        this.datacenterId = datacenterId;</span><br><span class=\"line\">        this.machineId = machineId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 产生下一个ID</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public synchronized long nextId() &#123;</span><br><span class=\"line\">        long currStmp = getNewstmp();</span><br><span class=\"line\">        if (currStmp &lt; lastStmp) &#123;</span><br><span class=\"line\">            throw new RuntimeException(&quot;Clock moved backwards.  Refusing to generate id&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (currStmp == lastStmp) &#123;</span><br><span class=\"line\">            //相同毫秒内，序列号自增</span><br><span class=\"line\">            sequence = (sequence + 1) &amp; MAX_SEQUENCE;</span><br><span class=\"line\">            //同一毫秒的序列数已经达到最大</span><br><span class=\"line\">            if (sequence == 0L) &#123;</span><br><span class=\"line\">                currStmp = getNextMill();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //不同毫秒内，序列号置为0</span><br><span class=\"line\">            sequence = 0L;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        lastStmp = currStmp;</span><br><span class=\"line\"></span><br><span class=\"line\">        return (currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT //时间戳部分</span><br><span class=\"line\">                | datacenterId &lt;&lt; DATACENTER_LEFT      //数据中心部分</span><br><span class=\"line\">                | machineId &lt;&lt; MACHINE_LEFT            //机器标识部分</span><br><span class=\"line\">                | sequence;                            //序列号部分</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private long getNextMill() &#123;</span><br><span class=\"line\">        long mill = getNewstmp();</span><br><span class=\"line\">        while (mill &lt;= lastStmp) &#123;</span><br><span class=\"line\">            mill = getNewstmp();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return mill;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private long getNewstmp() &#123;</span><br><span class=\"line\">        return System.currentTimeMillis();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void snow() &#123;</span><br><span class=\"line\">    SnowFlake snowFlake = new SnowFlake(2, 3);</span><br><span class=\"line\">    for (int i = 0; i &lt; (1 &lt;&lt; 12); i++) &#123;</span><br><span class=\"line\">        System.out.println(snowFlake.nextId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">155632577921953792</span><br><span class=\"line\">155632577921953793</span><br><span class=\"line\">155632577921953794</span><br><span class=\"line\">155632577921953795</span><br><span class=\"line\">155632577921953796</span><br><span class=\"line\">155632577921953797</span><br><span class=\"line\">155632577921953798</span><br><span class=\"line\">155632577921953799</span><br><span class=\"line\">155632577921953800</span><br><span class=\"line\">155632577921953801</span><br><span class=\"line\">155632577921953802</span><br><span class=\"line\">155632577921953803</span><br><span class=\"line\">155632577921953804</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/01/30/f0cada473c10b0fcfae9784875af64050052c1d2195d47-eEEC79_fw658.jpg\" alt=\"\"></p>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>SnowFlake算法是Twitter设计的一个可以在分布式系统中生成唯一的ID的算法，它可以满足Twitter每秒上万条消息ID分配的请求，这些消息ID是唯一的且有大致的递增顺序。</p>\n<p>SnowFlake算法生成的ID大致上是按照时间递增的，用在分布式系统中时，需要注意数据中心标识和机器标识必须唯一，这样就能保证每个节点生成的ID都是唯一的。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>SnowFlake算法产生的ID是一个64位的整型，结构如下（每一部分用“-”符号分隔）：</p>\n<p><img src=\"http://www.wailian.work/images/2018/01/30/WX20180130-084624.png\" alt=\"\"></p>\n<h2 id=\"1位标识部分\"><a href=\"#1位标识部分\" class=\"headerlink\" title=\"1位标识部分\"></a>1位标识部分</h2><p>在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以为0；</p>\n<h2 id=\"41位时间戳部分\"><a href=\"#41位时间戳部分\" class=\"headerlink\" title=\"41位时间戳部分\"></a>41位时间戳部分</h2><p>这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L <em> 60 </em> 60 <em> 24 </em> 365) = 69年；</p>\n<h2 id=\"10位节点部分\"><a href=\"#10位节点部分\" class=\"headerlink\" title=\"10位节点部分\"></a>10位节点部分</h2><p>Twitter实现中使用前5位作为数据中心标识，后5位作为机器标识，可以部署1024个节点；</p>\n<h2 id=\"12位序列号部分\"><a href=\"#12位序列号部分\" class=\"headerlink\" title=\"12位序列号部分\"></a>12位序列号部分</h2><p>支持同一毫秒内同一个节点可以生成4096个ID；</p>\n<p>SnowFlake算法生成的ID大致上是按照时间递增的，用在分布式系统中时，需要注意数据中心标识和机器标识必须唯一，这样就能保证每个节点生成的ID都是唯一的。或许我们不一定都需要像上面那样使用5位作为数据中心标识，5位作为机器标识，可以根据我们业务的需要，灵活分配节点部分，如：若不需要数据中心，完全可以使用全部10位作为机器标识；若数据中心不多，也可以只使用3位作为数据中心，7位作为机器标识。</p>\n<h1 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.wang.snow;</span><br><span class=\"line\"></span><br><span class=\"line\">public class SnowFlake &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 起始的时间戳</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private final static long START_STMP = 1480166465631L;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 每一部分占用的位数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private final static long SEQUENCE_BIT = 12; //序列号占用的位数</span><br><span class=\"line\">    private final static long MACHINE_BIT = 5;  //机器标识占用的位数</span><br><span class=\"line\">    private final static long DATACENTER_BIT = 5;//数据中心占用的位数</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 每一部分的最大值</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private final static long MAX_DATACENTER_NUM = -1L ^ (-1L &lt;&lt; DATACENTER_BIT);</span><br><span class=\"line\">    private final static long MAX_MACHINE_NUM = -1L ^ (-1L &lt;&lt; MACHINE_BIT);</span><br><span class=\"line\">    private final static long MAX_SEQUENCE = -1L ^ (-1L &lt;&lt; SEQUENCE_BIT);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 每一部分向左的位移</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private final static long MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class=\"line\">    private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class=\"line\">    private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT;</span><br><span class=\"line\"></span><br><span class=\"line\">    private long datacenterId;  //数据中心</span><br><span class=\"line\">    private long machineId;    //机器标识</span><br><span class=\"line\">    private long sequence = 0L; //序列号</span><br><span class=\"line\">    private long lastStmp = -1L;//上一次时间戳</span><br><span class=\"line\"></span><br><span class=\"line\">    public SnowFlake(long datacenterId, long machineId) &#123;</span><br><span class=\"line\">        if (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; 0) &#123;</span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;datacenterId can&apos;t be greater than MAX_DATACENTER_NUM or less than 0&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) &#123;</span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;machineId can&apos;t be greater than MAX_MACHINE_NUM or less than 0&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        this.datacenterId = datacenterId;</span><br><span class=\"line\">        this.machineId = machineId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 产生下一个ID</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public synchronized long nextId() &#123;</span><br><span class=\"line\">        long currStmp = getNewstmp();</span><br><span class=\"line\">        if (currStmp &lt; lastStmp) &#123;</span><br><span class=\"line\">            throw new RuntimeException(&quot;Clock moved backwards.  Refusing to generate id&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (currStmp == lastStmp) &#123;</span><br><span class=\"line\">            //相同毫秒内，序列号自增</span><br><span class=\"line\">            sequence = (sequence + 1) &amp; MAX_SEQUENCE;</span><br><span class=\"line\">            //同一毫秒的序列数已经达到最大</span><br><span class=\"line\">            if (sequence == 0L) &#123;</span><br><span class=\"line\">                currStmp = getNextMill();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //不同毫秒内，序列号置为0</span><br><span class=\"line\">            sequence = 0L;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        lastStmp = currStmp;</span><br><span class=\"line\"></span><br><span class=\"line\">        return (currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT //时间戳部分</span><br><span class=\"line\">                | datacenterId &lt;&lt; DATACENTER_LEFT      //数据中心部分</span><br><span class=\"line\">                | machineId &lt;&lt; MACHINE_LEFT            //机器标识部分</span><br><span class=\"line\">                | sequence;                            //序列号部分</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private long getNextMill() &#123;</span><br><span class=\"line\">        long mill = getNewstmp();</span><br><span class=\"line\">        while (mill &lt;= lastStmp) &#123;</span><br><span class=\"line\">            mill = getNewstmp();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return mill;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private long getNewstmp() &#123;</span><br><span class=\"line\">        return System.currentTimeMillis();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void snow() &#123;</span><br><span class=\"line\">    SnowFlake snowFlake = new SnowFlake(2, 3);</span><br><span class=\"line\">    for (int i = 0; i &lt; (1 &lt;&lt; 12); i++) &#123;</span><br><span class=\"line\">        System.out.println(snowFlake.nextId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">155632577921953792</span><br><span class=\"line\">155632577921953793</span><br><span class=\"line\">155632577921953794</span><br><span class=\"line\">155632577921953795</span><br><span class=\"line\">155632577921953796</span><br><span class=\"line\">155632577921953797</span><br><span class=\"line\">155632577921953798</span><br><span class=\"line\">155632577921953799</span><br><span class=\"line\">155632577921953800</span><br><span class=\"line\">155632577921953801</span><br><span class=\"line\">155632577921953802</span><br><span class=\"line\">155632577921953803</span><br><span class=\"line\">155632577921953804</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n"},{"title":"Spring Boot内嵌Tomcat临时目录问题","date":"2018-04-12T09:22:59.000Z","top":10,"_content":"\n> 最近发现线上一个项目日志突然报错，最终找到解决方法记录一下\n\n# 错误信息\n\n`java.io.IOException: The temporary upload location [/tmp/tomcat.948083514929465118.8889/work/Tomcat/localhost/ROOT] is not valid`\n\n![](http://www.wailian.work/images/2018/04/12/21.png)\n\n# 原因\n\n参考 https://github.com/spring-projects/spring-boot/issues/5009\n\n`tmpwatch` – removes  files  which haven’t been accessed for a period of time\n\n如上所言，删除指定的目录中一段时间未访问的文件。一般对于/tmp下的文件或日志文件\n\n意思是tomcat的临时目录会被`tmpwatch`删除掉，甚至可能删除掉`class`文件，导致错误的发生\n\n# 解决方法\n\n## 方法1.启动时指定新的临时目录\n\n```\n-Djava.io.tmpdir=/var/tmp\n```\n\n## 方法2.配置文件中设置新的临时目录\n\n```\nserver:\n    tomcat:\n       basedir: /var/tmp/\n```\n\n## 方法3.代码中配置tomcat 临时目录\n\n```\n@Configuration\npublic class MultipartConfig {\n    @Bean\n    MultipartConfigElement multipartConfigElement() {\n        MultipartConfigFactory factory = new MultipartConfigFactory();\n        String location = System.getProperty(\"user.dir\") + \"/data/tmp\";\n        File tmpFile = new File(location);\n        if (!tmpFile.exists()) {\n            tmpFile.mkdirs();\n        }\n        factory.setLocation(location);\n        return factory.createMultipartConfig();\n    }\n}\n```\n\n[参考链接](http://www.wtnull.com/v/SPRING/Spring%20boot%20%E5%86%85%E5%B5%8Ctomcat%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95%E4%B8%8D%E5%AD%98%E5%9C%A8%20%E9%94%99%E8%AF%AF.html)\n","source":"_posts/spring-boot-tomcat.md","raw":"---\ntitle: Spring Boot内嵌Tomcat临时目录问题 \ndate: 2018-04-12 17:22:59\ntags:\ntop: 10\n---\n\n> 最近发现线上一个项目日志突然报错，最终找到解决方法记录一下\n\n# 错误信息\n\n`java.io.IOException: The temporary upload location [/tmp/tomcat.948083514929465118.8889/work/Tomcat/localhost/ROOT] is not valid`\n\n![](http://www.wailian.work/images/2018/04/12/21.png)\n\n# 原因\n\n参考 https://github.com/spring-projects/spring-boot/issues/5009\n\n`tmpwatch` – removes  files  which haven’t been accessed for a period of time\n\n如上所言，删除指定的目录中一段时间未访问的文件。一般对于/tmp下的文件或日志文件\n\n意思是tomcat的临时目录会被`tmpwatch`删除掉，甚至可能删除掉`class`文件，导致错误的发生\n\n# 解决方法\n\n## 方法1.启动时指定新的临时目录\n\n```\n-Djava.io.tmpdir=/var/tmp\n```\n\n## 方法2.配置文件中设置新的临时目录\n\n```\nserver:\n    tomcat:\n       basedir: /var/tmp/\n```\n\n## 方法3.代码中配置tomcat 临时目录\n\n```\n@Configuration\npublic class MultipartConfig {\n    @Bean\n    MultipartConfigElement multipartConfigElement() {\n        MultipartConfigFactory factory = new MultipartConfigFactory();\n        String location = System.getProperty(\"user.dir\") + \"/data/tmp\";\n        File tmpFile = new File(location);\n        if (!tmpFile.exists()) {\n            tmpFile.mkdirs();\n        }\n        factory.setLocation(location);\n        return factory.createMultipartConfig();\n    }\n}\n```\n\n[参考链接](http://www.wtnull.com/v/SPRING/Spring%20boot%20%E5%86%85%E5%B5%8Ctomcat%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95%E4%B8%8D%E5%AD%98%E5%9C%A8%20%E9%94%99%E8%AF%AF.html)\n","slug":"spring-boot-tomcat","published":1,"updated":"2019-12-24T02:00:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jx400140j9kobbqyj3t","content":"<blockquote>\n<p>最近发现线上一个项目日志突然报错，最终找到解决方法记录一下</p>\n</blockquote>\n<h1 id=\"错误信息\"><a href=\"#错误信息\" class=\"headerlink\" title=\"错误信息\"></a>错误信息</h1><p><code>java.io.IOException: The temporary upload location [/tmp/tomcat.948083514929465118.8889/work/Tomcat/localhost/ROOT] is not valid</code></p>\n<p><img src=\"http://www.wailian.work/images/2018/04/12/21.png\" alt=\"\"></p>\n<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h1><p>参考 <a href=\"https://github.com/spring-projects/spring-boot/issues/5009\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-projects/spring-boot/issues/5009</a></p>\n<p><code>tmpwatch</code> – removes  files  which haven’t been accessed for a period of time</p>\n<p>如上所言，删除指定的目录中一段时间未访问的文件。一般对于/tmp下的文件或日志文件</p>\n<p>意思是tomcat的临时目录会被<code>tmpwatch</code>删除掉，甚至可能删除掉<code>class</code>文件，导致错误的发生</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><h2 id=\"方法1-启动时指定新的临时目录\"><a href=\"#方法1-启动时指定新的临时目录\" class=\"headerlink\" title=\"方法1.启动时指定新的临时目录\"></a>方法1.启动时指定新的临时目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Djava.io.tmpdir=/var/tmp</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法2-配置文件中设置新的临时目录\"><a href=\"#方法2-配置文件中设置新的临时目录\" class=\"headerlink\" title=\"方法2.配置文件中设置新的临时目录\"></a>方法2.配置文件中设置新的临时目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">    tomcat:</span><br><span class=\"line\">       basedir: /var/tmp/</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法3-代码中配置tomcat-临时目录\"><a href=\"#方法3-代码中配置tomcat-临时目录\" class=\"headerlink\" title=\"方法3.代码中配置tomcat 临时目录\"></a>方法3.代码中配置tomcat 临时目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class MultipartConfig &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    MultipartConfigElement multipartConfigElement() &#123;</span><br><span class=\"line\">        MultipartConfigFactory factory = new MultipartConfigFactory();</span><br><span class=\"line\">        String location = System.getProperty(&quot;user.dir&quot;) + &quot;/data/tmp&quot;;</span><br><span class=\"line\">        File tmpFile = new File(location);</span><br><span class=\"line\">        if (!tmpFile.exists()) &#123;</span><br><span class=\"line\">            tmpFile.mkdirs();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        factory.setLocation(location);</span><br><span class=\"line\">        return factory.createMultipartConfig();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.wtnull.com/v/SPRING/Spring%20boot%20%E5%86%85%E5%B5%8Ctomcat%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95%E4%B8%8D%E5%AD%98%E5%9C%A8%20%E9%94%99%E8%AF%AF.html\" target=\"_blank\" rel=\"noopener\">参考链接</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近发现线上一个项目日志突然报错，最终找到解决方法记录一下</p>\n</blockquote>\n<h1 id=\"错误信息\"><a href=\"#错误信息\" class=\"headerlink\" title=\"错误信息\"></a>错误信息</h1><p><code>java.io.IOException: The temporary upload location [/tmp/tomcat.948083514929465118.8889/work/Tomcat/localhost/ROOT] is not valid</code></p>\n<p><img src=\"http://www.wailian.work/images/2018/04/12/21.png\" alt=\"\"></p>\n<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h1><p>参考 <a href=\"https://github.com/spring-projects/spring-boot/issues/5009\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-projects/spring-boot/issues/5009</a></p>\n<p><code>tmpwatch</code> – removes  files  which haven’t been accessed for a period of time</p>\n<p>如上所言，删除指定的目录中一段时间未访问的文件。一般对于/tmp下的文件或日志文件</p>\n<p>意思是tomcat的临时目录会被<code>tmpwatch</code>删除掉，甚至可能删除掉<code>class</code>文件，导致错误的发生</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><h2 id=\"方法1-启动时指定新的临时目录\"><a href=\"#方法1-启动时指定新的临时目录\" class=\"headerlink\" title=\"方法1.启动时指定新的临时目录\"></a>方法1.启动时指定新的临时目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Djava.io.tmpdir=/var/tmp</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法2-配置文件中设置新的临时目录\"><a href=\"#方法2-配置文件中设置新的临时目录\" class=\"headerlink\" title=\"方法2.配置文件中设置新的临时目录\"></a>方法2.配置文件中设置新的临时目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">    tomcat:</span><br><span class=\"line\">       basedir: /var/tmp/</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法3-代码中配置tomcat-临时目录\"><a href=\"#方法3-代码中配置tomcat-临时目录\" class=\"headerlink\" title=\"方法3.代码中配置tomcat 临时目录\"></a>方法3.代码中配置tomcat 临时目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class MultipartConfig &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    MultipartConfigElement multipartConfigElement() &#123;</span><br><span class=\"line\">        MultipartConfigFactory factory = new MultipartConfigFactory();</span><br><span class=\"line\">        String location = System.getProperty(&quot;user.dir&quot;) + &quot;/data/tmp&quot;;</span><br><span class=\"line\">        File tmpFile = new File(location);</span><br><span class=\"line\">        if (!tmpFile.exists()) &#123;</span><br><span class=\"line\">            tmpFile.mkdirs();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        factory.setLocation(location);</span><br><span class=\"line\">        return factory.createMultipartConfig();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.wtnull.com/v/SPRING/Spring%20boot%20%E5%86%85%E5%B5%8Ctomcat%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95%E4%B8%8D%E5%AD%98%E5%9C%A8%20%E9%94%99%E8%AF%AF.html\" target=\"_blank\" rel=\"noopener\">参考链接</a></p>\n"},{"title":"1.Spring Cloud：服务注册与发现","date":"2017-12-14T06:39:51.000Z","top":1,"_content":"\n![](http://www.wailian.work/images/2018/04/11/7e5ab258cc355acd50eb3c588de61078be3bb9bd4c432-iZMM5y_fw658.jpg)\n\n# 微服务架构\n\n什么是“微服务架构”呢？简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。\n\n# 服务治理\n\n在简单介绍了Spring Cloud和微服务架构之后，下面回归本文的主旨内容，如何使用Spring Cloud来实现服务治理。\n\n由于Spring Cloud为服务治理做了一层抽象接口，所以在Spring Cloud应用中可以支持多种不同的服务治理框架，比如：Netflix Eureka、Consul、Zookeeper。在Spring Cloud服务治理抽象层的作用下，我们可以无缝地切换服务治理实现，并且不影响任何其他的服务注册、服务发现、服务调用等逻辑。\n\n所以，下面我们通过介绍两种服务治理的实现来体会Spring Cloud这一层抽象所带来的好处。\n\n# Spring Cloud Eureka\n\n首先，我们来尝试使用Spring Cloud Eureka来实现服务治理。\n\nSpring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。\n\n下面，就来具体看看如何使用Spring Cloud Eureka实现服务治理。\n\n# 创建“服务注册中心”\n\n创建一个基础的Spring Boot工程，命名为eureka-server，并在pom.xml中引入需要的依赖内容：\n\n```\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.5.4.RELEASE</version>\n    <relativePath/>\n</parent>\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-eureka-server</artifactId>\n    </dependency>\n</dependencies>\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n           <groupId>org.springframework.cloud</groupId>\n           <artifactId>spring-cloud-dependencies</artifactId>\n           <version>Dalston.SR1</version>\n           <type>pom</type>\n           <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。这一步非常的简单，只需要在一个普通的Spring Boot应用中添加这个注解就能开启此功能，比如下面的例子：\n```\n@EnableEurekaServer\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Application.class).web(true).run(args);\n    }\n}\n```\n在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties配置文件中增加如下信息：\n```\nspring.application.name=eureka-server\nserver.port=1001\neureka.instance.hostname=localhost\neureka.client.register-with-eureka=false\neureka.client.fetch-registry=false\n```\n为了与后续要进行注册的服务区分，这里将服务注册中心的端口通过server.port属性设置为1001。启动工程后，访问：http://localhost:1001/ ，可以看到下面的页面，其中还没有发现任何服务。\n\n# 创建“服务提供方”\n\n下面我们创建提供服务的客户端，并向服务注册中心注册自己。本文我们主要介绍服务的注册与发现，所以我们不妨在服务提供方中尝试着提供一个接口来获取当前所有的服务信息。\n\n首先，创建一个基本的Spring Boot应用。命名为eureka-client，在pom.xml中，加入如下配置：\n\n```\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.5.4.RELEASE</version>\n    <relativePath/> <!-- lookup parent from repository -->\n</parent>\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-eureka</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n           <groupId>org.springframework.cloud</groupId>\n           <artifactId>spring-cloud-dependencies</artifactId>\n           <version>Dalston.SR1</version>\n           <type>pom</type>\n           <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n其次，实现/dc请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。\n```\n@RestController\npublic class DcController {\n    @Autowired\n    DiscoveryClient discoveryClient;\n    @GetMapping(\"/dc\")\n    public String dc() {\n        String services = \"Services: \" + discoveryClient.getServices();\n        System.out.println(services);\n        return services;\n    }\n}\n```\n最后在应用主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。\n```\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(ComputeServiceApplication.class).web(true).run(args);\n    }\n}\n```\n我们在完成了服务内容的实现之后，再继续对application.properties做一些配置工作，具体如下：\n```\nspring.application.name=eureka-client\nserver.port=2001\neureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/\n```\n通过spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。为了在本机上测试区分服务提供方和服务注册中心，使用server.port属性设置不同的端口。\n\n启动该工程后，再次访问：http://localhost:1001/ 可以如下图内容，我们定义的服务被成功注册了。\n\n当然，我们也可以通过直接访问eureka-client服务提供的/dc接口来获取当前的服务清单，只需要访问：http://localhost:2001/dc ，我们可以得到如下输出返回：\n```\nServices: [eureka-client]\n```\n其中，方括号中的eureka-client就是通过Spring Cloud定义的DiscoveryClient接口在eureka的实现中获取到的所有服务清单。由于Spring Cloud在服务发现这一层做了非常好的抽象，所以，对于上面的程序，我们可以无缝的从eureka的服务治理体系切换到consul的服务治理体系中去。\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","source":"_posts/spring-cloud-eureka.md","raw":"---\ntitle: 1.Spring Cloud：服务注册与发现\ndate: 2017-12-14 14:39:51\ntop: 1\ncategories: 微服务\n---\n\n![](http://www.wailian.work/images/2018/04/11/7e5ab258cc355acd50eb3c588de61078be3bb9bd4c432-iZMM5y_fw658.jpg)\n\n# 微服务架构\n\n什么是“微服务架构”呢？简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。\n\n# 服务治理\n\n在简单介绍了Spring Cloud和微服务架构之后，下面回归本文的主旨内容，如何使用Spring Cloud来实现服务治理。\n\n由于Spring Cloud为服务治理做了一层抽象接口，所以在Spring Cloud应用中可以支持多种不同的服务治理框架，比如：Netflix Eureka、Consul、Zookeeper。在Spring Cloud服务治理抽象层的作用下，我们可以无缝地切换服务治理实现，并且不影响任何其他的服务注册、服务发现、服务调用等逻辑。\n\n所以，下面我们通过介绍两种服务治理的实现来体会Spring Cloud这一层抽象所带来的好处。\n\n# Spring Cloud Eureka\n\n首先，我们来尝试使用Spring Cloud Eureka来实现服务治理。\n\nSpring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。\n\n下面，就来具体看看如何使用Spring Cloud Eureka实现服务治理。\n\n# 创建“服务注册中心”\n\n创建一个基础的Spring Boot工程，命名为eureka-server，并在pom.xml中引入需要的依赖内容：\n\n```\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.5.4.RELEASE</version>\n    <relativePath/>\n</parent>\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-eureka-server</artifactId>\n    </dependency>\n</dependencies>\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n           <groupId>org.springframework.cloud</groupId>\n           <artifactId>spring-cloud-dependencies</artifactId>\n           <version>Dalston.SR1</version>\n           <type>pom</type>\n           <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。这一步非常的简单，只需要在一个普通的Spring Boot应用中添加这个注解就能开启此功能，比如下面的例子：\n```\n@EnableEurekaServer\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Application.class).web(true).run(args);\n    }\n}\n```\n在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties配置文件中增加如下信息：\n```\nspring.application.name=eureka-server\nserver.port=1001\neureka.instance.hostname=localhost\neureka.client.register-with-eureka=false\neureka.client.fetch-registry=false\n```\n为了与后续要进行注册的服务区分，这里将服务注册中心的端口通过server.port属性设置为1001。启动工程后，访问：http://localhost:1001/ ，可以看到下面的页面，其中还没有发现任何服务。\n\n# 创建“服务提供方”\n\n下面我们创建提供服务的客户端，并向服务注册中心注册自己。本文我们主要介绍服务的注册与发现，所以我们不妨在服务提供方中尝试着提供一个接口来获取当前所有的服务信息。\n\n首先，创建一个基本的Spring Boot应用。命名为eureka-client，在pom.xml中，加入如下配置：\n\n```\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.5.4.RELEASE</version>\n    <relativePath/> <!-- lookup parent from repository -->\n</parent>\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-eureka</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n           <groupId>org.springframework.cloud</groupId>\n           <artifactId>spring-cloud-dependencies</artifactId>\n           <version>Dalston.SR1</version>\n           <type>pom</type>\n           <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n其次，实现/dc请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。\n```\n@RestController\npublic class DcController {\n    @Autowired\n    DiscoveryClient discoveryClient;\n    @GetMapping(\"/dc\")\n    public String dc() {\n        String services = \"Services: \" + discoveryClient.getServices();\n        System.out.println(services);\n        return services;\n    }\n}\n```\n最后在应用主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。\n```\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(ComputeServiceApplication.class).web(true).run(args);\n    }\n}\n```\n我们在完成了服务内容的实现之后，再继续对application.properties做一些配置工作，具体如下：\n```\nspring.application.name=eureka-client\nserver.port=2001\neureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/\n```\n通过spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。为了在本机上测试区分服务提供方和服务注册中心，使用server.port属性设置不同的端口。\n\n启动该工程后，再次访问：http://localhost:1001/ 可以如下图内容，我们定义的服务被成功注册了。\n\n当然，我们也可以通过直接访问eureka-client服务提供的/dc接口来获取当前的服务清单，只需要访问：http://localhost:2001/dc ，我们可以得到如下输出返回：\n```\nServices: [eureka-client]\n```\n其中，方括号中的eureka-client就是通过Spring Cloud定义的DiscoveryClient接口在eureka的实现中获取到的所有服务清单。由于Spring Cloud在服务发现这一层做了非常好的抽象，所以，对于上面的程序，我们可以无缝的从eureka的服务治理体系切换到consul的服务治理体系中去。\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","slug":"spring-cloud-eureka","published":1,"updated":"2019-12-24T02:00:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jx500150j9kjt6zlfdg","content":"<p><img src=\"http://www.wailian.work/images/2018/04/11/7e5ab258cc355acd50eb3c588de61078be3bb9bd4c432-iZMM5y_fw658.jpg\" alt=\"\"></p>\n<h1 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h1><p>什么是“微服务架构”呢？简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。</p>\n<h1 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h1><p>在简单介绍了Spring Cloud和微服务架构之后，下面回归本文的主旨内容，如何使用Spring Cloud来实现服务治理。</p>\n<p>由于Spring Cloud为服务治理做了一层抽象接口，所以在Spring Cloud应用中可以支持多种不同的服务治理框架，比如：Netflix Eureka、Consul、Zookeeper。在Spring Cloud服务治理抽象层的作用下，我们可以无缝地切换服务治理实现，并且不影响任何其他的服务注册、服务发现、服务调用等逻辑。</p>\n<p>所以，下面我们通过介绍两种服务治理的实现来体会Spring Cloud这一层抽象所带来的好处。</p>\n<h1 id=\"Spring-Cloud-Eureka\"><a href=\"#Spring-Cloud-Eureka\" class=\"headerlink\" title=\"Spring Cloud Eureka\"></a>Spring Cloud Eureka</h1><p>首先，我们来尝试使用Spring Cloud Eureka来实现服务治理。</p>\n<p>Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。</p>\n<p>下面，就来具体看看如何使用Spring Cloud Eureka实现服务治理。</p>\n<h1 id=\"创建“服务注册中心”\"><a href=\"#创建“服务注册中心”\" class=\"headerlink\" title=\"创建“服务注册中心”\"></a>创建“服务注册中心”</h1><p>创建一个基础的Spring Boot工程，命名为eureka-server，并在pom.xml中引入需要的依赖内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;relativePath/&gt;</span><br><span class=\"line\">&lt;/parent&gt;</span><br><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br><span class=\"line\">&lt;dependencyManagement&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">           &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class=\"line\">           &lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class=\"line\">           &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">           &lt;scope&gt;import&lt;/scope&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>\n<p>通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。这一步非常的简单，只需要在一个普通的Spring Boot应用中添加这个注解就能开启此功能，比如下面的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableEurekaServer</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties配置文件中增加如下信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-server</span><br><span class=\"line\">server.port=1001</span><br><span class=\"line\">eureka.instance.hostname=localhost</span><br><span class=\"line\">eureka.client.register-with-eureka=false</span><br><span class=\"line\">eureka.client.fetch-registry=false</span><br></pre></td></tr></table></figure></p>\n<p>为了与后续要进行注册的服务区分，这里将服务注册中心的端口通过server.port属性设置为1001。启动工程后，访问：<a href=\"http://localhost:1001/\" target=\"_blank\" rel=\"noopener\">http://localhost:1001/</a> ，可以看到下面的页面，其中还没有发现任何服务。</p>\n<h1 id=\"创建“服务提供方”\"><a href=\"#创建“服务提供方”\" class=\"headerlink\" title=\"创建“服务提供方”\"></a>创建“服务提供方”</h1><p>下面我们创建提供服务的客户端，并向服务注册中心注册自己。本文我们主要介绍服务的注册与发现，所以我们不妨在服务提供方中尝试着提供一个接口来获取当前所有的服务信息。</p>\n<p>首先，创建一个基本的Spring Boot应用。命名为eureka-client，在pom.xml中，加入如下配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class=\"line\">&lt;/parent&gt;</span><br><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br><span class=\"line\">&lt;dependencyManagement&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">           &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class=\"line\">           &lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class=\"line\">           &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">           &lt;scope&gt;import&lt;/scope&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>\n<p>其次，实现/dc请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class DcController &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    DiscoveryClient discoveryClient;</span><br><span class=\"line\">    @GetMapping(&quot;/dc&quot;)</span><br><span class=\"line\">    public String dc() &#123;</span><br><span class=\"line\">        String services = &quot;Services: &quot; + discoveryClient.getServices();</span><br><span class=\"line\">        System.out.println(services);</span><br><span class=\"line\">        return services;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后在应用主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(ComputeServiceApplication.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们在完成了服务内容的实现之后，再继续对application.properties做一些配置工作，具体如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-client</span><br><span class=\"line\">server.port=2001</span><br><span class=\"line\">eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/</span><br></pre></td></tr></table></figure></p>\n<p>通过spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。为了在本机上测试区分服务提供方和服务注册中心，使用server.port属性设置不同的端口。</p>\n<p>启动该工程后，再次访问：<a href=\"http://localhost:1001/\" target=\"_blank\" rel=\"noopener\">http://localhost:1001/</a> 可以如下图内容，我们定义的服务被成功注册了。</p>\n<p>当然，我们也可以通过直接访问eureka-client服务提供的/dc接口来获取当前的服务清单，只需要访问：<a href=\"http://localhost:2001/dc\" target=\"_blank\" rel=\"noopener\">http://localhost:2001/dc</a> ，我们可以得到如下输出返回：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Services: [eureka-client]</span><br></pre></td></tr></table></figure></p>\n<p>其中，方括号中的eureka-client就是通过Spring Cloud定义的DiscoveryClient接口在eureka的实现中获取到的所有服务清单。由于Spring Cloud在服务发现这一层做了非常好的抽象，所以，对于上面的程序，我们可以无缝的从eureka的服务治理体系切换到consul的服务治理体系中去。</p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/04/11/7e5ab258cc355acd50eb3c588de61078be3bb9bd4c432-iZMM5y_fw658.jpg\" alt=\"\"></p>\n<h1 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h1><p>什么是“微服务架构”呢？简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。</p>\n<h1 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h1><p>在简单介绍了Spring Cloud和微服务架构之后，下面回归本文的主旨内容，如何使用Spring Cloud来实现服务治理。</p>\n<p>由于Spring Cloud为服务治理做了一层抽象接口，所以在Spring Cloud应用中可以支持多种不同的服务治理框架，比如：Netflix Eureka、Consul、Zookeeper。在Spring Cloud服务治理抽象层的作用下，我们可以无缝地切换服务治理实现，并且不影响任何其他的服务注册、服务发现、服务调用等逻辑。</p>\n<p>所以，下面我们通过介绍两种服务治理的实现来体会Spring Cloud这一层抽象所带来的好处。</p>\n<h1 id=\"Spring-Cloud-Eureka\"><a href=\"#Spring-Cloud-Eureka\" class=\"headerlink\" title=\"Spring Cloud Eureka\"></a>Spring Cloud Eureka</h1><p>首先，我们来尝试使用Spring Cloud Eureka来实现服务治理。</p>\n<p>Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。</p>\n<p>下面，就来具体看看如何使用Spring Cloud Eureka实现服务治理。</p>\n<h1 id=\"创建“服务注册中心”\"><a href=\"#创建“服务注册中心”\" class=\"headerlink\" title=\"创建“服务注册中心”\"></a>创建“服务注册中心”</h1><p>创建一个基础的Spring Boot工程，命名为eureka-server，并在pom.xml中引入需要的依赖内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;relativePath/&gt;</span><br><span class=\"line\">&lt;/parent&gt;</span><br><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br><span class=\"line\">&lt;dependencyManagement&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">           &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class=\"line\">           &lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class=\"line\">           &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">           &lt;scope&gt;import&lt;/scope&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>\n<p>通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。这一步非常的简单，只需要在一个普通的Spring Boot应用中添加这个注解就能开启此功能，比如下面的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableEurekaServer</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties配置文件中增加如下信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-server</span><br><span class=\"line\">server.port=1001</span><br><span class=\"line\">eureka.instance.hostname=localhost</span><br><span class=\"line\">eureka.client.register-with-eureka=false</span><br><span class=\"line\">eureka.client.fetch-registry=false</span><br></pre></td></tr></table></figure></p>\n<p>为了与后续要进行注册的服务区分，这里将服务注册中心的端口通过server.port属性设置为1001。启动工程后，访问：<a href=\"http://localhost:1001/\" target=\"_blank\" rel=\"noopener\">http://localhost:1001/</a> ，可以看到下面的页面，其中还没有发现任何服务。</p>\n<h1 id=\"创建“服务提供方”\"><a href=\"#创建“服务提供方”\" class=\"headerlink\" title=\"创建“服务提供方”\"></a>创建“服务提供方”</h1><p>下面我们创建提供服务的客户端，并向服务注册中心注册自己。本文我们主要介绍服务的注册与发现，所以我们不妨在服务提供方中尝试着提供一个接口来获取当前所有的服务信息。</p>\n<p>首先，创建一个基本的Spring Boot应用。命名为eureka-client，在pom.xml中，加入如下配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class=\"line\">&lt;/parent&gt;</span><br><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br><span class=\"line\">&lt;dependencyManagement&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">           &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class=\"line\">           &lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class=\"line\">           &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">           &lt;scope&gt;import&lt;/scope&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>\n<p>其次，实现/dc请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class DcController &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    DiscoveryClient discoveryClient;</span><br><span class=\"line\">    @GetMapping(&quot;/dc&quot;)</span><br><span class=\"line\">    public String dc() &#123;</span><br><span class=\"line\">        String services = &quot;Services: &quot; + discoveryClient.getServices();</span><br><span class=\"line\">        System.out.println(services);</span><br><span class=\"line\">        return services;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后在应用主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(ComputeServiceApplication.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们在完成了服务内容的实现之后，再继续对application.properties做一些配置工作，具体如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-client</span><br><span class=\"line\">server.port=2001</span><br><span class=\"line\">eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/</span><br></pre></td></tr></table></figure></p>\n<p>通过spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。为了在本机上测试区分服务提供方和服务注册中心，使用server.port属性设置不同的端口。</p>\n<p>启动该工程后，再次访问：<a href=\"http://localhost:1001/\" target=\"_blank\" rel=\"noopener\">http://localhost:1001/</a> 可以如下图内容，我们定义的服务被成功注册了。</p>\n<p>当然，我们也可以通过直接访问eureka-client服务提供的/dc接口来获取当前的服务清单，只需要访问：<a href=\"http://localhost:2001/dc\" target=\"_blank\" rel=\"noopener\">http://localhost:2001/dc</a> ，我们可以得到如下输出返回：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Services: [eureka-client]</span><br></pre></td></tr></table></figure></p>\n<p>其中，方括号中的eureka-client就是通过Spring Cloud定义的DiscoveryClient接口在eureka的实现中获取到的所有服务清单。由于Spring Cloud在服务发现这一层做了非常好的抽象，所以，对于上面的程序，我们可以无缝的从eureka的服务治理体系切换到consul的服务治理体系中去。</p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n"},{"title":"10.Spring Cloud构建微服务架构：服务网关（过滤器）【Dalston版】","date":"2018-04-11T08:18:49.000Z","_content":"\n![](http://www.wailian.work/images/2018/04/11/824a22acf6f0148cdd9cb70c66800ebaace0dcd92d5b7-QI248r_fw658.jpg)\n\n在前两篇文章：服务网关（基础）、服务网关（路由配置）中，我们了解了Spring Cloud Zuul作为网关所具备的最基本功能：路由。本文我们将具体介绍一下Spring Cloud Zuul的另一项核心功能：过滤器。\n\n# 过滤器的作用\n\n通过上面所述的两篇我们，我们已经能够实现请求的路由功能，所以我们的微服务应用提供的接口就可以通过统一的API网关入口被客户端访问到了。但是，每个客户端用户请求微服务应用提供的接口时，它们的访问权限往往都需要有一定的限制，系统并不会将所有的微服务接口都对它们开放。然而，目前的服务路由并没有限制权限这样的功能，所有请求都会被毫无保留地转发到具体的应用并返回结果，为了实现对客户端请求的安全校验和权限控制，最简单和粗暴的方法就是为每个微服务应用都实现一套用于校验签名和鉴别权限的过滤器或拦截器。不过，这样的做法并不可取，它会增加日后的系统维护难度，因为同一个系统中的各种校验逻辑很多情况下都是大致相同或类似的，这样的实现方式会使得相似的校验逻辑代码被分散到了各个微服务中去，冗余代码的出现是我们不希望看到的。所以，比较好的做法是将这些校验逻辑剥离出去，构建出一个独立的鉴权服务。在完成了剥离之后，有不少开发者会直接在微服务应用中通过调用鉴权服务来实现校验，但是这样的做法仅仅只是解决了鉴权逻辑的分离，并没有在本质上将这部分不属于业余的逻辑拆分出原有的微服务应用，冗余的拦截器或过滤器依然会存在。\n\n对于这样的问题，更好的做法是通过前置的网关服务来完成这些非业务性质的校验。由于网关服务的加入，外部客户端访问我们的系统已经有了统一入口，既然这些校验与具体业务无关，那何不在请求到达的时候就完成校验和过滤，而不是转发后再过滤而导致更长的请求延迟。同时，通过在网关中完成校验和过滤，微服务应用端就可以去除各种复杂的过滤器和拦截器了，这使得微服务应用的接口开发和测试复杂度也得到了相应的降低。\n\n为了在API网关中实现对客户端请求的校验，我们将需要使用到Spring Cloud Zuul的另外一个核心功能：过滤器。\n\nZuul允许开发者在API网关上通过定义过滤器来实现对请求的拦截与过滤，实现的方法非常简单，我们只需要继承ZuulFilter抽象类并实现它定义的四个抽象函数就可以完成对请求的拦截和过滤了。\n\n# 过滤器的实现\n\n比如下面的代码，我们定义了一个简单的Zuul过滤器，它实现了在请求被路由之前检查HttpServletRequest中是否有accessToken参数，若有就进行路由，若没有就拒绝访问，返回401 Unauthorized错误。\n\n```\npublic class AccessFilter extends ZuulFilter  {\n\n    private static Logger log = LoggerFactory.getLogger(AccessFilter.class);\n\n    @Override\n    public String filterType() {\n        return \"pre\";\n    }\n\n    @Override\n    public int filterOrder() {\n        return 0;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() {\n        RequestContext ctx = RequestContext.getCurrentContext();\n        HttpServletRequest request = ctx.getRequest();\n\n      \tlog.info(\"send {} request to {}\", request.getMethod(), request.getRequestURL().toString());\n\n        Object accessToken = request.getParameter(\"accessToken\");\n        if(accessToken == null) {\n            log.warn(\"access token is empty\");\n            ctx.setSendZuulResponse(false);\n            ctx.setResponseStatusCode(401);\n            return null;\n        }\n        log.info(\"access token ok\");\n        return null;\n    }\n\n}\n```\n\n在上面实现的过滤器代码中，我们通过继承`ZuulFilter`抽象类并重写了下面的四个方法来实现自定义的过滤器。这四个方法分别定义了：\n\n- `filterType`：过滤器的类型，它决定过滤器在请求的哪个生命周期中执行。这里定义为pre，代表会在请求被路由之前执行。\n- `filterOrder`：过滤器的执行顺序。当请求在一个阶段中存在多个过滤器时，需要根据该方法返回的值来依次执行。\n- `shouldFilter`：判断该过滤器是否需要被执行。这里我们直接返回了`true`，因此该过滤器对所有请求都会生效。实际运用中我们可以利用该函数来指定过滤器的有效范围。\n- `run`：过滤器的具体逻辑。这里我们通过`ctx.setSendZuulResponse(false)`令zuul过滤该请求，不对其进行路由，然后通过`ctx.setResponseStatusCode(401)`置了其返回的错误码，当然我们也可以进一步优化我们的返回，比如，通过`ctx.setResponseBody(body)`对返回body内容进行编辑等。\n\n在实现了自定义过滤器之后，它并不会直接生效，我们还需要为其创建具体的Bean才能启动该过滤器，比如，在应用主类中增加如下内容：\n\n```\n@EnableZuulProxy\n@SpringCloudApplication\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tnew SpringApplicationBuilder(Application.class).web(true).run(args);\n\t}\n\n\t@Bean\n\tpublic AccessFilter accessFilter() {\n\t\treturn new AccessFilter();\n\t}\n}\n```\n\n在对`api-gateway`服务完成了上面的改造之后，我们可以重新启动它，并发起下面的请求，对上面定义的过滤器做一个验证：\n\n- `http://localhost:1101/api-a/hello`：返回401错误\n- `http://localhost:1101/api-a/hello&accessToken=token`：正确路由到`hello-service`的`/hello`接口，并返回`Hello World`\n\n到这里，对于Spring Cloud Zuul过滤器的基本功能就以介绍完毕。读者可以根据自己的需要在服务网关上定义一些与业务无关的通用逻辑实现对请求的过滤和拦截，比如：签名校验、权限校验、请求限流等功能。\n","source":"_posts/spring-cloud10.md","raw":"---\ntitle: 10.Spring Cloud构建微服务架构：服务网关（过滤器）【Dalston版】 \ndate: 2018-04-11 16:18:49\ntags:\ncategories: 微服务\n---\n\n![](http://www.wailian.work/images/2018/04/11/824a22acf6f0148cdd9cb70c66800ebaace0dcd92d5b7-QI248r_fw658.jpg)\n\n在前两篇文章：服务网关（基础）、服务网关（路由配置）中，我们了解了Spring Cloud Zuul作为网关所具备的最基本功能：路由。本文我们将具体介绍一下Spring Cloud Zuul的另一项核心功能：过滤器。\n\n# 过滤器的作用\n\n通过上面所述的两篇我们，我们已经能够实现请求的路由功能，所以我们的微服务应用提供的接口就可以通过统一的API网关入口被客户端访问到了。但是，每个客户端用户请求微服务应用提供的接口时，它们的访问权限往往都需要有一定的限制，系统并不会将所有的微服务接口都对它们开放。然而，目前的服务路由并没有限制权限这样的功能，所有请求都会被毫无保留地转发到具体的应用并返回结果，为了实现对客户端请求的安全校验和权限控制，最简单和粗暴的方法就是为每个微服务应用都实现一套用于校验签名和鉴别权限的过滤器或拦截器。不过，这样的做法并不可取，它会增加日后的系统维护难度，因为同一个系统中的各种校验逻辑很多情况下都是大致相同或类似的，这样的实现方式会使得相似的校验逻辑代码被分散到了各个微服务中去，冗余代码的出现是我们不希望看到的。所以，比较好的做法是将这些校验逻辑剥离出去，构建出一个独立的鉴权服务。在完成了剥离之后，有不少开发者会直接在微服务应用中通过调用鉴权服务来实现校验，但是这样的做法仅仅只是解决了鉴权逻辑的分离，并没有在本质上将这部分不属于业余的逻辑拆分出原有的微服务应用，冗余的拦截器或过滤器依然会存在。\n\n对于这样的问题，更好的做法是通过前置的网关服务来完成这些非业务性质的校验。由于网关服务的加入，外部客户端访问我们的系统已经有了统一入口，既然这些校验与具体业务无关，那何不在请求到达的时候就完成校验和过滤，而不是转发后再过滤而导致更长的请求延迟。同时，通过在网关中完成校验和过滤，微服务应用端就可以去除各种复杂的过滤器和拦截器了，这使得微服务应用的接口开发和测试复杂度也得到了相应的降低。\n\n为了在API网关中实现对客户端请求的校验，我们将需要使用到Spring Cloud Zuul的另外一个核心功能：过滤器。\n\nZuul允许开发者在API网关上通过定义过滤器来实现对请求的拦截与过滤，实现的方法非常简单，我们只需要继承ZuulFilter抽象类并实现它定义的四个抽象函数就可以完成对请求的拦截和过滤了。\n\n# 过滤器的实现\n\n比如下面的代码，我们定义了一个简单的Zuul过滤器，它实现了在请求被路由之前检查HttpServletRequest中是否有accessToken参数，若有就进行路由，若没有就拒绝访问，返回401 Unauthorized错误。\n\n```\npublic class AccessFilter extends ZuulFilter  {\n\n    private static Logger log = LoggerFactory.getLogger(AccessFilter.class);\n\n    @Override\n    public String filterType() {\n        return \"pre\";\n    }\n\n    @Override\n    public int filterOrder() {\n        return 0;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() {\n        RequestContext ctx = RequestContext.getCurrentContext();\n        HttpServletRequest request = ctx.getRequest();\n\n      \tlog.info(\"send {} request to {}\", request.getMethod(), request.getRequestURL().toString());\n\n        Object accessToken = request.getParameter(\"accessToken\");\n        if(accessToken == null) {\n            log.warn(\"access token is empty\");\n            ctx.setSendZuulResponse(false);\n            ctx.setResponseStatusCode(401);\n            return null;\n        }\n        log.info(\"access token ok\");\n        return null;\n    }\n\n}\n```\n\n在上面实现的过滤器代码中，我们通过继承`ZuulFilter`抽象类并重写了下面的四个方法来实现自定义的过滤器。这四个方法分别定义了：\n\n- `filterType`：过滤器的类型，它决定过滤器在请求的哪个生命周期中执行。这里定义为pre，代表会在请求被路由之前执行。\n- `filterOrder`：过滤器的执行顺序。当请求在一个阶段中存在多个过滤器时，需要根据该方法返回的值来依次执行。\n- `shouldFilter`：判断该过滤器是否需要被执行。这里我们直接返回了`true`，因此该过滤器对所有请求都会生效。实际运用中我们可以利用该函数来指定过滤器的有效范围。\n- `run`：过滤器的具体逻辑。这里我们通过`ctx.setSendZuulResponse(false)`令zuul过滤该请求，不对其进行路由，然后通过`ctx.setResponseStatusCode(401)`置了其返回的错误码，当然我们也可以进一步优化我们的返回，比如，通过`ctx.setResponseBody(body)`对返回body内容进行编辑等。\n\n在实现了自定义过滤器之后，它并不会直接生效，我们还需要为其创建具体的Bean才能启动该过滤器，比如，在应用主类中增加如下内容：\n\n```\n@EnableZuulProxy\n@SpringCloudApplication\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tnew SpringApplicationBuilder(Application.class).web(true).run(args);\n\t}\n\n\t@Bean\n\tpublic AccessFilter accessFilter() {\n\t\treturn new AccessFilter();\n\t}\n}\n```\n\n在对`api-gateway`服务完成了上面的改造之后，我们可以重新启动它，并发起下面的请求，对上面定义的过滤器做一个验证：\n\n- `http://localhost:1101/api-a/hello`：返回401错误\n- `http://localhost:1101/api-a/hello&accessToken=token`：正确路由到`hello-service`的`/hello`接口，并返回`Hello World`\n\n到这里，对于Spring Cloud Zuul过滤器的基本功能就以介绍完毕。读者可以根据自己的需要在服务网关上定义一些与业务无关的通用逻辑实现对请求的过滤和拦截，比如：签名校验、权限校验、请求限流等功能。\n","slug":"spring-cloud10","published":1,"updated":"2019-12-24T02:00:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jx600170j9kruzoezp8","content":"<p><img src=\"http://www.wailian.work/images/2018/04/11/824a22acf6f0148cdd9cb70c66800ebaace0dcd92d5b7-QI248r_fw658.jpg\" alt=\"\"></p>\n<p>在前两篇文章：服务网关（基础）、服务网关（路由配置）中，我们了解了Spring Cloud Zuul作为网关所具备的最基本功能：路由。本文我们将具体介绍一下Spring Cloud Zuul的另一项核心功能：过滤器。</p>\n<h1 id=\"过滤器的作用\"><a href=\"#过滤器的作用\" class=\"headerlink\" title=\"过滤器的作用\"></a>过滤器的作用</h1><p>通过上面所述的两篇我们，我们已经能够实现请求的路由功能，所以我们的微服务应用提供的接口就可以通过统一的API网关入口被客户端访问到了。但是，每个客户端用户请求微服务应用提供的接口时，它们的访问权限往往都需要有一定的限制，系统并不会将所有的微服务接口都对它们开放。然而，目前的服务路由并没有限制权限这样的功能，所有请求都会被毫无保留地转发到具体的应用并返回结果，为了实现对客户端请求的安全校验和权限控制，最简单和粗暴的方法就是为每个微服务应用都实现一套用于校验签名和鉴别权限的过滤器或拦截器。不过，这样的做法并不可取，它会增加日后的系统维护难度，因为同一个系统中的各种校验逻辑很多情况下都是大致相同或类似的，这样的实现方式会使得相似的校验逻辑代码被分散到了各个微服务中去，冗余代码的出现是我们不希望看到的。所以，比较好的做法是将这些校验逻辑剥离出去，构建出一个独立的鉴权服务。在完成了剥离之后，有不少开发者会直接在微服务应用中通过调用鉴权服务来实现校验，但是这样的做法仅仅只是解决了鉴权逻辑的分离，并没有在本质上将这部分不属于业余的逻辑拆分出原有的微服务应用，冗余的拦截器或过滤器依然会存在。</p>\n<p>对于这样的问题，更好的做法是通过前置的网关服务来完成这些非业务性质的校验。由于网关服务的加入，外部客户端访问我们的系统已经有了统一入口，既然这些校验与具体业务无关，那何不在请求到达的时候就完成校验和过滤，而不是转发后再过滤而导致更长的请求延迟。同时，通过在网关中完成校验和过滤，微服务应用端就可以去除各种复杂的过滤器和拦截器了，这使得微服务应用的接口开发和测试复杂度也得到了相应的降低。</p>\n<p>为了在API网关中实现对客户端请求的校验，我们将需要使用到Spring Cloud Zuul的另外一个核心功能：过滤器。</p>\n<p>Zuul允许开发者在API网关上通过定义过滤器来实现对请求的拦截与过滤，实现的方法非常简单，我们只需要继承ZuulFilter抽象类并实现它定义的四个抽象函数就可以完成对请求的拦截和过滤了。</p>\n<h1 id=\"过滤器的实现\"><a href=\"#过滤器的实现\" class=\"headerlink\" title=\"过滤器的实现\"></a>过滤器的实现</h1><p>比如下面的代码，我们定义了一个简单的Zuul过滤器，它实现了在请求被路由之前检查HttpServletRequest中是否有accessToken参数，若有就进行路由，若没有就拒绝访问，返回401 Unauthorized错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AccessFilter extends ZuulFilter  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static Logger log = LoggerFactory.getLogger(AccessFilter.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String filterType() &#123;</span><br><span class=\"line\">        return &quot;pre&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int filterOrder() &#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean shouldFilter() &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object run() &#123;</span><br><span class=\"line\">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class=\"line\">        HttpServletRequest request = ctx.getRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">      \tlog.info(&quot;send &#123;&#125; request to &#123;&#125;&quot;, request.getMethod(), request.getRequestURL().toString());</span><br><span class=\"line\"></span><br><span class=\"line\">        Object accessToken = request.getParameter(&quot;accessToken&quot;);</span><br><span class=\"line\">        if(accessToken == null) &#123;</span><br><span class=\"line\">            log.warn(&quot;access token is empty&quot;);</span><br><span class=\"line\">            ctx.setSendZuulResponse(false);</span><br><span class=\"line\">            ctx.setResponseStatusCode(401);</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.info(&quot;access token ok&quot;);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面实现的过滤器代码中，我们通过继承<code>ZuulFilter</code>抽象类并重写了下面的四个方法来实现自定义的过滤器。这四个方法分别定义了：</p>\n<ul>\n<li><code>filterType</code>：过滤器的类型，它决定过滤器在请求的哪个生命周期中执行。这里定义为pre，代表会在请求被路由之前执行。</li>\n<li><code>filterOrder</code>：过滤器的执行顺序。当请求在一个阶段中存在多个过滤器时，需要根据该方法返回的值来依次执行。</li>\n<li><code>shouldFilter</code>：判断该过滤器是否需要被执行。这里我们直接返回了<code>true</code>，因此该过滤器对所有请求都会生效。实际运用中我们可以利用该函数来指定过滤器的有效范围。</li>\n<li><code>run</code>：过滤器的具体逻辑。这里我们通过<code>ctx.setSendZuulResponse(false)</code>令zuul过滤该请求，不对其进行路由，然后通过<code>ctx.setResponseStatusCode(401)</code>置了其返回的错误码，当然我们也可以进一步优化我们的返回，比如，通过<code>ctx.setResponseBody(body)</code>对返回body内容进行编辑等。</li>\n</ul>\n<p>在实现了自定义过滤器之后，它并不会直接生效，我们还需要为其创建具体的Bean才能启动该过滤器，比如，在应用主类中增加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableZuulProxy</span><br><span class=\"line\">@SpringCloudApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tnew SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Bean</span><br><span class=\"line\">\tpublic AccessFilter accessFilter() &#123;</span><br><span class=\"line\">\t\treturn new AccessFilter();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在对<code>api-gateway</code>服务完成了上面的改造之后，我们可以重新启动它，并发起下面的请求，对上面定义的过滤器做一个验证：</p>\n<ul>\n<li><code>http://localhost:1101/api-a/hello</code>：返回401错误</li>\n<li><code>http://localhost:1101/api-a/hello&amp;accessToken=token</code>：正确路由到<code>hello-service</code>的<code>/hello</code>接口，并返回<code>Hello World</code></li>\n</ul>\n<p>到这里，对于Spring Cloud Zuul过滤器的基本功能就以介绍完毕。读者可以根据自己的需要在服务网关上定义一些与业务无关的通用逻辑实现对请求的过滤和拦截，比如：签名校验、权限校验、请求限流等功能。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/04/11/824a22acf6f0148cdd9cb70c66800ebaace0dcd92d5b7-QI248r_fw658.jpg\" alt=\"\"></p>\n<p>在前两篇文章：服务网关（基础）、服务网关（路由配置）中，我们了解了Spring Cloud Zuul作为网关所具备的最基本功能：路由。本文我们将具体介绍一下Spring Cloud Zuul的另一项核心功能：过滤器。</p>\n<h1 id=\"过滤器的作用\"><a href=\"#过滤器的作用\" class=\"headerlink\" title=\"过滤器的作用\"></a>过滤器的作用</h1><p>通过上面所述的两篇我们，我们已经能够实现请求的路由功能，所以我们的微服务应用提供的接口就可以通过统一的API网关入口被客户端访问到了。但是，每个客户端用户请求微服务应用提供的接口时，它们的访问权限往往都需要有一定的限制，系统并不会将所有的微服务接口都对它们开放。然而，目前的服务路由并没有限制权限这样的功能，所有请求都会被毫无保留地转发到具体的应用并返回结果，为了实现对客户端请求的安全校验和权限控制，最简单和粗暴的方法就是为每个微服务应用都实现一套用于校验签名和鉴别权限的过滤器或拦截器。不过，这样的做法并不可取，它会增加日后的系统维护难度，因为同一个系统中的各种校验逻辑很多情况下都是大致相同或类似的，这样的实现方式会使得相似的校验逻辑代码被分散到了各个微服务中去，冗余代码的出现是我们不希望看到的。所以，比较好的做法是将这些校验逻辑剥离出去，构建出一个独立的鉴权服务。在完成了剥离之后，有不少开发者会直接在微服务应用中通过调用鉴权服务来实现校验，但是这样的做法仅仅只是解决了鉴权逻辑的分离，并没有在本质上将这部分不属于业余的逻辑拆分出原有的微服务应用，冗余的拦截器或过滤器依然会存在。</p>\n<p>对于这样的问题，更好的做法是通过前置的网关服务来完成这些非业务性质的校验。由于网关服务的加入，外部客户端访问我们的系统已经有了统一入口，既然这些校验与具体业务无关，那何不在请求到达的时候就完成校验和过滤，而不是转发后再过滤而导致更长的请求延迟。同时，通过在网关中完成校验和过滤，微服务应用端就可以去除各种复杂的过滤器和拦截器了，这使得微服务应用的接口开发和测试复杂度也得到了相应的降低。</p>\n<p>为了在API网关中实现对客户端请求的校验，我们将需要使用到Spring Cloud Zuul的另外一个核心功能：过滤器。</p>\n<p>Zuul允许开发者在API网关上通过定义过滤器来实现对请求的拦截与过滤，实现的方法非常简单，我们只需要继承ZuulFilter抽象类并实现它定义的四个抽象函数就可以完成对请求的拦截和过滤了。</p>\n<h1 id=\"过滤器的实现\"><a href=\"#过滤器的实现\" class=\"headerlink\" title=\"过滤器的实现\"></a>过滤器的实现</h1><p>比如下面的代码，我们定义了一个简单的Zuul过滤器，它实现了在请求被路由之前检查HttpServletRequest中是否有accessToken参数，若有就进行路由，若没有就拒绝访问，返回401 Unauthorized错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AccessFilter extends ZuulFilter  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static Logger log = LoggerFactory.getLogger(AccessFilter.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String filterType() &#123;</span><br><span class=\"line\">        return &quot;pre&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int filterOrder() &#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean shouldFilter() &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object run() &#123;</span><br><span class=\"line\">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class=\"line\">        HttpServletRequest request = ctx.getRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">      \tlog.info(&quot;send &#123;&#125; request to &#123;&#125;&quot;, request.getMethod(), request.getRequestURL().toString());</span><br><span class=\"line\"></span><br><span class=\"line\">        Object accessToken = request.getParameter(&quot;accessToken&quot;);</span><br><span class=\"line\">        if(accessToken == null) &#123;</span><br><span class=\"line\">            log.warn(&quot;access token is empty&quot;);</span><br><span class=\"line\">            ctx.setSendZuulResponse(false);</span><br><span class=\"line\">            ctx.setResponseStatusCode(401);</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.info(&quot;access token ok&quot;);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面实现的过滤器代码中，我们通过继承<code>ZuulFilter</code>抽象类并重写了下面的四个方法来实现自定义的过滤器。这四个方法分别定义了：</p>\n<ul>\n<li><code>filterType</code>：过滤器的类型，它决定过滤器在请求的哪个生命周期中执行。这里定义为pre，代表会在请求被路由之前执行。</li>\n<li><code>filterOrder</code>：过滤器的执行顺序。当请求在一个阶段中存在多个过滤器时，需要根据该方法返回的值来依次执行。</li>\n<li><code>shouldFilter</code>：判断该过滤器是否需要被执行。这里我们直接返回了<code>true</code>，因此该过滤器对所有请求都会生效。实际运用中我们可以利用该函数来指定过滤器的有效范围。</li>\n<li><code>run</code>：过滤器的具体逻辑。这里我们通过<code>ctx.setSendZuulResponse(false)</code>令zuul过滤该请求，不对其进行路由，然后通过<code>ctx.setResponseStatusCode(401)</code>置了其返回的错误码，当然我们也可以进一步优化我们的返回，比如，通过<code>ctx.setResponseBody(body)</code>对返回body内容进行编辑等。</li>\n</ul>\n<p>在实现了自定义过滤器之后，它并不会直接生效，我们还需要为其创建具体的Bean才能启动该过滤器，比如，在应用主类中增加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableZuulProxy</span><br><span class=\"line\">@SpringCloudApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tnew SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Bean</span><br><span class=\"line\">\tpublic AccessFilter accessFilter() &#123;</span><br><span class=\"line\">\t\treturn new AccessFilter();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在对<code>api-gateway</code>服务完成了上面的改造之后，我们可以重新启动它，并发起下面的请求，对上面定义的过滤器做一个验证：</p>\n<ul>\n<li><code>http://localhost:1101/api-a/hello</code>：返回401错误</li>\n<li><code>http://localhost:1101/api-a/hello&amp;accessToken=token</code>：正确路由到<code>hello-service</code>的<code>/hello</code>接口，并返回<code>Hello World</code></li>\n</ul>\n<p>到这里，对于Spring Cloud Zuul过滤器的基本功能就以介绍完毕。读者可以根据自己的需要在服务网关上定义一些与业务无关的通用逻辑实现对请求的过滤和拦截，比如：签名校验、权限校验、请求限流等功能。</p>\n"},{"title":"2.Spring Cloud：服务消费（基础）【Dalston版】","date":"2018-01-08T08:38:41.000Z","top":1,"_content":"\n![](http://www.wailian.work/images/2018/04/11/b175ccda74ff9615e7c170c40cccdef16a8c1a9c92ef3-tdFa3C_fw658.jpg)\n\n> 通过上一篇《Spring Cloud：服务注册与发现》我们已经成功地将服务提供者：eureka-client注册到了Eureka服务注册中心上了，同时我们也通过DiscoveryClient接口的getServices获取了当前客户端缓存的所有服务清单，那么接下来我们要学习的就是：如何去消费服务器提供者的接口？\n\n# 使用LoadBalancerClient\n\n在Spring Cloud Commons中提供了大量的与服务治理相关的抽象接口，包括DiscoveryClient、这里我们即将介绍的LoadBalancerClient等。对于这些接口的定义我们在上一篇介绍服务注册与发现时已经说过，Spring Cloud做这一层抽象，很好的解耦了服务治理体系，使得我们可以轻易的替换不同的服务治理设施。\n\n从LoadBalancerClient接口的命名中，我们就知道这是一个负载均衡客户端的抽象定义，下面我们就看看如何使用Spring Cloud提供的负载均衡器客户端接口来实现服务的消费。\n\n下面的例子，我们将利用上一篇中构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。\n\n我们先来创建一个服务消费者工程，命名为：eureka-consumer。并在pom.xml中引入依赖（这里省略了parent和dependencyManagement的配置）：\n\n```\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-eureka</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n</dependencies>\n```\n\n配置application.properties，指定eureka注册中心的地址：\n\n```\nspring.application.name=eureka-consumer\nserver.port=2101\neureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/\n```\n\n创建应用主类。初始化RestTemplate，用来真正发起REST请求。@EnableDiscoveryClient注解用来将当前应用加入到服务治理体系中。\n\n```\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class Application {\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Application.class).web(true).run(args);\n    }\n}\n```\n\n创建一个接口用来消费eureka-client提供的接口：\n\n```\n@RestController\npublic class DcController {\n    @Autowired\n    LoadBalancerClient loadBalancerClient;\n    @Autowired\n    RestTemplate restTemplate;\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        ServiceInstance serviceInstance = loadBalancerClient.choose(\"eureka-client\");\n        String url = \"http://\" + serviceInstance.getHost() + \":\" + serviceInstance.getPort() + \"/dc\";\n        System.out.println(url);\n        return restTemplate.getForObject(url, String.class);\n    }\n}\n```\n\n可以看到这里，我们注入了LoadBalancerClient和RestTemplate，并在/consumer接口的实现中，先通过loadBalancerClient的choose函数来负载均衡的选出一个eureka-client的服务实例，这个服务实例的基本信息存储在ServiceInstance中，然后通过这些对象中的信息拼接出访问/dc接口的详细地址，最后再利用RestTemplate对象实现对服务提供者接口的调用。\n\n在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer服务是如何消费eureka-client服务的/dc接口的。\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","source":"_posts/spring-cloud2.md","raw":"---\ntitle: 2.Spring Cloud：服务消费（基础）【Dalston版】\ndate: 2018-01-08 16:38:41\ntop: 1\ncategories: 微服务\n---\n\n![](http://www.wailian.work/images/2018/04/11/b175ccda74ff9615e7c170c40cccdef16a8c1a9c92ef3-tdFa3C_fw658.jpg)\n\n> 通过上一篇《Spring Cloud：服务注册与发现》我们已经成功地将服务提供者：eureka-client注册到了Eureka服务注册中心上了，同时我们也通过DiscoveryClient接口的getServices获取了当前客户端缓存的所有服务清单，那么接下来我们要学习的就是：如何去消费服务器提供者的接口？\n\n# 使用LoadBalancerClient\n\n在Spring Cloud Commons中提供了大量的与服务治理相关的抽象接口，包括DiscoveryClient、这里我们即将介绍的LoadBalancerClient等。对于这些接口的定义我们在上一篇介绍服务注册与发现时已经说过，Spring Cloud做这一层抽象，很好的解耦了服务治理体系，使得我们可以轻易的替换不同的服务治理设施。\n\n从LoadBalancerClient接口的命名中，我们就知道这是一个负载均衡客户端的抽象定义，下面我们就看看如何使用Spring Cloud提供的负载均衡器客户端接口来实现服务的消费。\n\n下面的例子，我们将利用上一篇中构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。\n\n我们先来创建一个服务消费者工程，命名为：eureka-consumer。并在pom.xml中引入依赖（这里省略了parent和dependencyManagement的配置）：\n\n```\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-eureka</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n</dependencies>\n```\n\n配置application.properties，指定eureka注册中心的地址：\n\n```\nspring.application.name=eureka-consumer\nserver.port=2101\neureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/\n```\n\n创建应用主类。初始化RestTemplate，用来真正发起REST请求。@EnableDiscoveryClient注解用来将当前应用加入到服务治理体系中。\n\n```\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class Application {\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Application.class).web(true).run(args);\n    }\n}\n```\n\n创建一个接口用来消费eureka-client提供的接口：\n\n```\n@RestController\npublic class DcController {\n    @Autowired\n    LoadBalancerClient loadBalancerClient;\n    @Autowired\n    RestTemplate restTemplate;\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        ServiceInstance serviceInstance = loadBalancerClient.choose(\"eureka-client\");\n        String url = \"http://\" + serviceInstance.getHost() + \":\" + serviceInstance.getPort() + \"/dc\";\n        System.out.println(url);\n        return restTemplate.getForObject(url, String.class);\n    }\n}\n```\n\n可以看到这里，我们注入了LoadBalancerClient和RestTemplate，并在/consumer接口的实现中，先通过loadBalancerClient的choose函数来负载均衡的选出一个eureka-client的服务实例，这个服务实例的基本信息存储在ServiceInstance中，然后通过这些对象中的信息拼接出访问/dc接口的详细地址，最后再利用RestTemplate对象实现对服务提供者接口的调用。\n\n在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer服务是如何消费eureka-client服务的/dc接口的。\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","slug":"spring-cloud2","published":1,"updated":"2019-12-24T02:00:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jx800190j9k2gx8afze","content":"<p><img src=\"http://www.wailian.work/images/2018/04/11/b175ccda74ff9615e7c170c40cccdef16a8c1a9c92ef3-tdFa3C_fw658.jpg\" alt=\"\"></p>\n<blockquote>\n<p>通过上一篇《Spring Cloud：服务注册与发现》我们已经成功地将服务提供者：eureka-client注册到了Eureka服务注册中心上了，同时我们也通过DiscoveryClient接口的getServices获取了当前客户端缓存的所有服务清单，那么接下来我们要学习的就是：如何去消费服务器提供者的接口？</p>\n</blockquote>\n<h1 id=\"使用LoadBalancerClient\"><a href=\"#使用LoadBalancerClient\" class=\"headerlink\" title=\"使用LoadBalancerClient\"></a>使用LoadBalancerClient</h1><p>在Spring Cloud Commons中提供了大量的与服务治理相关的抽象接口，包括DiscoveryClient、这里我们即将介绍的LoadBalancerClient等。对于这些接口的定义我们在上一篇介绍服务注册与发现时已经说过，Spring Cloud做这一层抽象，很好的解耦了服务治理体系，使得我们可以轻易的替换不同的服务治理设施。</p>\n<p>从LoadBalancerClient接口的命名中，我们就知道这是一个负载均衡客户端的抽象定义，下面我们就看看如何使用Spring Cloud提供的负载均衡器客户端接口来实现服务的消费。</p>\n<p>下面的例子，我们将利用上一篇中构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。</p>\n<p>我们先来创建一个服务消费者工程，命名为：eureka-consumer。并在pom.xml中引入依赖（这里省略了parent和dependencyManagement的配置）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<p>配置application.properties，指定eureka注册中心的地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-consumer</span><br><span class=\"line\">server.port=2101</span><br><span class=\"line\">eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/</span><br></pre></td></tr></table></figure>\n<p>创建应用主类。初始化RestTemplate，用来真正发起REST请求。@EnableDiscoveryClient注解用来将当前应用加入到服务治理体系中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public RestTemplate restTemplate() &#123;</span><br><span class=\"line\">        return new RestTemplate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建一个接口用来消费eureka-client提供的接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class DcController &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    LoadBalancerClient loadBalancerClient;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    RestTemplate restTemplate;</span><br><span class=\"line\">    @GetMapping(&quot;/consumer&quot;)</span><br><span class=\"line\">    public String dc() &#123;</span><br><span class=\"line\">        ServiceInstance serviceInstance = loadBalancerClient.choose(&quot;eureka-client&quot;);</span><br><span class=\"line\">        String url = &quot;http://&quot; + serviceInstance.getHost() + &quot;:&quot; + serviceInstance.getPort() + &quot;/dc&quot;;</span><br><span class=\"line\">        System.out.println(url);</span><br><span class=\"line\">        return restTemplate.getForObject(url, String.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这里，我们注入了LoadBalancerClient和RestTemplate，并在/consumer接口的实现中，先通过loadBalancerClient的choose函数来负载均衡的选出一个eureka-client的服务实例，这个服务实例的基本信息存储在ServiceInstance中，然后通过这些对象中的信息拼接出访问/dc接口的详细地址，最后再利用RestTemplate对象实现对服务提供者接口的调用。</p>\n<p>在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer都启动起来，然后访问<a href=\"http://localhost:2101/consumer\" target=\"_blank\" rel=\"noopener\">http://localhost:2101/consumer</a> ，来跟踪观察eureka-consumer服务是如何消费eureka-client服务的/dc接口的。</p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/04/11/b175ccda74ff9615e7c170c40cccdef16a8c1a9c92ef3-tdFa3C_fw658.jpg\" alt=\"\"></p>\n<blockquote>\n<p>通过上一篇《Spring Cloud：服务注册与发现》我们已经成功地将服务提供者：eureka-client注册到了Eureka服务注册中心上了，同时我们也通过DiscoveryClient接口的getServices获取了当前客户端缓存的所有服务清单，那么接下来我们要学习的就是：如何去消费服务器提供者的接口？</p>\n</blockquote>\n<h1 id=\"使用LoadBalancerClient\"><a href=\"#使用LoadBalancerClient\" class=\"headerlink\" title=\"使用LoadBalancerClient\"></a>使用LoadBalancerClient</h1><p>在Spring Cloud Commons中提供了大量的与服务治理相关的抽象接口，包括DiscoveryClient、这里我们即将介绍的LoadBalancerClient等。对于这些接口的定义我们在上一篇介绍服务注册与发现时已经说过，Spring Cloud做这一层抽象，很好的解耦了服务治理体系，使得我们可以轻易的替换不同的服务治理设施。</p>\n<p>从LoadBalancerClient接口的命名中，我们就知道这是一个负载均衡客户端的抽象定义，下面我们就看看如何使用Spring Cloud提供的负载均衡器客户端接口来实现服务的消费。</p>\n<p>下面的例子，我们将利用上一篇中构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。</p>\n<p>我们先来创建一个服务消费者工程，命名为：eureka-consumer。并在pom.xml中引入依赖（这里省略了parent和dependencyManagement的配置）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<p>配置application.properties，指定eureka注册中心的地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-consumer</span><br><span class=\"line\">server.port=2101</span><br><span class=\"line\">eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/</span><br></pre></td></tr></table></figure>\n<p>创建应用主类。初始化RestTemplate，用来真正发起REST请求。@EnableDiscoveryClient注解用来将当前应用加入到服务治理体系中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public RestTemplate restTemplate() &#123;</span><br><span class=\"line\">        return new RestTemplate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建一个接口用来消费eureka-client提供的接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class DcController &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    LoadBalancerClient loadBalancerClient;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    RestTemplate restTemplate;</span><br><span class=\"line\">    @GetMapping(&quot;/consumer&quot;)</span><br><span class=\"line\">    public String dc() &#123;</span><br><span class=\"line\">        ServiceInstance serviceInstance = loadBalancerClient.choose(&quot;eureka-client&quot;);</span><br><span class=\"line\">        String url = &quot;http://&quot; + serviceInstance.getHost() + &quot;:&quot; + serviceInstance.getPort() + &quot;/dc&quot;;</span><br><span class=\"line\">        System.out.println(url);</span><br><span class=\"line\">        return restTemplate.getForObject(url, String.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这里，我们注入了LoadBalancerClient和RestTemplate，并在/consumer接口的实现中，先通过loadBalancerClient的choose函数来负载均衡的选出一个eureka-client的服务实例，这个服务实例的基本信息存储在ServiceInstance中，然后通过这些对象中的信息拼接出访问/dc接口的详细地址，最后再利用RestTemplate对象实现对服务提供者接口的调用。</p>\n<p>在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer都启动起来，然后访问<a href=\"http://localhost:2101/consumer\" target=\"_blank\" rel=\"noopener\">http://localhost:2101/consumer</a> ，来跟踪观察eureka-consumer服务是如何消费eureka-client服务的/dc接口的。</p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n"},{"title":"3.Spring Cloud：服务消费（Ribbon）【Dalston版】","date":"2018-01-08T08:56:06.000Z","top":1,"_content":"\n![](http://www.wailian.work/images/2018/04/11/c823eb1967ed6f4573223516337156c2323dc33f1ce08-d4m6uZ_fw658.jpg)\n\n> 通过上一篇《Spring Cloud：服务消费（基础）》，我们已经学会如何通过LoadBalancerClient接口来获取某个服务的具体实例，并根据实例信息来发起服务接口消费请求。但是这样的做法需要我们手工的去编写服务选取、链接拼接等繁琐的工作，对于开发人员来说非常的不友好。所以，下来我们看看Spring Cloud中针对客户端负载均衡的工具包：Spring Cloud Ribbon\n\n# 动手试一试\n\n下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下：\n\n- 根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-ribbon。在pom.xml中增加下面的依赖：\n\n```\n<dependencies>\n    ...\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-ribbon</artifactId>\n    </dependency>\n</dependencies>\n```\n\n- 修改应用主类。为RestTemplate增加@LoadBalanced注解：\n\n```\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class Application {\n    @Bean\n    @LoadBalanced\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Application.class).web(true).run(args);\n    }\n}\n```\n\n- 修改Controller。去掉原来通过LoadBalancerClient选取实例和拼接URL的步骤，直接通过RestTemplate发起请求。\n\n```\n@RestController\npublic class DcController {\n    @Autowired\n    RestTemplate restTemplate;\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        return restTemplate.getForObject(\"http://eureka-client/dc\", String.class);\n    }\n}\n```\n\n可以看到这里，我们除了去掉了原来与LoadBalancerClient相关的逻辑之外，对于RestTemplate的使用，我们的第一个url参数有一些特别。这里请求的host位置并没有使用一个具体的IP地址和端口的形式，而是采用了服务名的方式组成。那么这样的请求为什么可以调用成功呢？因为Spring Cloud Ribbon有一个拦截器，它能够在这里进行实际调用的时候，自动的去选取服务实例，并将实际要请求的IP地址和端口替换这里的服务名，从而完成服务接口的调用。\n\n在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-ribbon都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer-ribbon服务是如何消费eureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","source":"_posts/spring-cloud3.md","raw":"---\ntitle: 3.Spring Cloud：服务消费（Ribbon）【Dalston版】\ndate: 2018-01-08 16:56:06\ntop: 1\ncategories: 微服务\n---\n\n![](http://www.wailian.work/images/2018/04/11/c823eb1967ed6f4573223516337156c2323dc33f1ce08-d4m6uZ_fw658.jpg)\n\n> 通过上一篇《Spring Cloud：服务消费（基础）》，我们已经学会如何通过LoadBalancerClient接口来获取某个服务的具体实例，并根据实例信息来发起服务接口消费请求。但是这样的做法需要我们手工的去编写服务选取、链接拼接等繁琐的工作，对于开发人员来说非常的不友好。所以，下来我们看看Spring Cloud中针对客户端负载均衡的工具包：Spring Cloud Ribbon\n\n# 动手试一试\n\n下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下：\n\n- 根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-ribbon。在pom.xml中增加下面的依赖：\n\n```\n<dependencies>\n    ...\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-ribbon</artifactId>\n    </dependency>\n</dependencies>\n```\n\n- 修改应用主类。为RestTemplate增加@LoadBalanced注解：\n\n```\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class Application {\n    @Bean\n    @LoadBalanced\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Application.class).web(true).run(args);\n    }\n}\n```\n\n- 修改Controller。去掉原来通过LoadBalancerClient选取实例和拼接URL的步骤，直接通过RestTemplate发起请求。\n\n```\n@RestController\npublic class DcController {\n    @Autowired\n    RestTemplate restTemplate;\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        return restTemplate.getForObject(\"http://eureka-client/dc\", String.class);\n    }\n}\n```\n\n可以看到这里，我们除了去掉了原来与LoadBalancerClient相关的逻辑之外，对于RestTemplate的使用，我们的第一个url参数有一些特别。这里请求的host位置并没有使用一个具体的IP地址和端口的形式，而是采用了服务名的方式组成。那么这样的请求为什么可以调用成功呢？因为Spring Cloud Ribbon有一个拦截器，它能够在这里进行实际调用的时候，自动的去选取服务实例，并将实际要请求的IP地址和端口替换这里的服务名，从而完成服务接口的调用。\n\n在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-ribbon都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer-ribbon服务是如何消费eureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","slug":"spring-cloud3","published":1,"updated":"2019-12-24T02:00:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jx9001a0j9khwlhnghl","content":"<p><img src=\"http://www.wailian.work/images/2018/04/11/c823eb1967ed6f4573223516337156c2323dc33f1ce08-d4m6uZ_fw658.jpg\" alt=\"\"></p>\n<blockquote>\n<p>通过上一篇《Spring Cloud：服务消费（基础）》，我们已经学会如何通过LoadBalancerClient接口来获取某个服务的具体实例，并根据实例信息来发起服务接口消费请求。但是这样的做法需要我们手工的去编写服务选取、链接拼接等繁琐的工作，对于开发人员来说非常的不友好。所以，下来我们看看Spring Cloud中针对客户端负载均衡的工具包：Spring Cloud Ribbon</p>\n</blockquote>\n<h1 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h1><p>下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下：</p>\n<ul>\n<li>根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-ribbon。在pom.xml中增加下面的依赖：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改应用主类。为RestTemplate增加@LoadBalanced注解：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    @LoadBalanced</span><br><span class=\"line\">    public RestTemplate restTemplate() &#123;</span><br><span class=\"line\">        return new RestTemplate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改Controller。去掉原来通过LoadBalancerClient选取实例和拼接URL的步骤，直接通过RestTemplate发起请求。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class DcController &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    RestTemplate restTemplate;</span><br><span class=\"line\">    @GetMapping(&quot;/consumer&quot;)</span><br><span class=\"line\">    public String dc() &#123;</span><br><span class=\"line\">        return restTemplate.getForObject(&quot;http://eureka-client/dc&quot;, String.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这里，我们除了去掉了原来与LoadBalancerClient相关的逻辑之外，对于RestTemplate的使用，我们的第一个url参数有一些特别。这里请求的host位置并没有使用一个具体的IP地址和端口的形式，而是采用了服务名的方式组成。那么这样的请求为什么可以调用成功呢？因为Spring Cloud Ribbon有一个拦截器，它能够在这里进行实际调用的时候，自动的去选取服务实例，并将实际要请求的IP地址和端口替换这里的服务名，从而完成服务接口的调用。</p>\n<p>在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-ribbon都启动起来，然后访问<a href=\"http://localhost:2101/consumer\" target=\"_blank\" rel=\"noopener\">http://localhost:2101/consumer</a> ，来跟踪观察eureka-consumer-ribbon服务是如何消费eureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。</p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/04/11/c823eb1967ed6f4573223516337156c2323dc33f1ce08-d4m6uZ_fw658.jpg\" alt=\"\"></p>\n<blockquote>\n<p>通过上一篇《Spring Cloud：服务消费（基础）》，我们已经学会如何通过LoadBalancerClient接口来获取某个服务的具体实例，并根据实例信息来发起服务接口消费请求。但是这样的做法需要我们手工的去编写服务选取、链接拼接等繁琐的工作，对于开发人员来说非常的不友好。所以，下来我们看看Spring Cloud中针对客户端负载均衡的工具包：Spring Cloud Ribbon</p>\n</blockquote>\n<h1 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h1><p>下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下：</p>\n<ul>\n<li>根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-ribbon。在pom.xml中增加下面的依赖：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改应用主类。为RestTemplate增加@LoadBalanced注解：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    @LoadBalanced</span><br><span class=\"line\">    public RestTemplate restTemplate() &#123;</span><br><span class=\"line\">        return new RestTemplate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改Controller。去掉原来通过LoadBalancerClient选取实例和拼接URL的步骤，直接通过RestTemplate发起请求。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class DcController &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    RestTemplate restTemplate;</span><br><span class=\"line\">    @GetMapping(&quot;/consumer&quot;)</span><br><span class=\"line\">    public String dc() &#123;</span><br><span class=\"line\">        return restTemplate.getForObject(&quot;http://eureka-client/dc&quot;, String.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这里，我们除了去掉了原来与LoadBalancerClient相关的逻辑之外，对于RestTemplate的使用，我们的第一个url参数有一些特别。这里请求的host位置并没有使用一个具体的IP地址和端口的形式，而是采用了服务名的方式组成。那么这样的请求为什么可以调用成功呢？因为Spring Cloud Ribbon有一个拦截器，它能够在这里进行实际调用的时候，自动的去选取服务实例，并将实际要请求的IP地址和端口替换这里的服务名，从而完成服务接口的调用。</p>\n<p>在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-ribbon都启动起来，然后访问<a href=\"http://localhost:2101/consumer\" target=\"_blank\" rel=\"noopener\">http://localhost:2101/consumer</a> ，来跟踪观察eureka-consumer-ribbon服务是如何消费eureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。</p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n"},{"title":"Spring Boot多环境配置","date":"2017-12-01T00:49:43.000Z","_content":"![](http://s1.wailian.download/2018/01/18/30861ad3a953b85edb424fe6dcf4e3198bdeaf28884b8-7xLVBN_fw658.jpg)\n我们在开发Spring Boot应用时，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。\n\n\n对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外，或者说更加简单。\n\n\n在Spring Boot中多环境配置文件名需要满足 `application-{profile}.properties`的格式，其中`{profile}`对应你的环境标识，比如：\n\n```\napplication-dev.properties：开发环境 \napplication-test.properties：测试环境 \napplication-prod.properties：生产环境\n```\n\n至于哪个具体的配置文件会被加载，需要在`application.properties`文件中通过`spring.profiles.active`属性来设置，其值对应`{profile}`值。\n\n如：`spring.profiles.active=test`就会加载`application-test.properties`配置文件内容\n\n下面，以不同环境配置不同的服务端口为例，进行样例实验。\n\n针对各环境新建不同的配置文件`application-dev.properties`、`application-test.properties`、`application-prod.properties`\n\n测试不同配置的加载: \n执行```java -jar xxx.jar --spring.profiles.active=prod```也就是生产环境的配置`(prod)`按照上面的实验，可以如下总结多环境的配置思路：\n\n**`application.properties`中配置通用内容，并设置`spring.profiles.active=dev`，以开发环境为默认配置**\n**`application-{profile}.properties`中配置各个环境不同的内容**\n**通过命令行方式去激活不同环境的配置**\n\n转载自[程序猿DD-翟永超](http://blog.didispace.com/springbootproperties/)\n","source":"_posts/spring-boot-active.md","raw":"---\ntitle: Spring Boot多环境配置\ndate: 2017-12-01 08:49:43\ntags:\n---\n![](http://s1.wailian.download/2018/01/18/30861ad3a953b85edb424fe6dcf4e3198bdeaf28884b8-7xLVBN_fw658.jpg)\n我们在开发Spring Boot应用时，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。\n\n\n对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外，或者说更加简单。\n\n\n在Spring Boot中多环境配置文件名需要满足 `application-{profile}.properties`的格式，其中`{profile}`对应你的环境标识，比如：\n\n```\napplication-dev.properties：开发环境 \napplication-test.properties：测试环境 \napplication-prod.properties：生产环境\n```\n\n至于哪个具体的配置文件会被加载，需要在`application.properties`文件中通过`spring.profiles.active`属性来设置，其值对应`{profile}`值。\n\n如：`spring.profiles.active=test`就会加载`application-test.properties`配置文件内容\n\n下面，以不同环境配置不同的服务端口为例，进行样例实验。\n\n针对各环境新建不同的配置文件`application-dev.properties`、`application-test.properties`、`application-prod.properties`\n\n测试不同配置的加载: \n执行```java -jar xxx.jar --spring.profiles.active=prod```也就是生产环境的配置`(prod)`按照上面的实验，可以如下总结多环境的配置思路：\n\n**`application.properties`中配置通用内容，并设置`spring.profiles.active=dev`，以开发环境为默认配置**\n**`application-{profile}.properties`中配置各个环境不同的内容**\n**通过命令行方式去激活不同环境的配置**\n\n转载自[程序猿DD-翟永超](http://blog.didispace.com/springbootproperties/)\n","slug":"spring-boot-active","published":1,"updated":"2019-12-24T02:00:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jxa001b0j9ktnbz3zkx","content":"<p><img src=\"http://s1.wailian.download/2018/01/18/30861ad3a953b85edb424fe6dcf4e3198bdeaf28884b8-7xLVBN_fw658.jpg\" alt=\"\"><br>我们在开发Spring Boot应用时，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。</p>\n<p>对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外，或者说更加简单。</p>\n<p>在Spring Boot中多环境配置文件名需要满足 <code>application-{profile}.properties</code>的格式，其中<code>{profile}</code>对应你的环境标识，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">application-dev.properties：开发环境 </span><br><span class=\"line\">application-test.properties：测试环境 </span><br><span class=\"line\">application-prod.properties：生产环境</span><br></pre></td></tr></table></figure>\n<p>至于哪个具体的配置文件会被加载，需要在<code>application.properties</code>文件中通过<code>spring.profiles.active</code>属性来设置，其值对应<code>{profile}</code>值。</p>\n<p>如：<code>spring.profiles.active=test</code>就会加载<code>application-test.properties</code>配置文件内容</p>\n<p>下面，以不同环境配置不同的服务端口为例，进行样例实验。</p>\n<p>针对各环境新建不同的配置文件<code>application-dev.properties</code>、<code>application-test.properties</code>、<code>application-prod.properties</code></p>\n<p>测试不同配置的加载:<br>执行<code>java -jar xxx.jar --spring.profiles.active=prod</code>也就是生产环境的配置<code>(prod)</code>按照上面的实验，可以如下总结多环境的配置思路：</p>\n<p><strong><code>application.properties</code>中配置通用内容，并设置<code>spring.profiles.active=dev</code>，以开发环境为默认配置</strong><br><strong><code>application-{profile}.properties</code>中配置各个环境不同的内容</strong><br><strong>通过命令行方式去激活不同环境的配置</strong></p>\n<p>转载自<a href=\"http://blog.didispace.com/springbootproperties/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://s1.wailian.download/2018/01/18/30861ad3a953b85edb424fe6dcf4e3198bdeaf28884b8-7xLVBN_fw658.jpg\" alt=\"\"><br>我们在开发Spring Boot应用时，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。</p>\n<p>对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外，或者说更加简单。</p>\n<p>在Spring Boot中多环境配置文件名需要满足 <code>application-{profile}.properties</code>的格式，其中<code>{profile}</code>对应你的环境标识，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">application-dev.properties：开发环境 </span><br><span class=\"line\">application-test.properties：测试环境 </span><br><span class=\"line\">application-prod.properties：生产环境</span><br></pre></td></tr></table></figure>\n<p>至于哪个具体的配置文件会被加载，需要在<code>application.properties</code>文件中通过<code>spring.profiles.active</code>属性来设置，其值对应<code>{profile}</code>值。</p>\n<p>如：<code>spring.profiles.active=test</code>就会加载<code>application-test.properties</code>配置文件内容</p>\n<p>下面，以不同环境配置不同的服务端口为例，进行样例实验。</p>\n<p>针对各环境新建不同的配置文件<code>application-dev.properties</code>、<code>application-test.properties</code>、<code>application-prod.properties</code></p>\n<p>测试不同配置的加载:<br>执行<code>java -jar xxx.jar --spring.profiles.active=prod</code>也就是生产环境的配置<code>(prod)</code>按照上面的实验，可以如下总结多环境的配置思路：</p>\n<p><strong><code>application.properties</code>中配置通用内容，并设置<code>spring.profiles.active=dev</code>，以开发环境为默认配置</strong><br><strong><code>application-{profile}.properties</code>中配置各个环境不同的内容</strong><br><strong>通过命令行方式去激活不同环境的配置</strong></p>\n<p>转载自<a href=\"http://blog.didispace.com/springbootproperties/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n"},{"title":"4.Spring Cloud：服务消费（Feign）【Dalston版】","date":"2018-01-08T09:02:08.000Z","top":1,"_content":"\n![](http://www.wailian.work/images/2018/04/11/82e28073c162d7fdb959807c8037c57b201707ba130dfa-J5nIN0_fw658.jpg)\n\n> 通过前两篇《Spring Cloud：服务消费（基础）》和《Spring Cloud：服务消费（Ribbon）》，我们已经学会了在Spring Cloud中基本的服务调用方式。本文我们将继续介绍Spring Cloud中的另外一个服务消费的工具：Spring Cloud Feign\n\n# Spring Cloud Feign\n\nSpring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。\n\n下面，我们通过一个例子来展现Feign如何方便的声明对eureka-client服务的定义和调用。\n\n# 动手试一试\n\n下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下：\n\n- 根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-feign。在pom.xml中增加下面的依赖：\n\n```\n<dependencies>\n    ...\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-feign</artifactId>\n    </dependency>\n</dependencies>\n```\n\n- 修改应用主类。通过@EnableFeignClients注解开启扫描Spring Cloud Feign客户端的功能：\n\n```\n@EnableFeignClients\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Application.class).web(true).run(args);\n    }\n}\n```\n\n- 创建一个Feign的客户端接口定义。使用@FeignClient注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口，比如下面就是绑定eureka-client服务的/dc接口的例子：\n\n```\n@FeignClient(\"eureka-client\")\npublic interface DcClient {\n    @GetMapping(\"/dc\")\n    String consumer();\n}\n```\n\n- 修改Controller。通过定义的feign客户端来调用服务提供方的接口：\n\n```\n@RestController\npublic class DcController {\n    @Autowired\n    DcClient dcClient;\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        return dcClient.consumer();\n    }\n}\n```\n\n通过Spring Cloud Feign来实现服务调用的方式更加简单了，通过@FeignClient定义的接口来统一的生命我们需要依赖的微服务接口。而在具体使用的时候就跟调用本地方法一点的进行调用即可。由于Feign是基于Ribbon实现的，所以它自带了客户端负载均衡功能，也可以通过Ribbon的IRule进行策略扩展。另外，Feign还整合的Hystrix来实现服务的容错保护，在Dalston版本中，Feign的Hystrix默认是关闭的。待后文介绍Hystrix带领大家入门之后，我们再结合介绍Feign中的Hystrix以及配置方式。\n\n在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-feign都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer-feign服务是如何消费eureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","source":"_posts/spring-cloud4.md","raw":"---\ntitle: 4.Spring Cloud：服务消费（Feign）【Dalston版】\ndate: 2018-01-08 17:02:08\ntop: 1\ncategories: 微服务\n---\n\n![](http://www.wailian.work/images/2018/04/11/82e28073c162d7fdb959807c8037c57b201707ba130dfa-J5nIN0_fw658.jpg)\n\n> 通过前两篇《Spring Cloud：服务消费（基础）》和《Spring Cloud：服务消费（Ribbon）》，我们已经学会了在Spring Cloud中基本的服务调用方式。本文我们将继续介绍Spring Cloud中的另外一个服务消费的工具：Spring Cloud Feign\n\n# Spring Cloud Feign\n\nSpring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。\n\n下面，我们通过一个例子来展现Feign如何方便的声明对eureka-client服务的定义和调用。\n\n# 动手试一试\n\n下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下：\n\n- 根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-feign。在pom.xml中增加下面的依赖：\n\n```\n<dependencies>\n    ...\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-feign</artifactId>\n    </dependency>\n</dependencies>\n```\n\n- 修改应用主类。通过@EnableFeignClients注解开启扫描Spring Cloud Feign客户端的功能：\n\n```\n@EnableFeignClients\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Application.class).web(true).run(args);\n    }\n}\n```\n\n- 创建一个Feign的客户端接口定义。使用@FeignClient注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口，比如下面就是绑定eureka-client服务的/dc接口的例子：\n\n```\n@FeignClient(\"eureka-client\")\npublic interface DcClient {\n    @GetMapping(\"/dc\")\n    String consumer();\n}\n```\n\n- 修改Controller。通过定义的feign客户端来调用服务提供方的接口：\n\n```\n@RestController\npublic class DcController {\n    @Autowired\n    DcClient dcClient;\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        return dcClient.consumer();\n    }\n}\n```\n\n通过Spring Cloud Feign来实现服务调用的方式更加简单了，通过@FeignClient定义的接口来统一的生命我们需要依赖的微服务接口。而在具体使用的时候就跟调用本地方法一点的进行调用即可。由于Feign是基于Ribbon实现的，所以它自带了客户端负载均衡功能，也可以通过Ribbon的IRule进行策略扩展。另外，Feign还整合的Hystrix来实现服务的容错保护，在Dalston版本中，Feign的Hystrix默认是关闭的。待后文介绍Hystrix带领大家入门之后，我们再结合介绍Feign中的Hystrix以及配置方式。\n\n在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-feign都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer-feign服务是如何消费eureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","slug":"spring-cloud4","published":1,"updated":"2019-12-24T02:00:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jxd001d0j9k48viaaln","content":"<p><img src=\"http://www.wailian.work/images/2018/04/11/82e28073c162d7fdb959807c8037c57b201707ba130dfa-J5nIN0_fw658.jpg\" alt=\"\"></p>\n<blockquote>\n<p>通过前两篇《Spring Cloud：服务消费（基础）》和《Spring Cloud：服务消费（Ribbon）》，我们已经学会了在Spring Cloud中基本的服务调用方式。本文我们将继续介绍Spring Cloud中的另外一个服务消费的工具：Spring Cloud Feign</p>\n</blockquote>\n<h1 id=\"Spring-Cloud-Feign\"><a href=\"#Spring-Cloud-Feign\" class=\"headerlink\" title=\"Spring Cloud Feign\"></a>Spring Cloud Feign</h1><p>Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。</p>\n<p>下面，我们通过一个例子来展现Feign如何方便的声明对eureka-client服务的定义和调用。</p>\n<h1 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h1><p>下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下：</p>\n<ul>\n<li>根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-feign。在pom.xml中增加下面的依赖：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改应用主类。通过@EnableFeignClients注解开启扫描Spring Cloud Feign客户端的功能：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableFeignClients</span><br><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建一个Feign的客户端接口定义。使用@FeignClient注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口，比如下面就是绑定eureka-client服务的/dc接口的例子：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FeignClient(&quot;eureka-client&quot;)</span><br><span class=\"line\">public interface DcClient &#123;</span><br><span class=\"line\">    @GetMapping(&quot;/dc&quot;)</span><br><span class=\"line\">    String consumer();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改Controller。通过定义的feign客户端来调用服务提供方的接口：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class DcController &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    DcClient dcClient;</span><br><span class=\"line\">    @GetMapping(&quot;/consumer&quot;)</span><br><span class=\"line\">    public String dc() &#123;</span><br><span class=\"line\">        return dcClient.consumer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过Spring Cloud Feign来实现服务调用的方式更加简单了，通过@FeignClient定义的接口来统一的生命我们需要依赖的微服务接口。而在具体使用的时候就跟调用本地方法一点的进行调用即可。由于Feign是基于Ribbon实现的，所以它自带了客户端负载均衡功能，也可以通过Ribbon的IRule进行策略扩展。另外，Feign还整合的Hystrix来实现服务的容错保护，在Dalston版本中，Feign的Hystrix默认是关闭的。待后文介绍Hystrix带领大家入门之后，我们再结合介绍Feign中的Hystrix以及配置方式。</p>\n<p>在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-feign都启动起来，然后访问<a href=\"http://localhost:2101/consumer\" target=\"_blank\" rel=\"noopener\">http://localhost:2101/consumer</a> ，来跟踪观察eureka-consumer-feign服务是如何消费eureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。</p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/04/11/82e28073c162d7fdb959807c8037c57b201707ba130dfa-J5nIN0_fw658.jpg\" alt=\"\"></p>\n<blockquote>\n<p>通过前两篇《Spring Cloud：服务消费（基础）》和《Spring Cloud：服务消费（Ribbon）》，我们已经学会了在Spring Cloud中基本的服务调用方式。本文我们将继续介绍Spring Cloud中的另外一个服务消费的工具：Spring Cloud Feign</p>\n</blockquote>\n<h1 id=\"Spring-Cloud-Feign\"><a href=\"#Spring-Cloud-Feign\" class=\"headerlink\" title=\"Spring Cloud Feign\"></a>Spring Cloud Feign</h1><p>Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。</p>\n<p>下面，我们通过一个例子来展现Feign如何方便的声明对eureka-client服务的定义和调用。</p>\n<h1 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h1><p>下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下：</p>\n<ul>\n<li>根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-feign。在pom.xml中增加下面的依赖：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改应用主类。通过@EnableFeignClients注解开启扫描Spring Cloud Feign客户端的功能：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableFeignClients</span><br><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建一个Feign的客户端接口定义。使用@FeignClient注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口，比如下面就是绑定eureka-client服务的/dc接口的例子：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FeignClient(&quot;eureka-client&quot;)</span><br><span class=\"line\">public interface DcClient &#123;</span><br><span class=\"line\">    @GetMapping(&quot;/dc&quot;)</span><br><span class=\"line\">    String consumer();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改Controller。通过定义的feign客户端来调用服务提供方的接口：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class DcController &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    DcClient dcClient;</span><br><span class=\"line\">    @GetMapping(&quot;/consumer&quot;)</span><br><span class=\"line\">    public String dc() &#123;</span><br><span class=\"line\">        return dcClient.consumer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过Spring Cloud Feign来实现服务调用的方式更加简单了，通过@FeignClient定义的接口来统一的生命我们需要依赖的微服务接口。而在具体使用的时候就跟调用本地方法一点的进行调用即可。由于Feign是基于Ribbon实现的，所以它自带了客户端负载均衡功能，也可以通过Ribbon的IRule进行策略扩展。另外，Feign还整合的Hystrix来实现服务的容错保护，在Dalston版本中，Feign的Hystrix默认是关闭的。待后文介绍Hystrix带领大家入门之后，我们再结合介绍Feign中的Hystrix以及配置方式。</p>\n<p>在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-feign都启动起来，然后访问<a href=\"http://localhost:2101/consumer\" target=\"_blank\" rel=\"noopener\">http://localhost:2101/consumer</a> ，来跟踪观察eureka-consumer-feign服务是如何消费eureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。</p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n"},{"title":"5.Spring Cloud：分布式配置中心【Dalston版】","date":"2018-01-09T01:28:55.000Z","top":1,"_content":"\n![](http://www.wailian.work/images/2018/04/11/3c33ce7eff9b6b50e038fa70e85b0e6a2b30d4c84a688-Rrw85Z_fw658.jpg)\n\nSpring Cloud Config是Spring Cloud团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于Spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息，所以使用Spring Cloud Config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN仓库、本地化文件系统。\n\n在本文中，我们将学习如何构建一个基于Git存储的分布式配置中心，并对客户端进行改造，并让其能够从配置中心获取配置信息并绑定到代码中的整个过程。\n\n# 准备配置仓库\n\n- 准备一个git仓库，可以在码云或Github上创建都可以。比如本文准备的仓库示例：\nhttp://git.oschina.net/didispace/config-repo-demo\n\n- 假设我们读取配置中心的应用名为config-client，那么我们可以在git仓库中该项目的默认配置文件config-client.yml：\n\n```\ninfo:\n  profile: default\n```\n\n- 为了演示加载不同环境的配置，我们可以在git仓库中再创建一个针对dev环境的配置文件config-client-dev.yml：\n\n```\ninfo:\n  profile: dev\n```\n\n# 构建配置中心\n\n- 创建一个基础的Spring Boot工程，命名为：config-server-git，并在pom.xml中引入下面的依赖（省略了parent和dependencyManagement部分）：\n\n```\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-config-server</artifactId>\n    </dependency>\n</dependencies>\n```\n\n- 创建Spring Boot的程序主类，并添加@EnableConfigServer注解，开启Spring Cloud Config的服务端功能。\n\n```\n@EnableConfigServer\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Application.class).web(true).run(args);\n    }\n}\n```\n\n- 在application.yml中添加配置服务的基本信息以及Git仓库的相关信息，例如：\n\n```\nspring\n  application:\n    name: config-server\n  cloud:\n    config:\n      server:\n        git:\n          uri: http://git.oschina.net/didispace/config-repo-demo/\nserver:\n  port: 1201\n```\n\n到这里，使用一个通过Spring Cloud Config实现，并使用Git管理配置内容的分布式配置中心就已经完成了。我们可以将该应用先启动起来，确保没有错误产生，然后再尝试下面的内容。\n\n> 如果我们的Git仓库需要权限访问，那么可以通过配置下面的两个属性来实现\nspring.cloud.config.server.git.username：访问Git仓库的用户名\nspring.cloud.config.server.git.password：访问Git仓库的用户密码\n\n完成了这些准备工作之后，我们就可以通过浏览器、POSTMAN或CURL等工具直接来访问到我们的配置内容了。访问配置信息的URL与配置文件的映射关系如下：\n\n- /{application}/{profile}[/{label}]\n- /{application}-{profile}.yml\n- /{label}/{application}-{profile}.yml\n- /{application}-{profile}.properties\n- /{label}/{application}-{profile}.properties\n\n上面的url会映射{application}-{profile}.properties对应的配置文件，其中{label}对应Git上不同的分支，默认为master。我们可以尝试构造不同的url来访问不同的配置内容，比如，要访问master分支，config-client应用的dev环境，就可以访问这个url：http://localhost:1201/config-client/dev/master，并获得如下返回：\n\n```\n{\n    \"name\": \"config-client\",\n    \"profiles\": [\n        \"dev\"\n    ],\n    \"label\": \"master\",\n    \"version\": null,\n    \"state\": null,\n    \"propertySources\": [\n        {\n            \"name\": \"http://git.oschina.net/didispace/config-repo-demo/config-client-dev.yml\",\n            \"source\": {\n                \"info.profile\": \"dev\"\n            }\n        },\n        {\n            \"name\": \"http://git.oschina.net/didispace/config-repo-demo/config-client.yml\",\n            \"source\": {\n                \"info.profile\": \"default\"\n            }\n        }\n    ]\n}\n```\n\n我们可以看到该Json中返回了应用名：config-client，环境名：dev，分支名：master，以及default环境和dev环境的配置内容。\n\n# 构建客户端\n\n在完成了上述验证之后，确定配置服务中心已经正常运作，下面我们尝试如何在微服务应用中获取上述的配置信息。\n\n- 创建一个Spring Boot应用，命名为config-client，并在pom.xml中引入下述依赖：\n\n```\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-config</artifactId>\n    </dependency>\n</dependencies>\n```\n\n- 创建Spring Boot的应用主类，具体如下：\n\n```\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Application.class).web(true).run(args);\n    }\n}\n```\n\n- 创建bootstrap.yml配置，来指定获取配置文件的config-server-git位置，例如：\n\n```\nspring:\n  application:\n    name: config-client\n  cloud:\n    config:\n      uri: http://localhost:1201/\n      profile: default\n      label: master\nserver:\n  port: 2001\n```\n\n上述配置参数与Git中存储的配置文件中各个部分的对应关系如下：\n- spring.application.name：对应配置文件规则中的{application}部分\n- spring.cloud.config.profile：对应配置文件规则中的{profile}部分\n- spring.cloud.config.label：对应配置文件规则中的{label}部分\n- spring.cloud.config.uri：配置中心config-server的地址\n\n* 这里需要格外注意：上面这些属性必须配置在bootstrap.properties中，这样config-server中的配置信息才能被正确加载 *\n\n在完成了上面你的代码编写之后，读者可以将config-server-git、config-client都启动起来，然后访问http://localhost:2001/info ，我们可以看到该端点将会返回从git仓库中获取的配置信息：\n\n```\n{\n    \"profile\": \"default\"\n}\n```\n另外，我们也可以修改config-client的profile为dev来观察加载配置的变化。\n\n# 配置刷新\n\n以上配置有个问题：只有在应用启动时会读取到git的内容， 之后只要应用不重启，git中文件的修改，应用无法感知， 即使重启Config Server也不行，此时需要让客户端(config-client)支持/refresh方法\n\n在程序入口类上面加载`@RefreshScope`注解，在客户端执行`/refresh`的时候就会更新此类下面的变量值\n\n以上每当git中配置文件被修改，仍然需要我们主动调用/refresh方法（手动调用或者写代码调用）， 有没有办法让git中配置有改动就自动触发客户端的refresh机制呢？ 答案是：有。可以通过git提供的githook来监听push命令，如果项目中使用了Jenkins等持续集成工具（也是利用githook来监听的），就可以在监听事件处理中直接调用/refresh方法就可以了。\n","source":"_posts/spring-cloud5.md","raw":"---\ntitle: 5.Spring Cloud：分布式配置中心【Dalston版】\ndate: 2018-01-09 09:28:55\ntop: 1\ncategories: 微服务\n---\n\n![](http://www.wailian.work/images/2018/04/11/3c33ce7eff9b6b50e038fa70e85b0e6a2b30d4c84a688-Rrw85Z_fw658.jpg)\n\nSpring Cloud Config是Spring Cloud团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于Spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息，所以使用Spring Cloud Config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN仓库、本地化文件系统。\n\n在本文中，我们将学习如何构建一个基于Git存储的分布式配置中心，并对客户端进行改造，并让其能够从配置中心获取配置信息并绑定到代码中的整个过程。\n\n# 准备配置仓库\n\n- 准备一个git仓库，可以在码云或Github上创建都可以。比如本文准备的仓库示例：\nhttp://git.oschina.net/didispace/config-repo-demo\n\n- 假设我们读取配置中心的应用名为config-client，那么我们可以在git仓库中该项目的默认配置文件config-client.yml：\n\n```\ninfo:\n  profile: default\n```\n\n- 为了演示加载不同环境的配置，我们可以在git仓库中再创建一个针对dev环境的配置文件config-client-dev.yml：\n\n```\ninfo:\n  profile: dev\n```\n\n# 构建配置中心\n\n- 创建一个基础的Spring Boot工程，命名为：config-server-git，并在pom.xml中引入下面的依赖（省略了parent和dependencyManagement部分）：\n\n```\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-config-server</artifactId>\n    </dependency>\n</dependencies>\n```\n\n- 创建Spring Boot的程序主类，并添加@EnableConfigServer注解，开启Spring Cloud Config的服务端功能。\n\n```\n@EnableConfigServer\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Application.class).web(true).run(args);\n    }\n}\n```\n\n- 在application.yml中添加配置服务的基本信息以及Git仓库的相关信息，例如：\n\n```\nspring\n  application:\n    name: config-server\n  cloud:\n    config:\n      server:\n        git:\n          uri: http://git.oschina.net/didispace/config-repo-demo/\nserver:\n  port: 1201\n```\n\n到这里，使用一个通过Spring Cloud Config实现，并使用Git管理配置内容的分布式配置中心就已经完成了。我们可以将该应用先启动起来，确保没有错误产生，然后再尝试下面的内容。\n\n> 如果我们的Git仓库需要权限访问，那么可以通过配置下面的两个属性来实现\nspring.cloud.config.server.git.username：访问Git仓库的用户名\nspring.cloud.config.server.git.password：访问Git仓库的用户密码\n\n完成了这些准备工作之后，我们就可以通过浏览器、POSTMAN或CURL等工具直接来访问到我们的配置内容了。访问配置信息的URL与配置文件的映射关系如下：\n\n- /{application}/{profile}[/{label}]\n- /{application}-{profile}.yml\n- /{label}/{application}-{profile}.yml\n- /{application}-{profile}.properties\n- /{label}/{application}-{profile}.properties\n\n上面的url会映射{application}-{profile}.properties对应的配置文件，其中{label}对应Git上不同的分支，默认为master。我们可以尝试构造不同的url来访问不同的配置内容，比如，要访问master分支，config-client应用的dev环境，就可以访问这个url：http://localhost:1201/config-client/dev/master，并获得如下返回：\n\n```\n{\n    \"name\": \"config-client\",\n    \"profiles\": [\n        \"dev\"\n    ],\n    \"label\": \"master\",\n    \"version\": null,\n    \"state\": null,\n    \"propertySources\": [\n        {\n            \"name\": \"http://git.oschina.net/didispace/config-repo-demo/config-client-dev.yml\",\n            \"source\": {\n                \"info.profile\": \"dev\"\n            }\n        },\n        {\n            \"name\": \"http://git.oschina.net/didispace/config-repo-demo/config-client.yml\",\n            \"source\": {\n                \"info.profile\": \"default\"\n            }\n        }\n    ]\n}\n```\n\n我们可以看到该Json中返回了应用名：config-client，环境名：dev，分支名：master，以及default环境和dev环境的配置内容。\n\n# 构建客户端\n\n在完成了上述验证之后，确定配置服务中心已经正常运作，下面我们尝试如何在微服务应用中获取上述的配置信息。\n\n- 创建一个Spring Boot应用，命名为config-client，并在pom.xml中引入下述依赖：\n\n```\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-config</artifactId>\n    </dependency>\n</dependencies>\n```\n\n- 创建Spring Boot的应用主类，具体如下：\n\n```\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Application.class).web(true).run(args);\n    }\n}\n```\n\n- 创建bootstrap.yml配置，来指定获取配置文件的config-server-git位置，例如：\n\n```\nspring:\n  application:\n    name: config-client\n  cloud:\n    config:\n      uri: http://localhost:1201/\n      profile: default\n      label: master\nserver:\n  port: 2001\n```\n\n上述配置参数与Git中存储的配置文件中各个部分的对应关系如下：\n- spring.application.name：对应配置文件规则中的{application}部分\n- spring.cloud.config.profile：对应配置文件规则中的{profile}部分\n- spring.cloud.config.label：对应配置文件规则中的{label}部分\n- spring.cloud.config.uri：配置中心config-server的地址\n\n* 这里需要格外注意：上面这些属性必须配置在bootstrap.properties中，这样config-server中的配置信息才能被正确加载 *\n\n在完成了上面你的代码编写之后，读者可以将config-server-git、config-client都启动起来，然后访问http://localhost:2001/info ，我们可以看到该端点将会返回从git仓库中获取的配置信息：\n\n```\n{\n    \"profile\": \"default\"\n}\n```\n另外，我们也可以修改config-client的profile为dev来观察加载配置的变化。\n\n# 配置刷新\n\n以上配置有个问题：只有在应用启动时会读取到git的内容， 之后只要应用不重启，git中文件的修改，应用无法感知， 即使重启Config Server也不行，此时需要让客户端(config-client)支持/refresh方法\n\n在程序入口类上面加载`@RefreshScope`注解，在客户端执行`/refresh`的时候就会更新此类下面的变量值\n\n以上每当git中配置文件被修改，仍然需要我们主动调用/refresh方法（手动调用或者写代码调用）， 有没有办法让git中配置有改动就自动触发客户端的refresh机制呢？ 答案是：有。可以通过git提供的githook来监听push命令，如果项目中使用了Jenkins等持续集成工具（也是利用githook来监听的），就可以在监听事件处理中直接调用/refresh方法就可以了。\n","slug":"spring-cloud5","published":1,"updated":"2019-12-24T02:00:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jxe001e0j9kljzzs8gk","content":"<p><img src=\"http://www.wailian.work/images/2018/04/11/3c33ce7eff9b6b50e038fa70e85b0e6a2b30d4c84a688-Rrw85Z_fw658.jpg\" alt=\"\"></p>\n<p>Spring Cloud Config是Spring Cloud团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于Spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息，所以使用Spring Cloud Config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN仓库、本地化文件系统。</p>\n<p>在本文中，我们将学习如何构建一个基于Git存储的分布式配置中心，并对客户端进行改造，并让其能够从配置中心获取配置信息并绑定到代码中的整个过程。</p>\n<h1 id=\"准备配置仓库\"><a href=\"#准备配置仓库\" class=\"headerlink\" title=\"准备配置仓库\"></a>准备配置仓库</h1><ul>\n<li><p>准备一个git仓库，可以在码云或Github上创建都可以。比如本文准备的仓库示例：<br><a href=\"http://git.oschina.net/didispace/config-repo-demo\" target=\"_blank\" rel=\"noopener\">http://git.oschina.net/didispace/config-repo-demo</a></p>\n</li>\n<li><p>假设我们读取配置中心的应用名为config-client，那么我们可以在git仓库中该项目的默认配置文件config-client.yml：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info:</span><br><span class=\"line\">  profile: default</span><br></pre></td></tr></table></figure>\n<ul>\n<li>为了演示加载不同环境的配置，我们可以在git仓库中再创建一个针对dev环境的配置文件config-client-dev.yml：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info:</span><br><span class=\"line\">  profile: dev</span><br></pre></td></tr></table></figure>\n<h1 id=\"构建配置中心\"><a href=\"#构建配置中心\" class=\"headerlink\" title=\"构建配置中心\"></a>构建配置中心</h1><ul>\n<li>创建一个基础的Spring Boot工程，命名为：config-server-git，并在pom.xml中引入下面的依赖（省略了parent和dependencyManagement部分）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建Spring Boot的程序主类，并添加@EnableConfigServer注解，开启Spring Cloud Config的服务端功能。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableConfigServer</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在application.yml中添加配置服务的基本信息以及Git仓库的相关信息，例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: config-server</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    config:</span><br><span class=\"line\">      server:</span><br><span class=\"line\">        git:</span><br><span class=\"line\">          uri: http://git.oschina.net/didispace/config-repo-demo/</span><br><span class=\"line\">server:</span><br><span class=\"line\">  port: 1201</span><br></pre></td></tr></table></figure>\n<p>到这里，使用一个通过Spring Cloud Config实现，并使用Git管理配置内容的分布式配置中心就已经完成了。我们可以将该应用先启动起来，确保没有错误产生，然后再尝试下面的内容。</p>\n<blockquote>\n<p>如果我们的Git仓库需要权限访问，那么可以通过配置下面的两个属性来实现<br>spring.cloud.config.server.git.username：访问Git仓库的用户名<br>spring.cloud.config.server.git.password：访问Git仓库的用户密码</p>\n</blockquote>\n<p>完成了这些准备工作之后，我们就可以通过浏览器、POSTMAN或CURL等工具直接来访问到我们的配置内容了。访问配置信息的URL与配置文件的映射关系如下：</p>\n<ul>\n<li>/{application}/{profile}[/{label}]</li>\n<li>/{application}-{profile}.yml</li>\n<li>/{label}/{application}-{profile}.yml</li>\n<li>/{application}-{profile}.properties</li>\n<li>/{label}/{application}-{profile}.properties</li>\n</ul>\n<p>上面的url会映射{application}-{profile}.properties对应的配置文件，其中{label}对应Git上不同的分支，默认为master。我们可以尝试构造不同的url来访问不同的配置内容，比如，要访问master分支，config-client应用的dev环境，就可以访问这个url：<a href=\"http://localhost:1201/config-client/dev/master，并获得如下返回：\" target=\"_blank\" rel=\"noopener\">http://localhost:1201/config-client/dev/master，并获得如下返回：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;: &quot;config-client&quot;,</span><br><span class=\"line\">    &quot;profiles&quot;: [</span><br><span class=\"line\">        &quot;dev&quot;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;label&quot;: &quot;master&quot;,</span><br><span class=\"line\">    &quot;version&quot;: null,</span><br><span class=\"line\">    &quot;state&quot;: null,</span><br><span class=\"line\">    &quot;propertySources&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;http://git.oschina.net/didispace/config-repo-demo/config-client-dev.yml&quot;,</span><br><span class=\"line\">            &quot;source&quot;: &#123;</span><br><span class=\"line\">                &quot;info.profile&quot;: &quot;dev&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;http://git.oschina.net/didispace/config-repo-demo/config-client.yml&quot;,</span><br><span class=\"line\">            &quot;source&quot;: &#123;</span><br><span class=\"line\">                &quot;info.profile&quot;: &quot;default&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到该Json中返回了应用名：config-client，环境名：dev，分支名：master，以及default环境和dev环境的配置内容。</p>\n<h1 id=\"构建客户端\"><a href=\"#构建客户端\" class=\"headerlink\" title=\"构建客户端\"></a>构建客户端</h1><p>在完成了上述验证之后，确定配置服务中心已经正常运作，下面我们尝试如何在微服务应用中获取上述的配置信息。</p>\n<ul>\n<li>创建一个Spring Boot应用，命名为config-client，并在pom.xml中引入下述依赖：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建Spring Boot的应用主类，具体如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建bootstrap.yml配置，来指定获取配置文件的config-server-git位置，例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: config-client</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    config:</span><br><span class=\"line\">      uri: http://localhost:1201/</span><br><span class=\"line\">      profile: default</span><br><span class=\"line\">      label: master</span><br><span class=\"line\">server:</span><br><span class=\"line\">  port: 2001</span><br></pre></td></tr></table></figure>\n<p>上述配置参数与Git中存储的配置文件中各个部分的对应关系如下：</p>\n<ul>\n<li>spring.application.name：对应配置文件规则中的{application}部分</li>\n<li>spring.cloud.config.profile：对应配置文件规则中的{profile}部分</li>\n<li>spring.cloud.config.label：对应配置文件规则中的{label}部分</li>\n<li>spring.cloud.config.uri：配置中心config-server的地址</li>\n</ul>\n<ul>\n<li>这里需要格外注意：上面这些属性必须配置在bootstrap.properties中，这样config-server中的配置信息才能被正确加载 *</li>\n</ul>\n<p>在完成了上面你的代码编写之后，读者可以将config-server-git、config-client都启动起来，然后访问<a href=\"http://localhost:2001/info\" target=\"_blank\" rel=\"noopener\">http://localhost:2001/info</a> ，我们可以看到该端点将会返回从git仓库中获取的配置信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;profile&quot;: &quot;default&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外，我们也可以修改config-client的profile为dev来观察加载配置的变化。</p>\n<h1 id=\"配置刷新\"><a href=\"#配置刷新\" class=\"headerlink\" title=\"配置刷新\"></a>配置刷新</h1><p>以上配置有个问题：只有在应用启动时会读取到git的内容， 之后只要应用不重启，git中文件的修改，应用无法感知， 即使重启Config Server也不行，此时需要让客户端(config-client)支持/refresh方法</p>\n<p>在程序入口类上面加载<code>@RefreshScope</code>注解，在客户端执行<code>/refresh</code>的时候就会更新此类下面的变量值</p>\n<p>以上每当git中配置文件被修改，仍然需要我们主动调用/refresh方法（手动调用或者写代码调用）， 有没有办法让git中配置有改动就自动触发客户端的refresh机制呢？ 答案是：有。可以通过git提供的githook来监听push命令，如果项目中使用了Jenkins等持续集成工具（也是利用githook来监听的），就可以在监听事件处理中直接调用/refresh方法就可以了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/04/11/3c33ce7eff9b6b50e038fa70e85b0e6a2b30d4c84a688-Rrw85Z_fw658.jpg\" alt=\"\"></p>\n<p>Spring Cloud Config是Spring Cloud团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于Spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息，所以使用Spring Cloud Config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN仓库、本地化文件系统。</p>\n<p>在本文中，我们将学习如何构建一个基于Git存储的分布式配置中心，并对客户端进行改造，并让其能够从配置中心获取配置信息并绑定到代码中的整个过程。</p>\n<h1 id=\"准备配置仓库\"><a href=\"#准备配置仓库\" class=\"headerlink\" title=\"准备配置仓库\"></a>准备配置仓库</h1><ul>\n<li><p>准备一个git仓库，可以在码云或Github上创建都可以。比如本文准备的仓库示例：<br><a href=\"http://git.oschina.net/didispace/config-repo-demo\" target=\"_blank\" rel=\"noopener\">http://git.oschina.net/didispace/config-repo-demo</a></p>\n</li>\n<li><p>假设我们读取配置中心的应用名为config-client，那么我们可以在git仓库中该项目的默认配置文件config-client.yml：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info:</span><br><span class=\"line\">  profile: default</span><br></pre></td></tr></table></figure>\n<ul>\n<li>为了演示加载不同环境的配置，我们可以在git仓库中再创建一个针对dev环境的配置文件config-client-dev.yml：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info:</span><br><span class=\"line\">  profile: dev</span><br></pre></td></tr></table></figure>\n<h1 id=\"构建配置中心\"><a href=\"#构建配置中心\" class=\"headerlink\" title=\"构建配置中心\"></a>构建配置中心</h1><ul>\n<li>创建一个基础的Spring Boot工程，命名为：config-server-git，并在pom.xml中引入下面的依赖（省略了parent和dependencyManagement部分）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建Spring Boot的程序主类，并添加@EnableConfigServer注解，开启Spring Cloud Config的服务端功能。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableConfigServer</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在application.yml中添加配置服务的基本信息以及Git仓库的相关信息，例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: config-server</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    config:</span><br><span class=\"line\">      server:</span><br><span class=\"line\">        git:</span><br><span class=\"line\">          uri: http://git.oschina.net/didispace/config-repo-demo/</span><br><span class=\"line\">server:</span><br><span class=\"line\">  port: 1201</span><br></pre></td></tr></table></figure>\n<p>到这里，使用一个通过Spring Cloud Config实现，并使用Git管理配置内容的分布式配置中心就已经完成了。我们可以将该应用先启动起来，确保没有错误产生，然后再尝试下面的内容。</p>\n<blockquote>\n<p>如果我们的Git仓库需要权限访问，那么可以通过配置下面的两个属性来实现<br>spring.cloud.config.server.git.username：访问Git仓库的用户名<br>spring.cloud.config.server.git.password：访问Git仓库的用户密码</p>\n</blockquote>\n<p>完成了这些准备工作之后，我们就可以通过浏览器、POSTMAN或CURL等工具直接来访问到我们的配置内容了。访问配置信息的URL与配置文件的映射关系如下：</p>\n<ul>\n<li>/{application}/{profile}[/{label}]</li>\n<li>/{application}-{profile}.yml</li>\n<li>/{label}/{application}-{profile}.yml</li>\n<li>/{application}-{profile}.properties</li>\n<li>/{label}/{application}-{profile}.properties</li>\n</ul>\n<p>上面的url会映射{application}-{profile}.properties对应的配置文件，其中{label}对应Git上不同的分支，默认为master。我们可以尝试构造不同的url来访问不同的配置内容，比如，要访问master分支，config-client应用的dev环境，就可以访问这个url：<a href=\"http://localhost:1201/config-client/dev/master，并获得如下返回：\" target=\"_blank\" rel=\"noopener\">http://localhost:1201/config-client/dev/master，并获得如下返回：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;: &quot;config-client&quot;,</span><br><span class=\"line\">    &quot;profiles&quot;: [</span><br><span class=\"line\">        &quot;dev&quot;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;label&quot;: &quot;master&quot;,</span><br><span class=\"line\">    &quot;version&quot;: null,</span><br><span class=\"line\">    &quot;state&quot;: null,</span><br><span class=\"line\">    &quot;propertySources&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;http://git.oschina.net/didispace/config-repo-demo/config-client-dev.yml&quot;,</span><br><span class=\"line\">            &quot;source&quot;: &#123;</span><br><span class=\"line\">                &quot;info.profile&quot;: &quot;dev&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;http://git.oschina.net/didispace/config-repo-demo/config-client.yml&quot;,</span><br><span class=\"line\">            &quot;source&quot;: &#123;</span><br><span class=\"line\">                &quot;info.profile&quot;: &quot;default&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到该Json中返回了应用名：config-client，环境名：dev，分支名：master，以及default环境和dev环境的配置内容。</p>\n<h1 id=\"构建客户端\"><a href=\"#构建客户端\" class=\"headerlink\" title=\"构建客户端\"></a>构建客户端</h1><p>在完成了上述验证之后，确定配置服务中心已经正常运作，下面我们尝试如何在微服务应用中获取上述的配置信息。</p>\n<ul>\n<li>创建一个Spring Boot应用，命名为config-client，并在pom.xml中引入下述依赖：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建Spring Boot的应用主类，具体如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建bootstrap.yml配置，来指定获取配置文件的config-server-git位置，例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: config-client</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    config:</span><br><span class=\"line\">      uri: http://localhost:1201/</span><br><span class=\"line\">      profile: default</span><br><span class=\"line\">      label: master</span><br><span class=\"line\">server:</span><br><span class=\"line\">  port: 2001</span><br></pre></td></tr></table></figure>\n<p>上述配置参数与Git中存储的配置文件中各个部分的对应关系如下：</p>\n<ul>\n<li>spring.application.name：对应配置文件规则中的{application}部分</li>\n<li>spring.cloud.config.profile：对应配置文件规则中的{profile}部分</li>\n<li>spring.cloud.config.label：对应配置文件规则中的{label}部分</li>\n<li>spring.cloud.config.uri：配置中心config-server的地址</li>\n</ul>\n<ul>\n<li>这里需要格外注意：上面这些属性必须配置在bootstrap.properties中，这样config-server中的配置信息才能被正确加载 *</li>\n</ul>\n<p>在完成了上面你的代码编写之后，读者可以将config-server-git、config-client都启动起来，然后访问<a href=\"http://localhost:2001/info\" target=\"_blank\" rel=\"noopener\">http://localhost:2001/info</a> ，我们可以看到该端点将会返回从git仓库中获取的配置信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;profile&quot;: &quot;default&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外，我们也可以修改config-client的profile为dev来观察加载配置的变化。</p>\n<h1 id=\"配置刷新\"><a href=\"#配置刷新\" class=\"headerlink\" title=\"配置刷新\"></a>配置刷新</h1><p>以上配置有个问题：只有在应用启动时会读取到git的内容， 之后只要应用不重启，git中文件的修改，应用无法感知， 即使重启Config Server也不行，此时需要让客户端(config-client)支持/refresh方法</p>\n<p>在程序入口类上面加载<code>@RefreshScope</code>注解，在客户端执行<code>/refresh</code>的时候就会更新此类下面的变量值</p>\n<p>以上每当git中配置文件被修改，仍然需要我们主动调用/refresh方法（手动调用或者写代码调用）， 有没有办法让git中配置有改动就自动触发客户端的refresh机制呢？ 答案是：有。可以通过git提供的githook来监听push命令，如果项目中使用了Jenkins等持续集成工具（也是利用githook来监听的），就可以在监听事件处理中直接调用/refresh方法就可以了。</p>\n"},{"title":"6.Spring Cloud构建微服务架构：服务容错保护（Hystrix服务降级）【Dalston版】","date":"2018-01-10T02:23:15.000Z","top":1,"_content":"# 前言\n\n在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元应用间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，线程资源无法释放，最终导致自身服务的瘫痪，进一步甚至出现故障的蔓延最终导致整个系统的瘫痪。如果这样的架构存在如此严重的隐患，那么相较传统架构就更加的不稳定。为了解决这样的问题，因此产生了断路器等一系列的服务保护机制。\n\n针对上述问题，在Spring Cloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。\n\n接下来，我们就从一个简单示例开始对Spring Cloud Hystrix的学习与使用。\n\n# 动手试一试\n\n在开始使用Spring Cloud Hystrix实现断路器之前，我们先拿之前实现的一些内容作为基础，其中包括：\n\n- eureka-server工程：服务注册中心，端口：1001\n- eureka-client工程：服务提供者，端口：2001\n\n下面我们可以复制一下之前实现的一个服务消费者：`eureka-consumer-ribbon`命名为`eureka-consumer-ribbon-hystrix`下面我们开始对其进行修改：\n\n第一步`pom.xml`的dependencies节点中引入`spring-cloud-starter-hystrix`依赖：\n\n```\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-hystrix</artifactId>\n</dependency>\n```\n\n第二步：在应用主类中使用`@EnableCircuitBreaker`或`@EnableHystrix`注解开启Hystrix的使用：\n\n```\n@EnableCircuitBreaker\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class Application {\n\n\t@Bean\n\t@LoadBalanced\n\tpublic RestTemplate restTemplate() {\n\t\treturn new RestTemplate();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew SpringApplicationBuilder(Application.class).web(true).run(args);\n\t}\n\n}\n```\n\n*注意：这里我们还可以使用Spring Cloud应用中的`@SpringCloudApplication`注解来修饰应用主类，该注解的具体定义如下所示。我们可以看到该注解中包含了上我们所引用的三个注解，这也意味着一个Spring Cloud标准应用应包含服务发现以及断路器。*\n\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableCircuitBreaker\npublic @interface SpringCloudApplication {\n}\n```\n\n第三步：改造服务消费方式，新增`ConsumerService`类,然后将在`Controller`中的逻辑迁移过去。最后，在为具体执行逻辑的函数上增加`@HystrixCommand`注解来指定服务降级方法，比如：\n\n```\n@RestController\npublic class DcController {\n\n    @Autowired\n    ConsumerService consumerService;\n\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        return consumerService.consumer();\n    }\n\n    class ConsumerService {\n\n        @Autowired\n        RestTemplate restTemplate;\n\n        @HystrixCommand(fallbackMethod = \"fallback\")\n        public String consumer() {\n            return restTemplate.getForObject(\"http://eureka-client/dc\", String.class);\n        }\n\n        public String fallback() {\n            return \"fallback\";\n        }\n\n    }\n\n}\n```\n\n下面我们来验证一下上面Hystrix带来的一些基础功能。我们先把涉及的服务都启动起来，然后访问`localhost:2101/consumer`此时可以获取正常的返回，比如：`Services: [eureka-consumer-ribbon-hystrix, eureka-client]`\n\n为了触发服务降级逻辑，我们可以将服务提供者`eureka-client`的逻辑加一些延迟，比如：\n\n```\n@GetMapping(\"/dc\")\npublic String dc() throws InterruptedException {\n    Thread.sleep(5000L);\n    String services = \"Services: \" + discoveryClient.getServices();\n    System.out.println(services);\n    return services;\n}\n```\n\n重启`eureka-client`之后，再尝试访问`localhost:2101/consumer`,此时我们将获得的返回结果为：`fallback`。我们从`eureka-client`的控制台中，可以看到服务提供方输出了原本要返回的结果，但是由于返回前延迟了5秒，而服务消费方触发了服务请求超时异常，服务消费者就通过HystrixCommand注解中指定的降级逻辑进行执行，因此该请求的结果返回了`fallback`。这样的机制，对自身服务起到了基础的保护，同时还为异常情况提供了自动的服务降级切换机制。\n\n具体工程说明如下：\n\n- eureka的服务注册中心：eureka-server\n- eureka的服务提供方：eureka-client\n- eureka的服务消费者：eureka-consumer-ribbon-hystrix\n","source":"_posts/spring-cloud6.md","raw":"---\ntitle: 6.Spring Cloud构建微服务架构：服务容错保护（Hystrix服务降级）【Dalston版】\ndate: 2018-01-10 10:23:15\ntop: 1\ncategories: 微服务\n---\n# 前言\n\n在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元应用间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，线程资源无法释放，最终导致自身服务的瘫痪，进一步甚至出现故障的蔓延最终导致整个系统的瘫痪。如果这样的架构存在如此严重的隐患，那么相较传统架构就更加的不稳定。为了解决这样的问题，因此产生了断路器等一系列的服务保护机制。\n\n针对上述问题，在Spring Cloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。\n\n接下来，我们就从一个简单示例开始对Spring Cloud Hystrix的学习与使用。\n\n# 动手试一试\n\n在开始使用Spring Cloud Hystrix实现断路器之前，我们先拿之前实现的一些内容作为基础，其中包括：\n\n- eureka-server工程：服务注册中心，端口：1001\n- eureka-client工程：服务提供者，端口：2001\n\n下面我们可以复制一下之前实现的一个服务消费者：`eureka-consumer-ribbon`命名为`eureka-consumer-ribbon-hystrix`下面我们开始对其进行修改：\n\n第一步`pom.xml`的dependencies节点中引入`spring-cloud-starter-hystrix`依赖：\n\n```\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-hystrix</artifactId>\n</dependency>\n```\n\n第二步：在应用主类中使用`@EnableCircuitBreaker`或`@EnableHystrix`注解开启Hystrix的使用：\n\n```\n@EnableCircuitBreaker\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class Application {\n\n\t@Bean\n\t@LoadBalanced\n\tpublic RestTemplate restTemplate() {\n\t\treturn new RestTemplate();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew SpringApplicationBuilder(Application.class).web(true).run(args);\n\t}\n\n}\n```\n\n*注意：这里我们还可以使用Spring Cloud应用中的`@SpringCloudApplication`注解来修饰应用主类，该注解的具体定义如下所示。我们可以看到该注解中包含了上我们所引用的三个注解，这也意味着一个Spring Cloud标准应用应包含服务发现以及断路器。*\n\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableCircuitBreaker\npublic @interface SpringCloudApplication {\n}\n```\n\n第三步：改造服务消费方式，新增`ConsumerService`类,然后将在`Controller`中的逻辑迁移过去。最后，在为具体执行逻辑的函数上增加`@HystrixCommand`注解来指定服务降级方法，比如：\n\n```\n@RestController\npublic class DcController {\n\n    @Autowired\n    ConsumerService consumerService;\n\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        return consumerService.consumer();\n    }\n\n    class ConsumerService {\n\n        @Autowired\n        RestTemplate restTemplate;\n\n        @HystrixCommand(fallbackMethod = \"fallback\")\n        public String consumer() {\n            return restTemplate.getForObject(\"http://eureka-client/dc\", String.class);\n        }\n\n        public String fallback() {\n            return \"fallback\";\n        }\n\n    }\n\n}\n```\n\n下面我们来验证一下上面Hystrix带来的一些基础功能。我们先把涉及的服务都启动起来，然后访问`localhost:2101/consumer`此时可以获取正常的返回，比如：`Services: [eureka-consumer-ribbon-hystrix, eureka-client]`\n\n为了触发服务降级逻辑，我们可以将服务提供者`eureka-client`的逻辑加一些延迟，比如：\n\n```\n@GetMapping(\"/dc\")\npublic String dc() throws InterruptedException {\n    Thread.sleep(5000L);\n    String services = \"Services: \" + discoveryClient.getServices();\n    System.out.println(services);\n    return services;\n}\n```\n\n重启`eureka-client`之后，再尝试访问`localhost:2101/consumer`,此时我们将获得的返回结果为：`fallback`。我们从`eureka-client`的控制台中，可以看到服务提供方输出了原本要返回的结果，但是由于返回前延迟了5秒，而服务消费方触发了服务请求超时异常，服务消费者就通过HystrixCommand注解中指定的降级逻辑进行执行，因此该请求的结果返回了`fallback`。这样的机制，对自身服务起到了基础的保护，同时还为异常情况提供了自动的服务降级切换机制。\n\n具体工程说明如下：\n\n- eureka的服务注册中心：eureka-server\n- eureka的服务提供方：eureka-client\n- eureka的服务消费者：eureka-consumer-ribbon-hystrix\n","slug":"spring-cloud6","published":1,"updated":"2019-12-24T02:00:57.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jxf001h0j9k55ebuvqd","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元应用间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，线程资源无法释放，最终导致自身服务的瘫痪，进一步甚至出现故障的蔓延最终导致整个系统的瘫痪。如果这样的架构存在如此严重的隐患，那么相较传统架构就更加的不稳定。为了解决这样的问题，因此产生了断路器等一系列的服务保护机制。</p>\n<p>针对上述问题，在Spring Cloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。</p>\n<p>接下来，我们就从一个简单示例开始对Spring Cloud Hystrix的学习与使用。</p>\n<h1 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h1><p>在开始使用Spring Cloud Hystrix实现断路器之前，我们先拿之前实现的一些内容作为基础，其中包括：</p>\n<ul>\n<li>eureka-server工程：服务注册中心，端口：1001</li>\n<li>eureka-client工程：服务提供者，端口：2001</li>\n</ul>\n<p>下面我们可以复制一下之前实现的一个服务消费者：<code>eureka-consumer-ribbon</code>命名为<code>eureka-consumer-ribbon-hystrix</code>下面我们开始对其进行修改：</p>\n<p>第一步<code>pom.xml</code>的dependencies节点中引入<code>spring-cloud-starter-hystrix</code>依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>第二步：在应用主类中使用<code>@EnableCircuitBreaker</code>或<code>@EnableHystrix</code>注解开启Hystrix的使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableCircuitBreaker</span><br><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Bean</span><br><span class=\"line\">\t@LoadBalanced</span><br><span class=\"line\">\tpublic RestTemplate restTemplate() &#123;</span><br><span class=\"line\">\t\treturn new RestTemplate();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tnew SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>注意：这里我们还可以使用Spring Cloud应用中的<code>@SpringCloudApplication</code>注解来修饰应用主类，该注解的具体定义如下所示。我们可以看到该注解中包含了上我们所引用的三个注解，这也意味着一个Spring Cloud标准应用应包含服务发现以及断路器。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">@Inherited</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@EnableCircuitBreaker</span><br><span class=\"line\">public @interface SpringCloudApplication &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三步：改造服务消费方式，新增<code>ConsumerService</code>类,然后将在<code>Controller</code>中的逻辑迁移过去。最后，在为具体执行逻辑的函数上增加<code>@HystrixCommand</code>注解来指定服务降级方法，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class DcController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    ConsumerService consumerService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @GetMapping(&quot;/consumer&quot;)</span><br><span class=\"line\">    public String dc() &#123;</span><br><span class=\"line\">        return consumerService.consumer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class ConsumerService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Autowired</span><br><span class=\"line\">        RestTemplate restTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">        @HystrixCommand(fallbackMethod = &quot;fallback&quot;)</span><br><span class=\"line\">        public String consumer() &#123;</span><br><span class=\"line\">            return restTemplate.getForObject(&quot;http://eureka-client/dc&quot;, String.class);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public String fallback() &#123;</span><br><span class=\"line\">            return &quot;fallback&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面我们来验证一下上面Hystrix带来的一些基础功能。我们先把涉及的服务都启动起来，然后访问<code>localhost:2101/consumer</code>此时可以获取正常的返回，比如：<code>Services: [eureka-consumer-ribbon-hystrix, eureka-client]</code></p>\n<p>为了触发服务降级逻辑，我们可以将服务提供者<code>eureka-client</code>的逻辑加一些延迟，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GetMapping(&quot;/dc&quot;)</span><br><span class=\"line\">public String dc() throws InterruptedException &#123;</span><br><span class=\"line\">    Thread.sleep(5000L);</span><br><span class=\"line\">    String services = &quot;Services: &quot; + discoveryClient.getServices();</span><br><span class=\"line\">    System.out.println(services);</span><br><span class=\"line\">    return services;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重启<code>eureka-client</code>之后，再尝试访问<code>localhost:2101/consumer</code>,此时我们将获得的返回结果为：<code>fallback</code>。我们从<code>eureka-client</code>的控制台中，可以看到服务提供方输出了原本要返回的结果，但是由于返回前延迟了5秒，而服务消费方触发了服务请求超时异常，服务消费者就通过HystrixCommand注解中指定的降级逻辑进行执行，因此该请求的结果返回了<code>fallback</code>。这样的机制，对自身服务起到了基础的保护，同时还为异常情况提供了自动的服务降级切换机制。</p>\n<p>具体工程说明如下：</p>\n<ul>\n<li>eureka的服务注册中心：eureka-server</li>\n<li>eureka的服务提供方：eureka-client</li>\n<li>eureka的服务消费者：eureka-consumer-ribbon-hystrix</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元应用间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，线程资源无法释放，最终导致自身服务的瘫痪，进一步甚至出现故障的蔓延最终导致整个系统的瘫痪。如果这样的架构存在如此严重的隐患，那么相较传统架构就更加的不稳定。为了解决这样的问题，因此产生了断路器等一系列的服务保护机制。</p>\n<p>针对上述问题，在Spring Cloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。</p>\n<p>接下来，我们就从一个简单示例开始对Spring Cloud Hystrix的学习与使用。</p>\n<h1 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h1><p>在开始使用Spring Cloud Hystrix实现断路器之前，我们先拿之前实现的一些内容作为基础，其中包括：</p>\n<ul>\n<li>eureka-server工程：服务注册中心，端口：1001</li>\n<li>eureka-client工程：服务提供者，端口：2001</li>\n</ul>\n<p>下面我们可以复制一下之前实现的一个服务消费者：<code>eureka-consumer-ribbon</code>命名为<code>eureka-consumer-ribbon-hystrix</code>下面我们开始对其进行修改：</p>\n<p>第一步<code>pom.xml</code>的dependencies节点中引入<code>spring-cloud-starter-hystrix</code>依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>第二步：在应用主类中使用<code>@EnableCircuitBreaker</code>或<code>@EnableHystrix</code>注解开启Hystrix的使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableCircuitBreaker</span><br><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Bean</span><br><span class=\"line\">\t@LoadBalanced</span><br><span class=\"line\">\tpublic RestTemplate restTemplate() &#123;</span><br><span class=\"line\">\t\treturn new RestTemplate();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tnew SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>注意：这里我们还可以使用Spring Cloud应用中的<code>@SpringCloudApplication</code>注解来修饰应用主类，该注解的具体定义如下所示。我们可以看到该注解中包含了上我们所引用的三个注解，这也意味着一个Spring Cloud标准应用应包含服务发现以及断路器。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">@Inherited</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@EnableCircuitBreaker</span><br><span class=\"line\">public @interface SpringCloudApplication &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三步：改造服务消费方式，新增<code>ConsumerService</code>类,然后将在<code>Controller</code>中的逻辑迁移过去。最后，在为具体执行逻辑的函数上增加<code>@HystrixCommand</code>注解来指定服务降级方法，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class DcController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    ConsumerService consumerService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @GetMapping(&quot;/consumer&quot;)</span><br><span class=\"line\">    public String dc() &#123;</span><br><span class=\"line\">        return consumerService.consumer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class ConsumerService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Autowired</span><br><span class=\"line\">        RestTemplate restTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">        @HystrixCommand(fallbackMethod = &quot;fallback&quot;)</span><br><span class=\"line\">        public String consumer() &#123;</span><br><span class=\"line\">            return restTemplate.getForObject(&quot;http://eureka-client/dc&quot;, String.class);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public String fallback() &#123;</span><br><span class=\"line\">            return &quot;fallback&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面我们来验证一下上面Hystrix带来的一些基础功能。我们先把涉及的服务都启动起来，然后访问<code>localhost:2101/consumer</code>此时可以获取正常的返回，比如：<code>Services: [eureka-consumer-ribbon-hystrix, eureka-client]</code></p>\n<p>为了触发服务降级逻辑，我们可以将服务提供者<code>eureka-client</code>的逻辑加一些延迟，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GetMapping(&quot;/dc&quot;)</span><br><span class=\"line\">public String dc() throws InterruptedException &#123;</span><br><span class=\"line\">    Thread.sleep(5000L);</span><br><span class=\"line\">    String services = &quot;Services: &quot; + discoveryClient.getServices();</span><br><span class=\"line\">    System.out.println(services);</span><br><span class=\"line\">    return services;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重启<code>eureka-client</code>之后，再尝试访问<code>localhost:2101/consumer</code>,此时我们将获得的返回结果为：<code>fallback</code>。我们从<code>eureka-client</code>的控制台中，可以看到服务提供方输出了原本要返回的结果，但是由于返回前延迟了5秒，而服务消费方触发了服务请求超时异常，服务消费者就通过HystrixCommand注解中指定的降级逻辑进行执行，因此该请求的结果返回了<code>fallback</code>。这样的机制，对自身服务起到了基础的保护，同时还为异常情况提供了自动的服务降级切换机制。</p>\n<p>具体工程说明如下：</p>\n<ul>\n<li>eureka的服务注册中心：eureka-server</li>\n<li>eureka的服务提供方：eureka-client</li>\n<li>eureka的服务消费者：eureka-consumer-ribbon-hystrix</li>\n</ul>\n"},{"title":"7.Spring Cloud构建微服务架构：Hystrix监控面板【Dalston版】","date":"2018-04-11T01:16:17.000Z","_content":"\n> 在上一篇《服务容错保护（hystrix断路器）》的介绍中，我们提到断路器是根据一段时间窗内的请求情况来判断并操作断路器的打开和关闭状态的。而这些请求情况的指标信息都是HystrixCommand和HystrixObservableCommand实例在执行过程中记录的重要度量信息，它们除了Hystrix断路器实现中使用之外，对于系统运维也有非常大的帮助。这些指标信息会以“滚动时间窗”与“桶”结合的方式进行汇总，并在内存中驻留一段时间，以供内部或外部进行查询使用，Hystrix Dashboard就是这些指标内容的消费者之一。\n\n下面我们基于之前的示例来结合Hystrix Dashboard实现Hystrix指标数据的可视化面板，这里我们将用到下之前实现的几个应用，包括：\n\n- eureka-server：服务注册中心\n- eureka-client：服务提供者\n- eureka-consumer-ribbon-hystrix：使用ribbon和hystrix实现的服务消费者\n\n由于eureka-consumer-ribbon-hystrix项目中的/consumer接口实现使用了@HystrixCommand修饰，所以这个接口的调用情况会被Hystrix记录下来，以用来给断路器和Hystrix Dashboard使用。断路器我们在上一篇中已经介绍过了，下面我们来具体说说Hystrix Dashboard的构建。\n\n# 试一试\n\n在Spring Cloud中构建一个Hystrix Dashboard非常简单，只需要下面四步：\n\n- 创建一个标准的Spring Boot工程，命名为：hystrix-dashboard。\n- 编辑pom.xml，具体依赖内容如下：\n\n```\n<parent>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-parent</artifactId>\n\t<version>Dalston.SR1</version>\n\t<relativePath />\n</parent>\n<dependencies>\n\t<dependency>\n\t\t<groupId>org.springframework.cloud</groupId>\n\t\t<artifactId>spring-cloud-starter-hystrix</artifactId>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>org.springframework.cloud</groupId>\n\t\t<artifactId>spring-cloud-starter-hystrix-dashboard</artifactId>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-actuator</artifactId>\n\t</dependency>\n</dependencies>\n```\n\n- 为应用主类加上`@EnableHystrixDashboard`，启用Hystrix Dashboard功能。\n\n```\n@EnableHystrixDashboard\n@SpringCloudApplication\npublic class HystrixDashboardApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(HystrixDashboardApplication.class, args);\n\t}\n}\n```\n\n- 根据实际情况修改`application.properties`配置文件，比如：选择一个未被占用的端口等，此步非必须。\n\n```\nspring.application.name=hystrix-dashboard\nserver.port=1301\n```\n\n到这里我们已经完成了基本配置，接下来我们可以启动该应用，并访问：`http://localhost:1301/hystrix`我们可以看到如下页面：\n\n![hystrix](http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-1.png)\n\n这是Hystrix Dashboard的监控首页，该页面中并没有具体的监控信息。从页面的文字内容中我们可以知道，Hystrix Dashboard共支持三种不同的监控方式，依次为：\n\n- 默认的集群监控：通过URL`http://turbine-hostname:port/turbine.stream`开启，实现对默认集群的监控。\n- 指定的集群监控：通过URL`http://turbine-hostname:port/turbine.stream?cluster=[clusterName]`开启，实现对clusterName集群的监控。\n- 单体应用的监控：通过URLhttp://hystrix-app:port/hystrix.stream开启，实现对具体某个服务实例的监控。\n\n前两者都对集群的监控，需要整合Turbine才能实现，这部分内容我们将在下一篇中做详细介绍。在本节中，我们主要实现对单个服务实例的监控，所以这里我们先来实现单个服务实例的监控。\n\n既然Hystrix Dashboard监控单实例节点需要通过访问实例的`/hystrix.stream`接口来实现，自然我们需要为服务实例添加这个端点，而添加该功能的步骤也同样简单，只需要下面两步：\n\n- 在服务实例`pom.xml`中的`dependencies`节点中新增`spring-boot-starter-actuator`监控模块以开启监控相关的端点，并确保已经引入断路器的依赖`spring-cloud-starter-hystrix`:\n\n```\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-hystrix</artifactId>\n</dependency>\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n- 确保在服务实例的主类中已经使用`@EnableCircuitBreaker`或`@EnableHystrix`注解，开启了断路器功能。\n\n到这里已经完成了所有的配置，我们可以在Hystrix Dashboard的首页输入`http://localhost:2101/hystrix.stream`,已启动对“eureka-consumer-ribbon-hystrix”的监控，点击“Monitor Stream”按钮，此时我们可以看到如下页面：\n\n![pirc](http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-2.png)\n\n\n在对该页面介绍前，我们先看看在首页中我们还没有介绍的两外两个参数：\n\n- `Delay`:该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒，我们可以通过配置该属性来降低客户端的网络和CPU消耗。\n- `Title`:该参数对应了上图头部标题Hystrix Stream之后的内容，默认会使用具体监控实例的URL，我们可以通过配置该信息来展示更合适的标题。\n\n回到监控页面，我们来详细说说其中各元素的具体含义：\n\n- 实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，如下图所示，它的健康度从绿色、黄色、橙色、红色递减。该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，我们就可以在大量的实例中快速的发现故障实例和高压力实例。\n\n![](http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-3.png)\n\n- 曲线：用来记录2分钟内流量的相对变化，我们可以通过它来观察到流量的上升和下降趋势,其他一些数量指标如下图所示\n\n![](http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-4.png)\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","source":"_posts/spring-cloud7.md","raw":"---\ntitle: 7.Spring Cloud构建微服务架构：Hystrix监控面板【Dalston版】\ndate: 2018-04-11 09:16:17\ntags:\ncategories: 微服务\n---\n\n> 在上一篇《服务容错保护（hystrix断路器）》的介绍中，我们提到断路器是根据一段时间窗内的请求情况来判断并操作断路器的打开和关闭状态的。而这些请求情况的指标信息都是HystrixCommand和HystrixObservableCommand实例在执行过程中记录的重要度量信息，它们除了Hystrix断路器实现中使用之外，对于系统运维也有非常大的帮助。这些指标信息会以“滚动时间窗”与“桶”结合的方式进行汇总，并在内存中驻留一段时间，以供内部或外部进行查询使用，Hystrix Dashboard就是这些指标内容的消费者之一。\n\n下面我们基于之前的示例来结合Hystrix Dashboard实现Hystrix指标数据的可视化面板，这里我们将用到下之前实现的几个应用，包括：\n\n- eureka-server：服务注册中心\n- eureka-client：服务提供者\n- eureka-consumer-ribbon-hystrix：使用ribbon和hystrix实现的服务消费者\n\n由于eureka-consumer-ribbon-hystrix项目中的/consumer接口实现使用了@HystrixCommand修饰，所以这个接口的调用情况会被Hystrix记录下来，以用来给断路器和Hystrix Dashboard使用。断路器我们在上一篇中已经介绍过了，下面我们来具体说说Hystrix Dashboard的构建。\n\n# 试一试\n\n在Spring Cloud中构建一个Hystrix Dashboard非常简单，只需要下面四步：\n\n- 创建一个标准的Spring Boot工程，命名为：hystrix-dashboard。\n- 编辑pom.xml，具体依赖内容如下：\n\n```\n<parent>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-parent</artifactId>\n\t<version>Dalston.SR1</version>\n\t<relativePath />\n</parent>\n<dependencies>\n\t<dependency>\n\t\t<groupId>org.springframework.cloud</groupId>\n\t\t<artifactId>spring-cloud-starter-hystrix</artifactId>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>org.springframework.cloud</groupId>\n\t\t<artifactId>spring-cloud-starter-hystrix-dashboard</artifactId>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-actuator</artifactId>\n\t</dependency>\n</dependencies>\n```\n\n- 为应用主类加上`@EnableHystrixDashboard`，启用Hystrix Dashboard功能。\n\n```\n@EnableHystrixDashboard\n@SpringCloudApplication\npublic class HystrixDashboardApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(HystrixDashboardApplication.class, args);\n\t}\n}\n```\n\n- 根据实际情况修改`application.properties`配置文件，比如：选择一个未被占用的端口等，此步非必须。\n\n```\nspring.application.name=hystrix-dashboard\nserver.port=1301\n```\n\n到这里我们已经完成了基本配置，接下来我们可以启动该应用，并访问：`http://localhost:1301/hystrix`我们可以看到如下页面：\n\n![hystrix](http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-1.png)\n\n这是Hystrix Dashboard的监控首页，该页面中并没有具体的监控信息。从页面的文字内容中我们可以知道，Hystrix Dashboard共支持三种不同的监控方式，依次为：\n\n- 默认的集群监控：通过URL`http://turbine-hostname:port/turbine.stream`开启，实现对默认集群的监控。\n- 指定的集群监控：通过URL`http://turbine-hostname:port/turbine.stream?cluster=[clusterName]`开启，实现对clusterName集群的监控。\n- 单体应用的监控：通过URLhttp://hystrix-app:port/hystrix.stream开启，实现对具体某个服务实例的监控。\n\n前两者都对集群的监控，需要整合Turbine才能实现，这部分内容我们将在下一篇中做详细介绍。在本节中，我们主要实现对单个服务实例的监控，所以这里我们先来实现单个服务实例的监控。\n\n既然Hystrix Dashboard监控单实例节点需要通过访问实例的`/hystrix.stream`接口来实现，自然我们需要为服务实例添加这个端点，而添加该功能的步骤也同样简单，只需要下面两步：\n\n- 在服务实例`pom.xml`中的`dependencies`节点中新增`spring-boot-starter-actuator`监控模块以开启监控相关的端点，并确保已经引入断路器的依赖`spring-cloud-starter-hystrix`:\n\n```\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-hystrix</artifactId>\n</dependency>\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n- 确保在服务实例的主类中已经使用`@EnableCircuitBreaker`或`@EnableHystrix`注解，开启了断路器功能。\n\n到这里已经完成了所有的配置，我们可以在Hystrix Dashboard的首页输入`http://localhost:2101/hystrix.stream`,已启动对“eureka-consumer-ribbon-hystrix”的监控，点击“Monitor Stream”按钮，此时我们可以看到如下页面：\n\n![pirc](http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-2.png)\n\n\n在对该页面介绍前，我们先看看在首页中我们还没有介绍的两外两个参数：\n\n- `Delay`:该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒，我们可以通过配置该属性来降低客户端的网络和CPU消耗。\n- `Title`:该参数对应了上图头部标题Hystrix Stream之后的内容，默认会使用具体监控实例的URL，我们可以通过配置该信息来展示更合适的标题。\n\n回到监控页面，我们来详细说说其中各元素的具体含义：\n\n- 实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，如下图所示，它的健康度从绿色、黄色、橙色、红色递减。该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，我们就可以在大量的实例中快速的发现故障实例和高压力实例。\n\n![](http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-3.png)\n\n- 曲线：用来记录2分钟内流量的相对变化，我们可以通过它来观察到流量的上升和下降趋势,其他一些数量指标如下图所示\n\n![](http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-4.png)\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","slug":"spring-cloud7","published":1,"updated":"2019-12-24T02:00:57.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jxh001j0j9kx3hqse6m","content":"<blockquote>\n<p>在上一篇《服务容错保护（hystrix断路器）》的介绍中，我们提到断路器是根据一段时间窗内的请求情况来判断并操作断路器的打开和关闭状态的。而这些请求情况的指标信息都是HystrixCommand和HystrixObservableCommand实例在执行过程中记录的重要度量信息，它们除了Hystrix断路器实现中使用之外，对于系统运维也有非常大的帮助。这些指标信息会以“滚动时间窗”与“桶”结合的方式进行汇总，并在内存中驻留一段时间，以供内部或外部进行查询使用，Hystrix Dashboard就是这些指标内容的消费者之一。</p>\n</blockquote>\n<p>下面我们基于之前的示例来结合Hystrix Dashboard实现Hystrix指标数据的可视化面板，这里我们将用到下之前实现的几个应用，包括：</p>\n<ul>\n<li>eureka-server：服务注册中心</li>\n<li>eureka-client：服务提供者</li>\n<li>eureka-consumer-ribbon-hystrix：使用ribbon和hystrix实现的服务消费者</li>\n</ul>\n<p>由于eureka-consumer-ribbon-hystrix项目中的/consumer接口实现使用了@HystrixCommand修饰，所以这个接口的调用情况会被Hystrix记录下来，以用来给断路器和Hystrix Dashboard使用。断路器我们在上一篇中已经介绍过了，下面我们来具体说说Hystrix Dashboard的构建。</p>\n<h1 id=\"试一试\"><a href=\"#试一试\" class=\"headerlink\" title=\"试一试\"></a>试一试</h1><p>在Spring Cloud中构建一个Hystrix Dashboard非常简单，只需要下面四步：</p>\n<ul>\n<li>创建一个标准的Spring Boot工程，命名为：hystrix-dashboard。</li>\n<li>编辑pom.xml，具体依赖内容如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-cloud-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class=\"line\">\t&lt;relativePath /&gt;</span><br><span class=\"line\">&lt;/parent&gt;</span><br><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t\t&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t\t&lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">\t\t&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>为应用主类加上<code>@EnableHystrixDashboard</code>，启用Hystrix Dashboard功能。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableHystrixDashboard</span><br><span class=\"line\">@SpringCloudApplication</span><br><span class=\"line\">public class HystrixDashboardApplication &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tSpringApplication.run(HystrixDashboardApplication.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>根据实际情况修改<code>application.properties</code>配置文件，比如：选择一个未被占用的端口等，此步非必须。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=hystrix-dashboard</span><br><span class=\"line\">server.port=1301</span><br></pre></td></tr></table></figure>\n<p>到这里我们已经完成了基本配置，接下来我们可以启动该应用，并访问：<code>http://localhost:1301/hystrix</code>我们可以看到如下页面：</p>\n<p><img src=\"http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-1.png\" alt=\"hystrix\"></p>\n<p>这是Hystrix Dashboard的监控首页，该页面中并没有具体的监控信息。从页面的文字内容中我们可以知道，Hystrix Dashboard共支持三种不同的监控方式，依次为：</p>\n<ul>\n<li>默认的集群监控：通过URL<code>http://turbine-hostname:port/turbine.stream</code>开启，实现对默认集群的监控。</li>\n<li>指定的集群监控：通过URL<code>http://turbine-hostname:port/turbine.stream?cluster=[clusterName]</code>开启，实现对clusterName集群的监控。</li>\n<li>单体应用的监控：通过URL<a href=\"http://hystrix-app:port/hystrix.stream开启，实现对具体某个服务实例的监控。\" target=\"_blank\" rel=\"noopener\">http://hystrix-app:port/hystrix.stream开启，实现对具体某个服务实例的监控。</a></li>\n</ul>\n<p>前两者都对集群的监控，需要整合Turbine才能实现，这部分内容我们将在下一篇中做详细介绍。在本节中，我们主要实现对单个服务实例的监控，所以这里我们先来实现单个服务实例的监控。</p>\n<p>既然Hystrix Dashboard监控单实例节点需要通过访问实例的<code>/hystrix.stream</code>接口来实现，自然我们需要为服务实例添加这个端点，而添加该功能的步骤也同样简单，只需要下面两步：</p>\n<ul>\n<li>在服务实例<code>pom.xml</code>中的<code>dependencies</code>节点中新增<code>spring-boot-starter-actuator</code>监控模块以开启监控相关的端点，并确保已经引入断路器的依赖<code>spring-cloud-starter-hystrix</code>:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>确保在服务实例的主类中已经使用<code>@EnableCircuitBreaker</code>或<code>@EnableHystrix</code>注解，开启了断路器功能。</li>\n</ul>\n<p>到这里已经完成了所有的配置，我们可以在Hystrix Dashboard的首页输入<code>http://localhost:2101/hystrix.stream</code>,已启动对“eureka-consumer-ribbon-hystrix”的监控，点击“Monitor Stream”按钮，此时我们可以看到如下页面：</p>\n<p><img src=\"http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-2.png\" alt=\"pirc\"></p>\n<p>在对该页面介绍前，我们先看看在首页中我们还没有介绍的两外两个参数：</p>\n<ul>\n<li><code>Delay</code>:该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒，我们可以通过配置该属性来降低客户端的网络和CPU消耗。</li>\n<li><code>Title</code>:该参数对应了上图头部标题Hystrix Stream之后的内容，默认会使用具体监控实例的URL，我们可以通过配置该信息来展示更合适的标题。</li>\n</ul>\n<p>回到监控页面，我们来详细说说其中各元素的具体含义：</p>\n<ul>\n<li>实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，如下图所示，它的健康度从绿色、黄色、橙色、红色递减。该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，我们就可以在大量的实例中快速的发现故障实例和高压力实例。</li>\n</ul>\n<p><img src=\"http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-3.png\" alt=\"\"></p>\n<ul>\n<li>曲线：用来记录2分钟内流量的相对变化，我们可以通过它来观察到流量的上升和下降趋势,其他一些数量指标如下图所示</li>\n</ul>\n<p><img src=\"http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-4.png\" alt=\"\"></p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在上一篇《服务容错保护（hystrix断路器）》的介绍中，我们提到断路器是根据一段时间窗内的请求情况来判断并操作断路器的打开和关闭状态的。而这些请求情况的指标信息都是HystrixCommand和HystrixObservableCommand实例在执行过程中记录的重要度量信息，它们除了Hystrix断路器实现中使用之外，对于系统运维也有非常大的帮助。这些指标信息会以“滚动时间窗”与“桶”结合的方式进行汇总，并在内存中驻留一段时间，以供内部或外部进行查询使用，Hystrix Dashboard就是这些指标内容的消费者之一。</p>\n</blockquote>\n<p>下面我们基于之前的示例来结合Hystrix Dashboard实现Hystrix指标数据的可视化面板，这里我们将用到下之前实现的几个应用，包括：</p>\n<ul>\n<li>eureka-server：服务注册中心</li>\n<li>eureka-client：服务提供者</li>\n<li>eureka-consumer-ribbon-hystrix：使用ribbon和hystrix实现的服务消费者</li>\n</ul>\n<p>由于eureka-consumer-ribbon-hystrix项目中的/consumer接口实现使用了@HystrixCommand修饰，所以这个接口的调用情况会被Hystrix记录下来，以用来给断路器和Hystrix Dashboard使用。断路器我们在上一篇中已经介绍过了，下面我们来具体说说Hystrix Dashboard的构建。</p>\n<h1 id=\"试一试\"><a href=\"#试一试\" class=\"headerlink\" title=\"试一试\"></a>试一试</h1><p>在Spring Cloud中构建一个Hystrix Dashboard非常简单，只需要下面四步：</p>\n<ul>\n<li>创建一个标准的Spring Boot工程，命名为：hystrix-dashboard。</li>\n<li>编辑pom.xml，具体依赖内容如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-cloud-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class=\"line\">\t&lt;relativePath /&gt;</span><br><span class=\"line\">&lt;/parent&gt;</span><br><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t\t&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t\t&lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">\t\t&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>为应用主类加上<code>@EnableHystrixDashboard</code>，启用Hystrix Dashboard功能。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableHystrixDashboard</span><br><span class=\"line\">@SpringCloudApplication</span><br><span class=\"line\">public class HystrixDashboardApplication &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tSpringApplication.run(HystrixDashboardApplication.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>根据实际情况修改<code>application.properties</code>配置文件，比如：选择一个未被占用的端口等，此步非必须。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=hystrix-dashboard</span><br><span class=\"line\">server.port=1301</span><br></pre></td></tr></table></figure>\n<p>到这里我们已经完成了基本配置，接下来我们可以启动该应用，并访问：<code>http://localhost:1301/hystrix</code>我们可以看到如下页面：</p>\n<p><img src=\"http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-1.png\" alt=\"hystrix\"></p>\n<p>这是Hystrix Dashboard的监控首页，该页面中并没有具体的监控信息。从页面的文字内容中我们可以知道，Hystrix Dashboard共支持三种不同的监控方式，依次为：</p>\n<ul>\n<li>默认的集群监控：通过URL<code>http://turbine-hostname:port/turbine.stream</code>开启，实现对默认集群的监控。</li>\n<li>指定的集群监控：通过URL<code>http://turbine-hostname:port/turbine.stream?cluster=[clusterName]</code>开启，实现对clusterName集群的监控。</li>\n<li>单体应用的监控：通过URL<a href=\"http://hystrix-app:port/hystrix.stream开启，实现对具体某个服务实例的监控。\" target=\"_blank\" rel=\"noopener\">http://hystrix-app:port/hystrix.stream开启，实现对具体某个服务实例的监控。</a></li>\n</ul>\n<p>前两者都对集群的监控，需要整合Turbine才能实现，这部分内容我们将在下一篇中做详细介绍。在本节中，我们主要实现对单个服务实例的监控，所以这里我们先来实现单个服务实例的监控。</p>\n<p>既然Hystrix Dashboard监控单实例节点需要通过访问实例的<code>/hystrix.stream</code>接口来实现，自然我们需要为服务实例添加这个端点，而添加该功能的步骤也同样简单，只需要下面两步：</p>\n<ul>\n<li>在服务实例<code>pom.xml</code>中的<code>dependencies</code>节点中新增<code>spring-boot-starter-actuator</code>监控模块以开启监控相关的端点，并确保已经引入断路器的依赖<code>spring-cloud-starter-hystrix</code>:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>确保在服务实例的主类中已经使用<code>@EnableCircuitBreaker</code>或<code>@EnableHystrix</code>注解，开启了断路器功能。</li>\n</ul>\n<p>到这里已经完成了所有的配置，我们可以在Hystrix Dashboard的首页输入<code>http://localhost:2101/hystrix.stream</code>,已启动对“eureka-consumer-ribbon-hystrix”的监控，点击“Monitor Stream”按钮，此时我们可以看到如下页面：</p>\n<p><img src=\"http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-2.png\" alt=\"pirc\"></p>\n<p>在对该页面介绍前，我们先看看在首页中我们还没有介绍的两外两个参数：</p>\n<ul>\n<li><code>Delay</code>:该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒，我们可以通过配置该属性来降低客户端的网络和CPU消耗。</li>\n<li><code>Title</code>:该参数对应了上图头部标题Hystrix Stream之后的内容，默认会使用具体监控实例的URL，我们可以通过配置该信息来展示更合适的标题。</li>\n</ul>\n<p>回到监控页面，我们来详细说说其中各元素的具体含义：</p>\n<ul>\n<li>实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，如下图所示，它的健康度从绿色、黄色、橙色、红色递减。该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，我们就可以在大量的实例中快速的发现故障实例和高压力实例。</li>\n</ul>\n<p><img src=\"http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-3.png\" alt=\"\"></p>\n<ul>\n<li>曲线：用来记录2分钟内流量的相对变化，我们可以通过它来观察到流量的上升和下降趋势,其他一些数量指标如下图所示</li>\n</ul>\n<p><img src=\"http://www.wailian.work/images/2018/04/11/spring-cloud-starter-dalston-5-1-4.png\" alt=\"\"></p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n"},{"title":"8.Spring Cloud构建微服务架构：服务网关（基础）【Dalston版】","date":"2018-04-11T06:11:45.000Z","_content":"\n通过之前几篇Spring Cloud中几个核心组件的介绍，我们已经可以构建一个简略的（不够完善）微服务架构了。比如下图所示：\n\n![](http://www.wailian.work/images/2018/04/11/-----.png)\n\n我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。\n\n在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。本文我们把焦点聚集在对外服务这块，这样的实现是否合理，或者是否有更好的实现方式呢？\n\n先来说说这样架构需要做的一些事儿以及存在的不足：\n\n- 首先，破坏了服务无状态特点。为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外可续对接口访问的控制处理。\n\n- 其次，无法直接复用既有接口。当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。\n\n面对类似上面的问题，我们要如何解决呢？下面进入本文的正题：服务网关！\n\n为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器，它就是本文将来介绍的：服务网关。\n\n服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。\n\n下面我们通过实例例子来使用一下Zuul来作为服务的路有功能。\n\n# 准备工作\n\n- eureka-client\n- eureka-consumer\n\n# 构建服务网关\n\n使用Spring Cloud Zuul来构建服务网关的基础步骤非常简单，只需要下面几步：\n\n- 创建一个基础的Spring Boot项目，命名为：`api-gateway`。并在`pom.xml`中引入依赖：\n\n```\n<parent>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-parent</artifactId>\n  <version>1.5.4.RELEASE</version>\n  <relativePath/>\n</parent>\n\n<dependencies>\n  <dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-zuul</artifactId>\n  </dependency>\n  <dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-eureka</artifactId>\n  </dependency>\n</dependencies>\n\n<dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-dependencies</artifactId>\n      <version>Dalston.SR1</version>\n      <type>pom</type>\n      <scope>import</scope>\n    </dependency>\n  </dependencies>\n</dependencyManagement>\n```\n\n- 创建应用主类，并使用`@EnableZuulProxy`注解开启Zuul的功能。\n\n```\n@EnableZuulProxy\n@SpringCloudApplication\npublic class Application {\n\n  public static void main(String[] args) {\n    new SpringApplicationBuilder(Application.class).web(true).run(args);\n  }\n\n}\n```\n\n- 创建配置文件`application.yaml`，并加入服务名、端口号、eureka注册中心的地址：\n\n```\nspring:\n  application:\n    name: api-gateway\n\nserver:\n  port: 1101\n\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://eureka.didispace.com/eureka/\n```\n\n到这里，一个基于Spring Cloud Zuul服务网关就已经构建完毕。启动该应用，一个默认的服务网关就构建完毕了。由于Spring Cloud Zuul在整合了Eureka之后，具备默认的服务路由功能，即：当我们这里构建的`api-gateway`应用启动并注册到eureka之后，服务网关会发现上面我们启动的两个服务`eureka-client`和`eureka-consumer`，这时候Zuul就会创建两个路由规则。每个路由规则都包含两部分，一部分是外部请求的匹配规则，另一部分是路由的服务ID。针对当前示例的情况，Zuul会创建下面的两个路由规则：\n\n- 转发到`eureka-client`服务的请求规则为：`/eureka-client/**`\n- 转发到`eureka-consumer`服务的请求规则为：`/eureka-consumer/**`\n\n最后，我们可以通过访问`1101`端口的服务网关来验证上述路由的正确性：\n\n- 比如访问：`http://localhost:1101/eureka-client/dc `，该请求将最终被路由到`eureka-client`的`/dc`接口上。\n\n# 本篇小结\n\n本篇，我们介绍了构建服务网关的基础。通过上面的构建内容，我们已经为所有内部服务提供了一个统一的对外入口，同时对于服务的路由都是自动创建了，减少了传统方式大量的运维配置工作。\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","source":"_posts/spring-cloud8.md","raw":"---\ntitle: 8.Spring Cloud构建微服务架构：服务网关（基础）【Dalston版】 \ndate: 2018-04-11 14:11:45\ntags:\ncategories: 微服务\n---\n\n通过之前几篇Spring Cloud中几个核心组件的介绍，我们已经可以构建一个简略的（不够完善）微服务架构了。比如下图所示：\n\n![](http://www.wailian.work/images/2018/04/11/-----.png)\n\n我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。\n\n在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。本文我们把焦点聚集在对外服务这块，这样的实现是否合理，或者是否有更好的实现方式呢？\n\n先来说说这样架构需要做的一些事儿以及存在的不足：\n\n- 首先，破坏了服务无状态特点。为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外可续对接口访问的控制处理。\n\n- 其次，无法直接复用既有接口。当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。\n\n面对类似上面的问题，我们要如何解决呢？下面进入本文的正题：服务网关！\n\n为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器，它就是本文将来介绍的：服务网关。\n\n服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。\n\n下面我们通过实例例子来使用一下Zuul来作为服务的路有功能。\n\n# 准备工作\n\n- eureka-client\n- eureka-consumer\n\n# 构建服务网关\n\n使用Spring Cloud Zuul来构建服务网关的基础步骤非常简单，只需要下面几步：\n\n- 创建一个基础的Spring Boot项目，命名为：`api-gateway`。并在`pom.xml`中引入依赖：\n\n```\n<parent>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-parent</artifactId>\n  <version>1.5.4.RELEASE</version>\n  <relativePath/>\n</parent>\n\n<dependencies>\n  <dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-zuul</artifactId>\n  </dependency>\n  <dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-eureka</artifactId>\n  </dependency>\n</dependencies>\n\n<dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-dependencies</artifactId>\n      <version>Dalston.SR1</version>\n      <type>pom</type>\n      <scope>import</scope>\n    </dependency>\n  </dependencies>\n</dependencyManagement>\n```\n\n- 创建应用主类，并使用`@EnableZuulProxy`注解开启Zuul的功能。\n\n```\n@EnableZuulProxy\n@SpringCloudApplication\npublic class Application {\n\n  public static void main(String[] args) {\n    new SpringApplicationBuilder(Application.class).web(true).run(args);\n  }\n\n}\n```\n\n- 创建配置文件`application.yaml`，并加入服务名、端口号、eureka注册中心的地址：\n\n```\nspring:\n  application:\n    name: api-gateway\n\nserver:\n  port: 1101\n\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://eureka.didispace.com/eureka/\n```\n\n到这里，一个基于Spring Cloud Zuul服务网关就已经构建完毕。启动该应用，一个默认的服务网关就构建完毕了。由于Spring Cloud Zuul在整合了Eureka之后，具备默认的服务路由功能，即：当我们这里构建的`api-gateway`应用启动并注册到eureka之后，服务网关会发现上面我们启动的两个服务`eureka-client`和`eureka-consumer`，这时候Zuul就会创建两个路由规则。每个路由规则都包含两部分，一部分是外部请求的匹配规则，另一部分是路由的服务ID。针对当前示例的情况，Zuul会创建下面的两个路由规则：\n\n- 转发到`eureka-client`服务的请求规则为：`/eureka-client/**`\n- 转发到`eureka-consumer`服务的请求规则为：`/eureka-consumer/**`\n\n最后，我们可以通过访问`1101`端口的服务网关来验证上述路由的正确性：\n\n- 比如访问：`http://localhost:1101/eureka-client/dc `，该请求将最终被路由到`eureka-client`的`/dc`接口上。\n\n# 本篇小结\n\n本篇，我们介绍了构建服务网关的基础。通过上面的构建内容，我们已经为所有内部服务提供了一个统一的对外入口，同时对于服务的路由都是自动创建了，减少了传统方式大量的运维配置工作。\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","slug":"spring-cloud8","published":1,"updated":"2019-12-24T02:00:57.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jxi001l0j9kht4vk5xw","content":"<p>通过之前几篇Spring Cloud中几个核心组件的介绍，我们已经可以构建一个简略的（不够完善）微服务架构了。比如下图所示：</p>\n<p><img src=\"http://www.wailian.work/images/2018/04/11/-----.png\" alt=\"\"></p>\n<p>我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。</p>\n<p>在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。本文我们把焦点聚集在对外服务这块，这样的实现是否合理，或者是否有更好的实现方式呢？</p>\n<p>先来说说这样架构需要做的一些事儿以及存在的不足：</p>\n<ul>\n<li><p>首先，破坏了服务无状态特点。为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外可续对接口访问的控制处理。</p>\n</li>\n<li><p>其次，无法直接复用既有接口。当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。</p>\n</li>\n</ul>\n<p>面对类似上面的问题，我们要如何解决呢？下面进入本文的正题：服务网关！</p>\n<p>为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器，它就是本文将来介绍的：服务网关。</p>\n<p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p>\n<p>下面我们通过实例例子来使用一下Zuul来作为服务的路有功能。</p>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><ul>\n<li>eureka-client</li>\n<li>eureka-consumer</li>\n</ul>\n<h1 id=\"构建服务网关\"><a href=\"#构建服务网关\" class=\"headerlink\" title=\"构建服务网关\"></a>构建服务网关</h1><p>使用Spring Cloud Zuul来构建服务网关的基础步骤非常简单，只需要下面几步：</p>\n<ul>\n<li>创建一个基础的Spring Boot项目，命名为：<code>api-gateway</code>。并在<code>pom.xml</code>中引入依赖：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class=\"line\">  &lt;relativePath/&gt;</span><br><span class=\"line\">&lt;/parent&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">  &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">  &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependencyManagement&gt;</span><br><span class=\"line\">  &lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class=\"line\">      &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">      &lt;scope&gt;import&lt;/scope&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">  &lt;/dependencies&gt;</span><br><span class=\"line\">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建应用主类，并使用<code>@EnableZuulProxy</code>注解开启Zuul的功能。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableZuulProxy</span><br><span class=\"line\">@SpringCloudApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  public static void main(String[] args) &#123;</span><br><span class=\"line\">    new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建配置文件<code>application.yaml</code>，并加入服务名、端口号、eureka注册中心的地址：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: api-gateway</span><br><span class=\"line\"></span><br><span class=\"line\">server:</span><br><span class=\"line\">  port: 1101</span><br><span class=\"line\"></span><br><span class=\"line\">eureka:</span><br><span class=\"line\">  client:</span><br><span class=\"line\">    serviceUrl:</span><br><span class=\"line\">      defaultZone: http://eureka.didispace.com/eureka/</span><br></pre></td></tr></table></figure>\n<p>到这里，一个基于Spring Cloud Zuul服务网关就已经构建完毕。启动该应用，一个默认的服务网关就构建完毕了。由于Spring Cloud Zuul在整合了Eureka之后，具备默认的服务路由功能，即：当我们这里构建的<code>api-gateway</code>应用启动并注册到eureka之后，服务网关会发现上面我们启动的两个服务<code>eureka-client</code>和<code>eureka-consumer</code>，这时候Zuul就会创建两个路由规则。每个路由规则都包含两部分，一部分是外部请求的匹配规则，另一部分是路由的服务ID。针对当前示例的情况，Zuul会创建下面的两个路由规则：</p>\n<ul>\n<li>转发到<code>eureka-client</code>服务的请求规则为：<code>/eureka-client/**</code></li>\n<li>转发到<code>eureka-consumer</code>服务的请求规则为：<code>/eureka-consumer/**</code></li>\n</ul>\n<p>最后，我们可以通过访问<code>1101</code>端口的服务网关来验证上述路由的正确性：</p>\n<ul>\n<li>比如访问：<code>http://localhost:1101/eureka-client/dc</code>，该请求将最终被路由到<code>eureka-client</code>的<code>/dc</code>接口上。</li>\n</ul>\n<h1 id=\"本篇小结\"><a href=\"#本篇小结\" class=\"headerlink\" title=\"本篇小结\"></a>本篇小结</h1><p>本篇，我们介绍了构建服务网关的基础。通过上面的构建内容，我们已经为所有内部服务提供了一个统一的对外入口，同时对于服务的路由都是自动创建了，减少了传统方式大量的运维配置工作。</p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>通过之前几篇Spring Cloud中几个核心组件的介绍，我们已经可以构建一个简略的（不够完善）微服务架构了。比如下图所示：</p>\n<p><img src=\"http://www.wailian.work/images/2018/04/11/-----.png\" alt=\"\"></p>\n<p>我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。</p>\n<p>在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。本文我们把焦点聚集在对外服务这块，这样的实现是否合理，或者是否有更好的实现方式呢？</p>\n<p>先来说说这样架构需要做的一些事儿以及存在的不足：</p>\n<ul>\n<li><p>首先，破坏了服务无状态特点。为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外可续对接口访问的控制处理。</p>\n</li>\n<li><p>其次，无法直接复用既有接口。当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。</p>\n</li>\n</ul>\n<p>面对类似上面的问题，我们要如何解决呢？下面进入本文的正题：服务网关！</p>\n<p>为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器，它就是本文将来介绍的：服务网关。</p>\n<p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p>\n<p>下面我们通过实例例子来使用一下Zuul来作为服务的路有功能。</p>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><ul>\n<li>eureka-client</li>\n<li>eureka-consumer</li>\n</ul>\n<h1 id=\"构建服务网关\"><a href=\"#构建服务网关\" class=\"headerlink\" title=\"构建服务网关\"></a>构建服务网关</h1><p>使用Spring Cloud Zuul来构建服务网关的基础步骤非常简单，只需要下面几步：</p>\n<ul>\n<li>创建一个基础的Spring Boot项目，命名为：<code>api-gateway</code>。并在<code>pom.xml</code>中引入依赖：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class=\"line\">  &lt;relativePath/&gt;</span><br><span class=\"line\">&lt;/parent&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">  &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">  &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependencyManagement&gt;</span><br><span class=\"line\">  &lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class=\"line\">      &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">      &lt;scope&gt;import&lt;/scope&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">  &lt;/dependencies&gt;</span><br><span class=\"line\">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建应用主类，并使用<code>@EnableZuulProxy</code>注解开启Zuul的功能。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableZuulProxy</span><br><span class=\"line\">@SpringCloudApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  public static void main(String[] args) &#123;</span><br><span class=\"line\">    new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建配置文件<code>application.yaml</code>，并加入服务名、端口号、eureka注册中心的地址：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: api-gateway</span><br><span class=\"line\"></span><br><span class=\"line\">server:</span><br><span class=\"line\">  port: 1101</span><br><span class=\"line\"></span><br><span class=\"line\">eureka:</span><br><span class=\"line\">  client:</span><br><span class=\"line\">    serviceUrl:</span><br><span class=\"line\">      defaultZone: http://eureka.didispace.com/eureka/</span><br></pre></td></tr></table></figure>\n<p>到这里，一个基于Spring Cloud Zuul服务网关就已经构建完毕。启动该应用，一个默认的服务网关就构建完毕了。由于Spring Cloud Zuul在整合了Eureka之后，具备默认的服务路由功能，即：当我们这里构建的<code>api-gateway</code>应用启动并注册到eureka之后，服务网关会发现上面我们启动的两个服务<code>eureka-client</code>和<code>eureka-consumer</code>，这时候Zuul就会创建两个路由规则。每个路由规则都包含两部分，一部分是外部请求的匹配规则，另一部分是路由的服务ID。针对当前示例的情况，Zuul会创建下面的两个路由规则：</p>\n<ul>\n<li>转发到<code>eureka-client</code>服务的请求规则为：<code>/eureka-client/**</code></li>\n<li>转发到<code>eureka-consumer</code>服务的请求规则为：<code>/eureka-consumer/**</code></li>\n</ul>\n<p>最后，我们可以通过访问<code>1101</code>端口的服务网关来验证上述路由的正确性：</p>\n<ul>\n<li>比如访问：<code>http://localhost:1101/eureka-client/dc</code>，该请求将最终被路由到<code>eureka-client</code>的<code>/dc</code>接口上。</li>\n</ul>\n<h1 id=\"本篇小结\"><a href=\"#本篇小结\" class=\"headerlink\" title=\"本篇小结\"></a>本篇小结</h1><p>本篇，我们介绍了构建服务网关的基础。通过上面的构建内容，我们已经为所有内部服务提供了一个统一的对外入口，同时对于服务的路由都是自动创建了，减少了传统方式大量的运维配置工作。</p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n"},{"title":"9.Spring Cloud构建微服务架构：服务网关（路由配置）【Dalston版】","date":"2018-04-11T06:37:58.000Z","_content":"\n在上一篇《Spring Cloud构建微服务架构：服务网关（基础）》一文中，我们通过使用Spring Cloud Zuul构建了一个基础的API网关服务，同时也演示了Spring Cloud Zuul基于服务的自动路由功能。在本文中，我们将进一步详细地介绍关于Spring Cloud Zuul的路由功能，以帮助读者可以更好的理解和使用它，以完成更复杂的路由配置。\n\n# 传统路由配置\n\n所谓的传统路由配置方式就是在不依赖于服务发现机制的情况下，通过在配置文件中具体指定每个路由表达式与服务实例的映射关系来实现API网关对外部请求的路由。\n\n没有Eureka和Consul的服务治理框架帮助的时候，我们需要根据服务实例的数量采用不同方式的配置来实现路由规则：\n\n- 单实例配置：通过一组`zuul.routes.<route>.path`与`zuul.routes.<route>.url`参数对的方式配置，比如：\n\n```\nzuul.routes.user-service.path=/user-service/**\nzuul.routes.user-service.url=http://localhost:8080/\n```\n\n该配置实现了对符合`/user-service/**`规则的请求路径转发到`http://localhost:8080/`地址的路由规则，比如，当有一个请求`http://localhost:1101/user-service/hello`被发送到API网关上，由于`/user-service/hello`能够被上述配置的`path`规则匹配，所以API网关会转发请求到`http://localhost:8080/hello`地址。\n\n- 多实例配置：通过一组`zuul.routes.<route>.path`与`zuul.routes.<route>.serviceId`参数对的方式配置，比如：\n\n```\nzuul.routes.user-service.path=/user-service/**\nzuul.routes.user-service.serviceId=user-service\n\nribbon.eureka.enabled=false\nuser-service.ribbon.listOfServers=http://localhost:8080/,http://localhost:8081/\n```\n\n该配置实现了对符合`/user-service/**`规则的请求路径转发到`http://localhost:8080/`和`http://localhost:8081/`两个实例地址的路由规则。它的配置方式与服务路由的配置方式一样，都采用了`zuul.routes.<route>.path`与`zuul.routes.<route>.serviceId`参数对的映射方式，只是这里的`serviceId`是由用户手工命名的服务名称，配合`<serviceId>.ribbon.listOfServers参数`参数实现服务与实例的维护。由于存在多个实例，API网关在进行路由转发时需要实现负载均衡策略，于是这里还需要Spring Cloud Ribbon的配合。由于在Spring Cloud Zuul中自带了对Ribbon的依赖，所以我们只需要做一些配置即可，比如上面示例中关于Ribbon的各个配置，它们的具体作用如下：\n\n- `ribbon.eureka.enabled`:由于`zuul.routes.<route>.serviceId`指定的是服务名称，默认情况下Ribbon会根据服务发现机制来获取配置服务名对应的实例清单。但是，该示例并没有整合类似Eureka之类的服务治理框架，所以需要将该参数设置为false，不然配置的`serviceId`是获取不到对应实例清单的。\n\n- `user-service.ribbon.listOfServers`:该参数内容与`zuul.routes.<route>.serviceId`的配置相对应，开头的`user-service`对应了`serviceId`的值，这两个参数的配置相当于在该应用内部手工维护了服务与实例的对应关系。\n\n不论是单实例还是多实例的配置方式，我们都需要为每一对映射关系指定一个名称，也就是上面配置中的`<route>`，每一个`<route>`就对应了一条路由规则。每条路由规则都需要通过`path`性来定义一个用来匹配客户端请求的路径表达式，并通过`url`或`serviceId`属性来指定请求表达式映射具体实例地址或服务名。\n\n# 服务路由配置\n\n服务路由我们在上一篇中也已经有过基础的介绍和体验，Spring Cloud Zuul通过与Spring Cloud Eureka的整合，实现了对服务实例的自动化维护，所以在使用服务路由配置的时候，我们不需要向传统路由配置方式那样为`serviceId`去指定具体的服务实例地址，只需要通过一组`zuul.routes.<route>.path`与`zuul.routes.<route>.serviceId`参数对的方式配置即可。\n\n比如下面的示例，它实现了对符合`/user-service/**`规则的请求路径转发到名为`user-service`的服务实例上去的路由规则。其中`<route>`可以指定为任意的路由名称。\n\n```\nzuul.routes.user-service.path=/user-service/**\nzuul.routes.user-service.serviceId=user-service\n```\n\n对于面向服务的路由配置，除了使用`path`与`serviceId`映射的配置方式之外，还有一种更简洁的配置方式：`zuul.routes.<serviceId>=<path>`，其中`<serviceId>`用来指定路由的具体服务名，`<path>`用来配置匹配的请求表达式。比如下面的例子，它的路由规则等价于上面通过`path`与`serviceId`组合使用的配置方式。\n\n```\nzuul.routes.user-service=/user-service/**\n```\n\n传统路由的映射方式比较直观且容易理解，API网关直接根据请求的URL路径找到最匹配的`path`表达式，直接转发给该表达式对应的`url`或对应`serviceId`下配置的实例地址，以实现外部请求的路由。那么当采用`path`与`serviceId`以服务路由方式实现时候，没有配置任何实例地址的情况下，外部请求经过API网关的时候，它是如何被解析并转发到服务具体实例的呢？\n\n在Spring Cloud Netflix中，Zuul巧妙的整合了Eureka来实现面向服务的路由。实际上，我们可以直接将API网关也看做是Eureka服务治理下的一个普通微服务应用。它除了会将自己注册到Eureka服务注册中心上之外，也会从注册中心获取所有服务以及它们的实例清单。所以，在Eureka的帮助下，API网关服务本身就已经维护了系统中所有serviceId与实例地址的映射关系。当有外部请求到达API网关的时候，根据请求的URL路径找到最佳匹配的`path`规则，API网关就可以知道要将该请求路由到哪个具体的`serviceId`上去。由于在API网关中已经知道`serviceId`对应服务实例的地址清单，那么只需要通过Ribbon的负载均衡策略，直接在这些清单中选择一个具体的实例进行转发就能完成路由工作了。\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","source":"_posts/spring-cloud9.md","raw":"---\ntitle: 9.Spring Cloud构建微服务架构：服务网关（路由配置）【Dalston版】\ndate: 2018-04-11 14:37:58\ntags:\ncategories: 微服务\n---\n\n在上一篇《Spring Cloud构建微服务架构：服务网关（基础）》一文中，我们通过使用Spring Cloud Zuul构建了一个基础的API网关服务，同时也演示了Spring Cloud Zuul基于服务的自动路由功能。在本文中，我们将进一步详细地介绍关于Spring Cloud Zuul的路由功能，以帮助读者可以更好的理解和使用它，以完成更复杂的路由配置。\n\n# 传统路由配置\n\n所谓的传统路由配置方式就是在不依赖于服务发现机制的情况下，通过在配置文件中具体指定每个路由表达式与服务实例的映射关系来实现API网关对外部请求的路由。\n\n没有Eureka和Consul的服务治理框架帮助的时候，我们需要根据服务实例的数量采用不同方式的配置来实现路由规则：\n\n- 单实例配置：通过一组`zuul.routes.<route>.path`与`zuul.routes.<route>.url`参数对的方式配置，比如：\n\n```\nzuul.routes.user-service.path=/user-service/**\nzuul.routes.user-service.url=http://localhost:8080/\n```\n\n该配置实现了对符合`/user-service/**`规则的请求路径转发到`http://localhost:8080/`地址的路由规则，比如，当有一个请求`http://localhost:1101/user-service/hello`被发送到API网关上，由于`/user-service/hello`能够被上述配置的`path`规则匹配，所以API网关会转发请求到`http://localhost:8080/hello`地址。\n\n- 多实例配置：通过一组`zuul.routes.<route>.path`与`zuul.routes.<route>.serviceId`参数对的方式配置，比如：\n\n```\nzuul.routes.user-service.path=/user-service/**\nzuul.routes.user-service.serviceId=user-service\n\nribbon.eureka.enabled=false\nuser-service.ribbon.listOfServers=http://localhost:8080/,http://localhost:8081/\n```\n\n该配置实现了对符合`/user-service/**`规则的请求路径转发到`http://localhost:8080/`和`http://localhost:8081/`两个实例地址的路由规则。它的配置方式与服务路由的配置方式一样，都采用了`zuul.routes.<route>.path`与`zuul.routes.<route>.serviceId`参数对的映射方式，只是这里的`serviceId`是由用户手工命名的服务名称，配合`<serviceId>.ribbon.listOfServers参数`参数实现服务与实例的维护。由于存在多个实例，API网关在进行路由转发时需要实现负载均衡策略，于是这里还需要Spring Cloud Ribbon的配合。由于在Spring Cloud Zuul中自带了对Ribbon的依赖，所以我们只需要做一些配置即可，比如上面示例中关于Ribbon的各个配置，它们的具体作用如下：\n\n- `ribbon.eureka.enabled`:由于`zuul.routes.<route>.serviceId`指定的是服务名称，默认情况下Ribbon会根据服务发现机制来获取配置服务名对应的实例清单。但是，该示例并没有整合类似Eureka之类的服务治理框架，所以需要将该参数设置为false，不然配置的`serviceId`是获取不到对应实例清单的。\n\n- `user-service.ribbon.listOfServers`:该参数内容与`zuul.routes.<route>.serviceId`的配置相对应，开头的`user-service`对应了`serviceId`的值，这两个参数的配置相当于在该应用内部手工维护了服务与实例的对应关系。\n\n不论是单实例还是多实例的配置方式，我们都需要为每一对映射关系指定一个名称，也就是上面配置中的`<route>`，每一个`<route>`就对应了一条路由规则。每条路由规则都需要通过`path`性来定义一个用来匹配客户端请求的路径表达式，并通过`url`或`serviceId`属性来指定请求表达式映射具体实例地址或服务名。\n\n# 服务路由配置\n\n服务路由我们在上一篇中也已经有过基础的介绍和体验，Spring Cloud Zuul通过与Spring Cloud Eureka的整合，实现了对服务实例的自动化维护，所以在使用服务路由配置的时候，我们不需要向传统路由配置方式那样为`serviceId`去指定具体的服务实例地址，只需要通过一组`zuul.routes.<route>.path`与`zuul.routes.<route>.serviceId`参数对的方式配置即可。\n\n比如下面的示例，它实现了对符合`/user-service/**`规则的请求路径转发到名为`user-service`的服务实例上去的路由规则。其中`<route>`可以指定为任意的路由名称。\n\n```\nzuul.routes.user-service.path=/user-service/**\nzuul.routes.user-service.serviceId=user-service\n```\n\n对于面向服务的路由配置，除了使用`path`与`serviceId`映射的配置方式之外，还有一种更简洁的配置方式：`zuul.routes.<serviceId>=<path>`，其中`<serviceId>`用来指定路由的具体服务名，`<path>`用来配置匹配的请求表达式。比如下面的例子，它的路由规则等价于上面通过`path`与`serviceId`组合使用的配置方式。\n\n```\nzuul.routes.user-service=/user-service/**\n```\n\n传统路由的映射方式比较直观且容易理解，API网关直接根据请求的URL路径找到最匹配的`path`表达式，直接转发给该表达式对应的`url`或对应`serviceId`下配置的实例地址，以实现外部请求的路由。那么当采用`path`与`serviceId`以服务路由方式实现时候，没有配置任何实例地址的情况下，外部请求经过API网关的时候，它是如何被解析并转发到服务具体实例的呢？\n\n在Spring Cloud Netflix中，Zuul巧妙的整合了Eureka来实现面向服务的路由。实际上，我们可以直接将API网关也看做是Eureka服务治理下的一个普通微服务应用。它除了会将自己注册到Eureka服务注册中心上之外，也会从注册中心获取所有服务以及它们的实例清单。所以，在Eureka的帮助下，API网关服务本身就已经维护了系统中所有serviceId与实例地址的映射关系。当有外部请求到达API网关的时候，根据请求的URL路径找到最佳匹配的`path`规则，API网关就可以知道要将该请求路由到哪个具体的`serviceId`上去。由于在API网关中已经知道`serviceId`对应服务实例的地址清单，那么只需要通过Ribbon的负载均衡策略，直接在这些清单中选择一个具体的实例进行转发就能完成路由工作了。\n\n> 转载自[程序猿DD-翟永超](http://blog.didispace.com/)\n","slug":"spring-cloud9","published":1,"updated":"2019-12-24T02:00:57.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jxj001n0j9ksxhhwnxt","content":"<p>在上一篇《Spring Cloud构建微服务架构：服务网关（基础）》一文中，我们通过使用Spring Cloud Zuul构建了一个基础的API网关服务，同时也演示了Spring Cloud Zuul基于服务的自动路由功能。在本文中，我们将进一步详细地介绍关于Spring Cloud Zuul的路由功能，以帮助读者可以更好的理解和使用它，以完成更复杂的路由配置。</p>\n<h1 id=\"传统路由配置\"><a href=\"#传统路由配置\" class=\"headerlink\" title=\"传统路由配置\"></a>传统路由配置</h1><p>所谓的传统路由配置方式就是在不依赖于服务发现机制的情况下，通过在配置文件中具体指定每个路由表达式与服务实例的映射关系来实现API网关对外部请求的路由。</p>\n<p>没有Eureka和Consul的服务治理框架帮助的时候，我们需要根据服务实例的数量采用不同方式的配置来实现路由规则：</p>\n<ul>\n<li>单实例配置：通过一组<code>zuul.routes.&lt;route&gt;.path</code>与<code>zuul.routes.&lt;route&gt;.url</code>参数对的方式配置，比如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zuul.routes.user-service.path=/user-service/**</span><br><span class=\"line\">zuul.routes.user-service.url=http://localhost:8080/</span><br></pre></td></tr></table></figure>\n<p>该配置实现了对符合<code>/user-service/**</code>规则的请求路径转发到<code>http://localhost:8080/</code>地址的路由规则，比如，当有一个请求<code>http://localhost:1101/user-service/hello</code>被发送到API网关上，由于<code>/user-service/hello</code>能够被上述配置的<code>path</code>规则匹配，所以API网关会转发请求到<code>http://localhost:8080/hello</code>地址。</p>\n<ul>\n<li>多实例配置：通过一组<code>zuul.routes.&lt;route&gt;.path</code>与<code>zuul.routes.&lt;route&gt;.serviceId</code>参数对的方式配置，比如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zuul.routes.user-service.path=/user-service/**</span><br><span class=\"line\">zuul.routes.user-service.serviceId=user-service</span><br><span class=\"line\"></span><br><span class=\"line\">ribbon.eureka.enabled=false</span><br><span class=\"line\">user-service.ribbon.listOfServers=http://localhost:8080/,http://localhost:8081/</span><br></pre></td></tr></table></figure>\n<p>该配置实现了对符合<code>/user-service/**</code>规则的请求路径转发到<code>http://localhost:8080/</code>和<code>http://localhost:8081/</code>两个实例地址的路由规则。它的配置方式与服务路由的配置方式一样，都采用了<code>zuul.routes.&lt;route&gt;.path</code>与<code>zuul.routes.&lt;route&gt;.serviceId</code>参数对的映射方式，只是这里的<code>serviceId</code>是由用户手工命名的服务名称，配合<code>&lt;serviceId&gt;.ribbon.listOfServers参数</code>参数实现服务与实例的维护。由于存在多个实例，API网关在进行路由转发时需要实现负载均衡策略，于是这里还需要Spring Cloud Ribbon的配合。由于在Spring Cloud Zuul中自带了对Ribbon的依赖，所以我们只需要做一些配置即可，比如上面示例中关于Ribbon的各个配置，它们的具体作用如下：</p>\n<ul>\n<li><p><code>ribbon.eureka.enabled</code>:由于<code>zuul.routes.&lt;route&gt;.serviceId</code>指定的是服务名称，默认情况下Ribbon会根据服务发现机制来获取配置服务名对应的实例清单。但是，该示例并没有整合类似Eureka之类的服务治理框架，所以需要将该参数设置为false，不然配置的<code>serviceId</code>是获取不到对应实例清单的。</p>\n</li>\n<li><p><code>user-service.ribbon.listOfServers</code>:该参数内容与<code>zuul.routes.&lt;route&gt;.serviceId</code>的配置相对应，开头的<code>user-service</code>对应了<code>serviceId</code>的值，这两个参数的配置相当于在该应用内部手工维护了服务与实例的对应关系。</p>\n</li>\n</ul>\n<p>不论是单实例还是多实例的配置方式，我们都需要为每一对映射关系指定一个名称，也就是上面配置中的<code>&lt;route&gt;</code>，每一个<code>&lt;route&gt;</code>就对应了一条路由规则。每条路由规则都需要通过<code>path</code>性来定义一个用来匹配客户端请求的路径表达式，并通过<code>url</code>或<code>serviceId</code>属性来指定请求表达式映射具体实例地址或服务名。</p>\n<h1 id=\"服务路由配置\"><a href=\"#服务路由配置\" class=\"headerlink\" title=\"服务路由配置\"></a>服务路由配置</h1><p>服务路由我们在上一篇中也已经有过基础的介绍和体验，Spring Cloud Zuul通过与Spring Cloud Eureka的整合，实现了对服务实例的自动化维护，所以在使用服务路由配置的时候，我们不需要向传统路由配置方式那样为<code>serviceId</code>去指定具体的服务实例地址，只需要通过一组<code>zuul.routes.&lt;route&gt;.path</code>与<code>zuul.routes.&lt;route&gt;.serviceId</code>参数对的方式配置即可。</p>\n<p>比如下面的示例，它实现了对符合<code>/user-service/**</code>规则的请求路径转发到名为<code>user-service</code>的服务实例上去的路由规则。其中<code>&lt;route&gt;</code>可以指定为任意的路由名称。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zuul.routes.user-service.path=/user-service/**</span><br><span class=\"line\">zuul.routes.user-service.serviceId=user-service</span><br></pre></td></tr></table></figure>\n<p>对于面向服务的路由配置，除了使用<code>path</code>与<code>serviceId</code>映射的配置方式之外，还有一种更简洁的配置方式：<code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code>，其中<code>&lt;serviceId&gt;</code>用来指定路由的具体服务名，<code>&lt;path&gt;</code>用来配置匹配的请求表达式。比如下面的例子，它的路由规则等价于上面通过<code>path</code>与<code>serviceId</code>组合使用的配置方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zuul.routes.user-service=/user-service/**</span><br></pre></td></tr></table></figure>\n<p>传统路由的映射方式比较直观且容易理解，API网关直接根据请求的URL路径找到最匹配的<code>path</code>表达式，直接转发给该表达式对应的<code>url</code>或对应<code>serviceId</code>下配置的实例地址，以实现外部请求的路由。那么当采用<code>path</code>与<code>serviceId</code>以服务路由方式实现时候，没有配置任何实例地址的情况下，外部请求经过API网关的时候，它是如何被解析并转发到服务具体实例的呢？</p>\n<p>在Spring Cloud Netflix中，Zuul巧妙的整合了Eureka来实现面向服务的路由。实际上，我们可以直接将API网关也看做是Eureka服务治理下的一个普通微服务应用。它除了会将自己注册到Eureka服务注册中心上之外，也会从注册中心获取所有服务以及它们的实例清单。所以，在Eureka的帮助下，API网关服务本身就已经维护了系统中所有serviceId与实例地址的映射关系。当有外部请求到达API网关的时候，根据请求的URL路径找到最佳匹配的<code>path</code>规则，API网关就可以知道要将该请求路由到哪个具体的<code>serviceId</code>上去。由于在API网关中已经知道<code>serviceId</code>对应服务实例的地址清单，那么只需要通过Ribbon的负载均衡策略，直接在这些清单中选择一个具体的实例进行转发就能完成路由工作了。</p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>在上一篇《Spring Cloud构建微服务架构：服务网关（基础）》一文中，我们通过使用Spring Cloud Zuul构建了一个基础的API网关服务，同时也演示了Spring Cloud Zuul基于服务的自动路由功能。在本文中，我们将进一步详细地介绍关于Spring Cloud Zuul的路由功能，以帮助读者可以更好的理解和使用它，以完成更复杂的路由配置。</p>\n<h1 id=\"传统路由配置\"><a href=\"#传统路由配置\" class=\"headerlink\" title=\"传统路由配置\"></a>传统路由配置</h1><p>所谓的传统路由配置方式就是在不依赖于服务发现机制的情况下，通过在配置文件中具体指定每个路由表达式与服务实例的映射关系来实现API网关对外部请求的路由。</p>\n<p>没有Eureka和Consul的服务治理框架帮助的时候，我们需要根据服务实例的数量采用不同方式的配置来实现路由规则：</p>\n<ul>\n<li>单实例配置：通过一组<code>zuul.routes.&lt;route&gt;.path</code>与<code>zuul.routes.&lt;route&gt;.url</code>参数对的方式配置，比如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zuul.routes.user-service.path=/user-service/**</span><br><span class=\"line\">zuul.routes.user-service.url=http://localhost:8080/</span><br></pre></td></tr></table></figure>\n<p>该配置实现了对符合<code>/user-service/**</code>规则的请求路径转发到<code>http://localhost:8080/</code>地址的路由规则，比如，当有一个请求<code>http://localhost:1101/user-service/hello</code>被发送到API网关上，由于<code>/user-service/hello</code>能够被上述配置的<code>path</code>规则匹配，所以API网关会转发请求到<code>http://localhost:8080/hello</code>地址。</p>\n<ul>\n<li>多实例配置：通过一组<code>zuul.routes.&lt;route&gt;.path</code>与<code>zuul.routes.&lt;route&gt;.serviceId</code>参数对的方式配置，比如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zuul.routes.user-service.path=/user-service/**</span><br><span class=\"line\">zuul.routes.user-service.serviceId=user-service</span><br><span class=\"line\"></span><br><span class=\"line\">ribbon.eureka.enabled=false</span><br><span class=\"line\">user-service.ribbon.listOfServers=http://localhost:8080/,http://localhost:8081/</span><br></pre></td></tr></table></figure>\n<p>该配置实现了对符合<code>/user-service/**</code>规则的请求路径转发到<code>http://localhost:8080/</code>和<code>http://localhost:8081/</code>两个实例地址的路由规则。它的配置方式与服务路由的配置方式一样，都采用了<code>zuul.routes.&lt;route&gt;.path</code>与<code>zuul.routes.&lt;route&gt;.serviceId</code>参数对的映射方式，只是这里的<code>serviceId</code>是由用户手工命名的服务名称，配合<code>&lt;serviceId&gt;.ribbon.listOfServers参数</code>参数实现服务与实例的维护。由于存在多个实例，API网关在进行路由转发时需要实现负载均衡策略，于是这里还需要Spring Cloud Ribbon的配合。由于在Spring Cloud Zuul中自带了对Ribbon的依赖，所以我们只需要做一些配置即可，比如上面示例中关于Ribbon的各个配置，它们的具体作用如下：</p>\n<ul>\n<li><p><code>ribbon.eureka.enabled</code>:由于<code>zuul.routes.&lt;route&gt;.serviceId</code>指定的是服务名称，默认情况下Ribbon会根据服务发现机制来获取配置服务名对应的实例清单。但是，该示例并没有整合类似Eureka之类的服务治理框架，所以需要将该参数设置为false，不然配置的<code>serviceId</code>是获取不到对应实例清单的。</p>\n</li>\n<li><p><code>user-service.ribbon.listOfServers</code>:该参数内容与<code>zuul.routes.&lt;route&gt;.serviceId</code>的配置相对应，开头的<code>user-service</code>对应了<code>serviceId</code>的值，这两个参数的配置相当于在该应用内部手工维护了服务与实例的对应关系。</p>\n</li>\n</ul>\n<p>不论是单实例还是多实例的配置方式，我们都需要为每一对映射关系指定一个名称，也就是上面配置中的<code>&lt;route&gt;</code>，每一个<code>&lt;route&gt;</code>就对应了一条路由规则。每条路由规则都需要通过<code>path</code>性来定义一个用来匹配客户端请求的路径表达式，并通过<code>url</code>或<code>serviceId</code>属性来指定请求表达式映射具体实例地址或服务名。</p>\n<h1 id=\"服务路由配置\"><a href=\"#服务路由配置\" class=\"headerlink\" title=\"服务路由配置\"></a>服务路由配置</h1><p>服务路由我们在上一篇中也已经有过基础的介绍和体验，Spring Cloud Zuul通过与Spring Cloud Eureka的整合，实现了对服务实例的自动化维护，所以在使用服务路由配置的时候，我们不需要向传统路由配置方式那样为<code>serviceId</code>去指定具体的服务实例地址，只需要通过一组<code>zuul.routes.&lt;route&gt;.path</code>与<code>zuul.routes.&lt;route&gt;.serviceId</code>参数对的方式配置即可。</p>\n<p>比如下面的示例，它实现了对符合<code>/user-service/**</code>规则的请求路径转发到名为<code>user-service</code>的服务实例上去的路由规则。其中<code>&lt;route&gt;</code>可以指定为任意的路由名称。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zuul.routes.user-service.path=/user-service/**</span><br><span class=\"line\">zuul.routes.user-service.serviceId=user-service</span><br></pre></td></tr></table></figure>\n<p>对于面向服务的路由配置，除了使用<code>path</code>与<code>serviceId</code>映射的配置方式之外，还有一种更简洁的配置方式：<code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code>，其中<code>&lt;serviceId&gt;</code>用来指定路由的具体服务名，<code>&lt;path&gt;</code>用来配置匹配的请求表达式。比如下面的例子，它的路由规则等价于上面通过<code>path</code>与<code>serviceId</code>组合使用的配置方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zuul.routes.user-service=/user-service/**</span><br></pre></td></tr></table></figure>\n<p>传统路由的映射方式比较直观且容易理解，API网关直接根据请求的URL路径找到最匹配的<code>path</code>表达式，直接转发给该表达式对应的<code>url</code>或对应<code>serviceId</code>下配置的实例地址，以实现外部请求的路由。那么当采用<code>path</code>与<code>serviceId</code>以服务路由方式实现时候，没有配置任何实例地址的情况下，外部请求经过API网关的时候，它是如何被解析并转发到服务具体实例的呢？</p>\n<p>在Spring Cloud Netflix中，Zuul巧妙的整合了Eureka来实现面向服务的路由。实际上，我们可以直接将API网关也看做是Eureka服务治理下的一个普通微服务应用。它除了会将自己注册到Eureka服务注册中心上之外，也会从注册中心获取所有服务以及它们的实例清单。所以，在Eureka的帮助下，API网关服务本身就已经维护了系统中所有serviceId与实例地址的映射关系。当有外部请求到达API网关的时候，根据请求的URL路径找到最佳匹配的<code>path</code>规则，API网关就可以知道要将该请求路由到哪个具体的<code>serviceId</code>上去。由于在API网关中已经知道<code>serviceId</code>对应服务实例的地址清单，那么只需要通过Ribbon的负载均衡策略，直接在这些清单中选择一个具体的实例进行转发就能完成路由工作了。</p>\n<blockquote>\n<p>转载自<a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超</a></p>\n</blockquote>\n"},{"title":"避免ssh超时断开","date":"2017-12-20T01:24:21.000Z","_content":"![pic](http://s1.wailian.download/2018/01/18/714c395dedd696f341be46b38326674137170a2a1cb62-mzzZiS_fw658.jpg)\n用ssh连接服务器经常遇到长时间不操作而被服务器踢出的情况，提示如下\n> Write failed: Broken pipe\n\n# 方案一:客户端配置\n\n在`/etc/ssh/ssh_config`中添加配置\n```\nServerAliveInterval 60\n```\n之后，当使用ssh时每隔60s客户端都会向服务端发送一个KeepAlive请求，避免被踢\n\n# 方案二：服务端配置\n\n在`/etc/ssh/sshd_config`中添加配置\n```\nClientAliveInterval 60\n```\n重启服务器后设置生效\n注意：这种方式每一个连接服务器的客户端都受到影响，安全性会有一定的下降\n","source":"_posts/ssh-broken.md","raw":"---\ntitle: 避免ssh超时断开\ndate: 2017-12-20 09:24:21\ntags:\n---\n![pic](http://s1.wailian.download/2018/01/18/714c395dedd696f341be46b38326674137170a2a1cb62-mzzZiS_fw658.jpg)\n用ssh连接服务器经常遇到长时间不操作而被服务器踢出的情况，提示如下\n> Write failed: Broken pipe\n\n# 方案一:客户端配置\n\n在`/etc/ssh/ssh_config`中添加配置\n```\nServerAliveInterval 60\n```\n之后，当使用ssh时每隔60s客户端都会向服务端发送一个KeepAlive请求，避免被踢\n\n# 方案二：服务端配置\n\n在`/etc/ssh/sshd_config`中添加配置\n```\nClientAliveInterval 60\n```\n重启服务器后设置生效\n注意：这种方式每一个连接服务器的客户端都受到影响，安全性会有一定的下降\n","slug":"ssh-broken","published":1,"updated":"2019-12-24T02:00:57.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jxk001p0j9kre8xfiwn","content":"<p><img src=\"http://s1.wailian.download/2018/01/18/714c395dedd696f341be46b38326674137170a2a1cb62-mzzZiS_fw658.jpg\" alt=\"pic\"><br>用ssh连接服务器经常遇到长时间不操作而被服务器踢出的情况，提示如下</p>\n<blockquote>\n<p>Write failed: Broken pipe</p>\n</blockquote>\n<h1 id=\"方案一-客户端配置\"><a href=\"#方案一-客户端配置\" class=\"headerlink\" title=\"方案一:客户端配置\"></a>方案一:客户端配置</h1><p>在<code>/etc/ssh/ssh_config</code>中添加配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ServerAliveInterval 60</span><br></pre></td></tr></table></figure></p>\n<p>之后，当使用ssh时每隔60s客户端都会向服务端发送一个KeepAlive请求，避免被踢</p>\n<h1 id=\"方案二：服务端配置\"><a href=\"#方案二：服务端配置\" class=\"headerlink\" title=\"方案二：服务端配置\"></a>方案二：服务端配置</h1><p>在<code>/etc/ssh/sshd_config</code>中添加配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClientAliveInterval 60</span><br></pre></td></tr></table></figure></p>\n<p>重启服务器后设置生效<br>注意：这种方式每一个连接服务器的客户端都受到影响，安全性会有一定的下降</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://s1.wailian.download/2018/01/18/714c395dedd696f341be46b38326674137170a2a1cb62-mzzZiS_fw658.jpg\" alt=\"pic\"><br>用ssh连接服务器经常遇到长时间不操作而被服务器踢出的情况，提示如下</p>\n<blockquote>\n<p>Write failed: Broken pipe</p>\n</blockquote>\n<h1 id=\"方案一-客户端配置\"><a href=\"#方案一-客户端配置\" class=\"headerlink\" title=\"方案一:客户端配置\"></a>方案一:客户端配置</h1><p>在<code>/etc/ssh/ssh_config</code>中添加配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ServerAliveInterval 60</span><br></pre></td></tr></table></figure></p>\n<p>之后，当使用ssh时每隔60s客户端都会向服务端发送一个KeepAlive请求，避免被踢</p>\n<h1 id=\"方案二：服务端配置\"><a href=\"#方案二：服务端配置\" class=\"headerlink\" title=\"方案二：服务端配置\"></a>方案二：服务端配置</h1><p>在<code>/etc/ssh/sshd_config</code>中添加配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClientAliveInterval 60</span><br></pre></td></tr></table></figure></p>\n<p>重启服务器后设置生效<br>注意：这种方式每一个连接服务器的客户端都受到影响，安全性会有一定的下降</p>\n"},{"title":"ssh免密登录","date":"2017-12-18T12:45:29.000Z","_content":"![pic](http://s1.wailian.download/2018/01/18/77e75ad8e3c3226b53206731154ac0f7a0c27a97a99c5-2wKmIY_fw658.jpg)\n# 场景\n\n客户端A想要免密登录服务器B\n\n# 客户端A\n\n## 生成SSH KEY\n\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n\n## 查看客户端公钥\n\n```\ncat ~/.ssh/id_rsa.pub\n```\n\n# 服务端B\n\n## 生成SSH KEY\n\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n\n## 连接A-B\n\n复制A的公钥到B的\n```\n~/.ssh/authorized_keys\n```\n\n# 重新登录\n","source":"_posts/ssh-no-pass.md","raw":"---\ntitle: ssh免密登录\ndate: 2017-12-18 20:45:29\ntags:\n---\n![pic](http://s1.wailian.download/2018/01/18/77e75ad8e3c3226b53206731154ac0f7a0c27a97a99c5-2wKmIY_fw658.jpg)\n# 场景\n\n客户端A想要免密登录服务器B\n\n# 客户端A\n\n## 生成SSH KEY\n\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n\n## 查看客户端公钥\n\n```\ncat ~/.ssh/id_rsa.pub\n```\n\n# 服务端B\n\n## 生成SSH KEY\n\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n\n## 连接A-B\n\n复制A的公钥到B的\n```\n~/.ssh/authorized_keys\n```\n\n# 重新登录\n","slug":"ssh-no-pass","published":1,"updated":"2019-12-24T02:00:57.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jxl001r0j9kbnoowm1m","content":"<p><img src=\"http://s1.wailian.download/2018/01/18/77e75ad8e3c3226b53206731154ac0f7a0c27a97a99c5-2wKmIY_fw658.jpg\" alt=\"pic\"></p>\n<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>客户端A想要免密登录服务器B</p>\n<h1 id=\"客户端A\"><a href=\"#客户端A\" class=\"headerlink\" title=\"客户端A\"></a>客户端A</h1><h2 id=\"生成SSH-KEY\"><a href=\"#生成SSH-KEY\" class=\"headerlink\" title=\"生成SSH KEY\"></a>生成SSH KEY</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看客户端公钥\"><a href=\"#查看客户端公钥\" class=\"headerlink\" title=\"查看客户端公钥\"></a>查看客户端公钥</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n<h1 id=\"服务端B\"><a href=\"#服务端B\" class=\"headerlink\" title=\"服务端B\"></a>服务端B</h1><h2 id=\"生成SSH-KEY-1\"><a href=\"#生成SSH-KEY-1\" class=\"headerlink\" title=\"生成SSH KEY\"></a>生成SSH KEY</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"连接A-B\"><a href=\"#连接A-B\" class=\"headerlink\" title=\"连接A-B\"></a>连接A-B</h2><p>复制A的公钥到B的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"重新登录\"><a href=\"#重新登录\" class=\"headerlink\" title=\"重新登录\"></a>重新登录</h1>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://s1.wailian.download/2018/01/18/77e75ad8e3c3226b53206731154ac0f7a0c27a97a99c5-2wKmIY_fw658.jpg\" alt=\"pic\"></p>\n<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>客户端A想要免密登录服务器B</p>\n<h1 id=\"客户端A\"><a href=\"#客户端A\" class=\"headerlink\" title=\"客户端A\"></a>客户端A</h1><h2 id=\"生成SSH-KEY\"><a href=\"#生成SSH-KEY\" class=\"headerlink\" title=\"生成SSH KEY\"></a>生成SSH KEY</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看客户端公钥\"><a href=\"#查看客户端公钥\" class=\"headerlink\" title=\"查看客户端公钥\"></a>查看客户端公钥</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n<h1 id=\"服务端B\"><a href=\"#服务端B\" class=\"headerlink\" title=\"服务端B\"></a>服务端B</h1><h2 id=\"生成SSH-KEY-1\"><a href=\"#生成SSH-KEY-1\" class=\"headerlink\" title=\"生成SSH KEY\"></a>生成SSH KEY</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"连接A-B\"><a href=\"#连接A-B\" class=\"headerlink\" title=\"连接A-B\"></a>连接A-B</h2><p>复制A的公钥到B的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"重新登录\"><a href=\"#重新登录\" class=\"headerlink\" title=\"重新登录\"></a>重新登录</h1>"},{"title":"CentOS7修改ssh端口号,增强服务器安全","date":"2017-11-27T02:37:06.000Z","_content":"> 最近发现购买的vps总是有很多次失败尝试登录的记录,感觉很不安全,遂想到修改ssh默认端口来降低风险\n\n# 修改配置文件\n\n```\nvim /etc/ssh/sshd_config\n```\n\n在**#Port 22**下增加端口**Port 10001**,去掉22端口的注释(以防修改端口失败,默认端口也不能登录)\n\nSSH默认监听端口就是22,上面我保留了22端口,以防修改端口失败,默认端口也不能登录\n\n增加10001端口，大家修改端口时候最好挑10000~65535之间的端口号，10000以下容易被系统或一些特殊软件占用，或是以后新应用准备占用该端口的时候，却被你先占用了，导致软件无法运行。\n\n# 修改SELinux配置\n\n## 查看是否开启了SELinux\n\n```\n    sestatus -v\n```\n\n如果没有开启,则跳过这一步\n\n## 查看SELinux开放给ssh使用的端口\n\n``` bash\n    semanage port -l|grep ssh\n```\n\n**ssh_port_t         tcp      22**\n\n## SELinux开放10001端口给ssh\n\n```\n    semanage port -a -t ssh_port_t -p tcp 10001\n```\n\n完成后再次查看\n\n```\n    semanage port -l|grep ssh\n```\n\n**ssh_port_t         tcp      22，10001**\n\n# 防火墙放开10001端口\n\n## 修改防火墙配置文件\n\n```\nvim /etc/firewalld/zones/public.xml\n```\n\n增加100001的端口放开\n\n```\n<port protocol=\"tcp\" port=\"10001\"/>\n```\n\n# 重启\n\n``` bash\n    systemctl restart sshd   重启ssh\n    systemctl restart firewalld.service    重启防火墙\n    shutdown -r now  重启服务器\n```\n\n# 重新登录\n\n``` bash\n    ssh root@localhost -p 10001\n```\n\n# 如果登录成功注释掉上边的22端口配置\n\n修改了默认端口之后尝试登录的攻击显著降低\n","source":"_posts/ssh.md","raw":"---\ntitle: CentOS7修改ssh端口号,增强服务器安全\ndate: 2017-11-27 10:37:06\ntags:\n---\n> 最近发现购买的vps总是有很多次失败尝试登录的记录,感觉很不安全,遂想到修改ssh默认端口来降低风险\n\n# 修改配置文件\n\n```\nvim /etc/ssh/sshd_config\n```\n\n在**#Port 22**下增加端口**Port 10001**,去掉22端口的注释(以防修改端口失败,默认端口也不能登录)\n\nSSH默认监听端口就是22,上面我保留了22端口,以防修改端口失败,默认端口也不能登录\n\n增加10001端口，大家修改端口时候最好挑10000~65535之间的端口号，10000以下容易被系统或一些特殊软件占用，或是以后新应用准备占用该端口的时候，却被你先占用了，导致软件无法运行。\n\n# 修改SELinux配置\n\n## 查看是否开启了SELinux\n\n```\n    sestatus -v\n```\n\n如果没有开启,则跳过这一步\n\n## 查看SELinux开放给ssh使用的端口\n\n``` bash\n    semanage port -l|grep ssh\n```\n\n**ssh_port_t         tcp      22**\n\n## SELinux开放10001端口给ssh\n\n```\n    semanage port -a -t ssh_port_t -p tcp 10001\n```\n\n完成后再次查看\n\n```\n    semanage port -l|grep ssh\n```\n\n**ssh_port_t         tcp      22，10001**\n\n# 防火墙放开10001端口\n\n## 修改防火墙配置文件\n\n```\nvim /etc/firewalld/zones/public.xml\n```\n\n增加100001的端口放开\n\n```\n<port protocol=\"tcp\" port=\"10001\"/>\n```\n\n# 重启\n\n``` bash\n    systemctl restart sshd   重启ssh\n    systemctl restart firewalld.service    重启防火墙\n    shutdown -r now  重启服务器\n```\n\n# 重新登录\n\n``` bash\n    ssh root@localhost -p 10001\n```\n\n# 如果登录成功注释掉上边的22端口配置\n\n修改了默认端口之后尝试登录的攻击显著降低\n","slug":"ssh","published":1,"updated":"2019-12-24T02:00:57.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jxn001t0j9k5x70vg0q","content":"<blockquote>\n<p>最近发现购买的vps总是有很多次失败尝试登录的记录,感觉很不安全,遂想到修改ssh默认端口来降低风险</p>\n</blockquote>\n<h1 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>\n<p>在<strong>#Port 22</strong>下增加端口<strong>Port 10001</strong>,去掉22端口的注释(以防修改端口失败,默认端口也不能登录)</p>\n<p>SSH默认监听端口就是22,上面我保留了22端口,以防修改端口失败,默认端口也不能登录</p>\n<p>增加10001端口，大家修改端口时候最好挑10000~65535之间的端口号，10000以下容易被系统或一些特殊软件占用，或是以后新应用准备占用该端口的时候，却被你先占用了，导致软件无法运行。</p>\n<h1 id=\"修改SELinux配置\"><a href=\"#修改SELinux配置\" class=\"headerlink\" title=\"修改SELinux配置\"></a>修改SELinux配置</h1><h2 id=\"查看是否开启了SELinux\"><a href=\"#查看是否开启了SELinux\" class=\"headerlink\" title=\"查看是否开启了SELinux\"></a>查看是否开启了SELinux</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sestatus -v</span><br></pre></td></tr></table></figure>\n<p>如果没有开启,则跳过这一步</p>\n<h2 id=\"查看SELinux开放给ssh使用的端口\"><a href=\"#查看SELinux开放给ssh使用的端口\" class=\"headerlink\" title=\"查看SELinux开放给ssh使用的端口\"></a>查看SELinux开放给ssh使用的端口</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semanage port -l|grep ssh</span><br></pre></td></tr></table></figure>\n<p><strong>ssh_port_t         tcp      22</strong></p>\n<h2 id=\"SELinux开放10001端口给ssh\"><a href=\"#SELinux开放10001端口给ssh\" class=\"headerlink\" title=\"SELinux开放10001端口给ssh\"></a>SELinux开放10001端口给ssh</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semanage port -a -t ssh_port_t -p tcp 10001</span><br></pre></td></tr></table></figure>\n<p>完成后再次查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semanage port -l|grep ssh</span><br></pre></td></tr></table></figure>\n<p><strong>ssh_port_t         tcp      22，10001</strong></p>\n<h1 id=\"防火墙放开10001端口\"><a href=\"#防火墙放开10001端口\" class=\"headerlink\" title=\"防火墙放开10001端口\"></a>防火墙放开10001端口</h1><h2 id=\"修改防火墙配置文件\"><a href=\"#修改防火墙配置文件\" class=\"headerlink\" title=\"修改防火墙配置文件\"></a>修改防火墙配置文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/firewalld/zones/public.xml</span><br></pre></td></tr></table></figure>\n<p>增加100001的端口放开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;port protocol=&quot;tcp&quot; port=&quot;10001&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"重启\"><a href=\"#重启\" class=\"headerlink\" title=\"重启\"></a>重启</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart sshd   重启ssh</span><br><span class=\"line\">systemctl restart firewalld.service    重启防火墙</span><br><span class=\"line\">shutdown -r now  重启服务器</span><br></pre></td></tr></table></figure>\n<h1 id=\"重新登录\"><a href=\"#重新登录\" class=\"headerlink\" title=\"重新登录\"></a>重新登录</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh root@localhost -p 10001</span><br></pre></td></tr></table></figure>\n<h1 id=\"如果登录成功注释掉上边的22端口配置\"><a href=\"#如果登录成功注释掉上边的22端口配置\" class=\"headerlink\" title=\"如果登录成功注释掉上边的22端口配置\"></a>如果登录成功注释掉上边的22端口配置</h1><p>修改了默认端口之后尝试登录的攻击显著降低</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近发现购买的vps总是有很多次失败尝试登录的记录,感觉很不安全,遂想到修改ssh默认端口来降低风险</p>\n</blockquote>\n<h1 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>\n<p>在<strong>#Port 22</strong>下增加端口<strong>Port 10001</strong>,去掉22端口的注释(以防修改端口失败,默认端口也不能登录)</p>\n<p>SSH默认监听端口就是22,上面我保留了22端口,以防修改端口失败,默认端口也不能登录</p>\n<p>增加10001端口，大家修改端口时候最好挑10000~65535之间的端口号，10000以下容易被系统或一些特殊软件占用，或是以后新应用准备占用该端口的时候，却被你先占用了，导致软件无法运行。</p>\n<h1 id=\"修改SELinux配置\"><a href=\"#修改SELinux配置\" class=\"headerlink\" title=\"修改SELinux配置\"></a>修改SELinux配置</h1><h2 id=\"查看是否开启了SELinux\"><a href=\"#查看是否开启了SELinux\" class=\"headerlink\" title=\"查看是否开启了SELinux\"></a>查看是否开启了SELinux</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sestatus -v</span><br></pre></td></tr></table></figure>\n<p>如果没有开启,则跳过这一步</p>\n<h2 id=\"查看SELinux开放给ssh使用的端口\"><a href=\"#查看SELinux开放给ssh使用的端口\" class=\"headerlink\" title=\"查看SELinux开放给ssh使用的端口\"></a>查看SELinux开放给ssh使用的端口</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semanage port -l|grep ssh</span><br></pre></td></tr></table></figure>\n<p><strong>ssh_port_t         tcp      22</strong></p>\n<h2 id=\"SELinux开放10001端口给ssh\"><a href=\"#SELinux开放10001端口给ssh\" class=\"headerlink\" title=\"SELinux开放10001端口给ssh\"></a>SELinux开放10001端口给ssh</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semanage port -a -t ssh_port_t -p tcp 10001</span><br></pre></td></tr></table></figure>\n<p>完成后再次查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semanage port -l|grep ssh</span><br></pre></td></tr></table></figure>\n<p><strong>ssh_port_t         tcp      22，10001</strong></p>\n<h1 id=\"防火墙放开10001端口\"><a href=\"#防火墙放开10001端口\" class=\"headerlink\" title=\"防火墙放开10001端口\"></a>防火墙放开10001端口</h1><h2 id=\"修改防火墙配置文件\"><a href=\"#修改防火墙配置文件\" class=\"headerlink\" title=\"修改防火墙配置文件\"></a>修改防火墙配置文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/firewalld/zones/public.xml</span><br></pre></td></tr></table></figure>\n<p>增加100001的端口放开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;port protocol=&quot;tcp&quot; port=&quot;10001&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"重启\"><a href=\"#重启\" class=\"headerlink\" title=\"重启\"></a>重启</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart sshd   重启ssh</span><br><span class=\"line\">systemctl restart firewalld.service    重启防火墙</span><br><span class=\"line\">shutdown -r now  重启服务器</span><br></pre></td></tr></table></figure>\n<h1 id=\"重新登录\"><a href=\"#重新登录\" class=\"headerlink\" title=\"重新登录\"></a>重新登录</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh root@localhost -p 10001</span><br></pre></td></tr></table></figure>\n<h1 id=\"如果登录成功注释掉上边的22端口配置\"><a href=\"#如果登录成功注释掉上边的22端口配置\" class=\"headerlink\" title=\"如果登录成功注释掉上边的22端口配置\"></a>如果登录成功注释掉上边的22端口配置</h1><p>修改了默认端口之后尝试登录的攻击显著降低</p>\n"},{"title":"函数节流","date":"2019-10-19T01:24:21.000Z","_content":"\n# 函数节流\n\n## 应用场景\n\n在浏览器 DOM 事件里面，有一些事件会随着用户的操作不间断触发。比如：重新调整浏览器窗口大小（resize），浏览器页面滚动（scroll），鼠标移动（mousemove）。也就是说用户在触发这些浏览器操作的时候，如果脚本里面绑定了对应的事件处理方法，这个方法就不停的触发。\n\n这并不是我们想要的，因为有的时候如果事件处理方法比较庞大，DOM 操作比如复杂，还不断的触发此类事件就会造成性能上的损失，导致用户体验下降（UI 反映慢、浏览器卡死等）。所以通常来讲我们会给相应事件添加延迟执行的逻辑。\n\n## 代码\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>函数节流or函数防抖</title>\n</head>\n\n<body>\n    <div>《JavaScript高级程序设计》中把函数防抖的命名错了，导致以后很多人都理解反了。<br />\n        问题：我们要做一个input，根据用户的输入实时搜索，该怎么做？\n        <br />\n        <h1>实例1：</h1>\n        <img src=\"a.gif\" />\n        <br />\n        <h1>实例2：</h1>\n        <img src=\"b.gif\" />\n    </div>\n    <hr />\n    <div id=\"demo\"></div>\n    <script>\n        var COUNT = 0;\n        var demo = document.getElementById('demo');\n\n        function testFn() {\n            demo.innerHTML += 'testFn 被调用了 ' + ++COUNT + '次<br>';\n        }\n\n        // version0: 《JavaScript高级程序设计》中的方法，把定时器ID存为函数的一个属性\n        /*\n        function throttle(method, context) {\n            clearTimeout(method.tid);\n            method.tid = setTimeout(function () {\n                method.call(context);\n            }, 100);\n        }\n\n        window.onresize = function () {\n            throttle(testFn);\n        }\n        */\n\n        // version1: -> 错误 timer不是相对全局的变量每次resize会生成一个timer\n        /*\n        window.onresize = function () {\n            var timer = null;\n            clearTimeout(timer);\n\n            timer = setTimeout(function () {\n                testFn();\n            }, 100);\n        };\n        */\n\n        // version2: -> 正确， 但是会多添加一个相对全局的变量，有可能影响业务逻辑\n        /*\n        var timer = null;\n        window.onresize = function () {\n            clearTimeout(timer);\n            timer = setTimeout(function() {\n                testFn();\n            }, 100);\n        };\n        */\n\n        // version3: -> 正确，使用闭包。但是到目前为至还有一个问题，如果不间断的触发resize的话fn是永远不会执行的\n        /**\n         * 函数节流方法\n         * @param Function fn 延时调用函数\n         * @param Number delay 延迟多长时间\n         * @return Function 延迟执行的方法\n         */\n\n        /*\n        var throttle = function (fn, delay) {\n            var timer = null;\n\n            return function () {\n                clearTimeout(timer);\n                timer = setTimeout(function () {\n                    fn();\n                }, delay);\n            }\n        };\n        */\n\n        // 第一种调用方式\n        /*\n        var f = throttle(testFn, 200);\n        window.onresize = function () {\n            f();\n        };\n        */\n\n        // 第二种调用方式\n        /* window.onresize = throttle(testFn, 200);*/\n\n        // versin4：最终模式\n        var throttle = function (fn, delay, atleast) {\n            var timer = null;\n            var previous = null;\n\n            return function () {\n                var now = +new Date();\n\n                if (!previous) previous = now;\n\n                if (atleast && now - previous > atleast) {\n                    fn();\n                    // 重置上一次开始时间为本次结束时间\n                    previous = now;\n                    clearTimeout(timer);\n                } else {\n                    clearTimeout(timer);\n                    timer = setTimeout(function () {\n                        fn();\n                        previous = null;\n                    }, delay);\n                }\n            }\n        };\n\n        // atleast参数选填\n        window.onresize = throttle(testFn, 200, 1000);\n        // window.onresize = throttle(testFn, 200);\n    </script>\n</body>\n\n</html>\n```\n\ntestcase2\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>函数节流or函数防抖测试用例</title>\n</head>\n\n<body>\n    <div style=\"height:5000px\">\n        <div id=\"demo\" style=\"position:fixed;\"></div>\n    </div>\n    <script>\n        var COUNT = 0,\n            demo = document.getElementById('demo');\n\n        function testFn() {\n            demo.innerHTML += 'testFn 被调用了 ' + ++COUNT + '次<br>';\n        }\n\n        var throttle = function (fn, delay, atleast) {\n            var timer = null;\n            var previous = null;\n\n            return function () {\n                var now = +new Date();\n\n                if (!previous) previous = now;\n                if (atleast && now - previous > atleast) {\n                    fn();\n                    // 重置上一次开始时间为本次结束时间\n                    previous = now;\n                    clearTimeout(timer);\n                } else {\n                    clearTimeout(timer);\n                    timer = setTimeout(function () {\n                        fn();\n                        previous = null;\n                    }, delay);\n                }\n            }\n        };\n\n        // testCase1\n        window.onscroll = throttle(testFn, 200);\n\n        // testCase2\n        // window.onscroll = throttle(testFn, 500, 1000);\n    </script>\n</body>\n\n</html>\n```\n\n[完整代码](https://github.com/wangweiye01/throttle)","source":"_posts/throttle.md","raw":"---\ntitle: 函数节流\ndate: 2019-10-19 09:24:21\ntags:\n---\n\n# 函数节流\n\n## 应用场景\n\n在浏览器 DOM 事件里面，有一些事件会随着用户的操作不间断触发。比如：重新调整浏览器窗口大小（resize），浏览器页面滚动（scroll），鼠标移动（mousemove）。也就是说用户在触发这些浏览器操作的时候，如果脚本里面绑定了对应的事件处理方法，这个方法就不停的触发。\n\n这并不是我们想要的，因为有的时候如果事件处理方法比较庞大，DOM 操作比如复杂，还不断的触发此类事件就会造成性能上的损失，导致用户体验下降（UI 反映慢、浏览器卡死等）。所以通常来讲我们会给相应事件添加延迟执行的逻辑。\n\n## 代码\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>函数节流or函数防抖</title>\n</head>\n\n<body>\n    <div>《JavaScript高级程序设计》中把函数防抖的命名错了，导致以后很多人都理解反了。<br />\n        问题：我们要做一个input，根据用户的输入实时搜索，该怎么做？\n        <br />\n        <h1>实例1：</h1>\n        <img src=\"a.gif\" />\n        <br />\n        <h1>实例2：</h1>\n        <img src=\"b.gif\" />\n    </div>\n    <hr />\n    <div id=\"demo\"></div>\n    <script>\n        var COUNT = 0;\n        var demo = document.getElementById('demo');\n\n        function testFn() {\n            demo.innerHTML += 'testFn 被调用了 ' + ++COUNT + '次<br>';\n        }\n\n        // version0: 《JavaScript高级程序设计》中的方法，把定时器ID存为函数的一个属性\n        /*\n        function throttle(method, context) {\n            clearTimeout(method.tid);\n            method.tid = setTimeout(function () {\n                method.call(context);\n            }, 100);\n        }\n\n        window.onresize = function () {\n            throttle(testFn);\n        }\n        */\n\n        // version1: -> 错误 timer不是相对全局的变量每次resize会生成一个timer\n        /*\n        window.onresize = function () {\n            var timer = null;\n            clearTimeout(timer);\n\n            timer = setTimeout(function () {\n                testFn();\n            }, 100);\n        };\n        */\n\n        // version2: -> 正确， 但是会多添加一个相对全局的变量，有可能影响业务逻辑\n        /*\n        var timer = null;\n        window.onresize = function () {\n            clearTimeout(timer);\n            timer = setTimeout(function() {\n                testFn();\n            }, 100);\n        };\n        */\n\n        // version3: -> 正确，使用闭包。但是到目前为至还有一个问题，如果不间断的触发resize的话fn是永远不会执行的\n        /**\n         * 函数节流方法\n         * @param Function fn 延时调用函数\n         * @param Number delay 延迟多长时间\n         * @return Function 延迟执行的方法\n         */\n\n        /*\n        var throttle = function (fn, delay) {\n            var timer = null;\n\n            return function () {\n                clearTimeout(timer);\n                timer = setTimeout(function () {\n                    fn();\n                }, delay);\n            }\n        };\n        */\n\n        // 第一种调用方式\n        /*\n        var f = throttle(testFn, 200);\n        window.onresize = function () {\n            f();\n        };\n        */\n\n        // 第二种调用方式\n        /* window.onresize = throttle(testFn, 200);*/\n\n        // versin4：最终模式\n        var throttle = function (fn, delay, atleast) {\n            var timer = null;\n            var previous = null;\n\n            return function () {\n                var now = +new Date();\n\n                if (!previous) previous = now;\n\n                if (atleast && now - previous > atleast) {\n                    fn();\n                    // 重置上一次开始时间为本次结束时间\n                    previous = now;\n                    clearTimeout(timer);\n                } else {\n                    clearTimeout(timer);\n                    timer = setTimeout(function () {\n                        fn();\n                        previous = null;\n                    }, delay);\n                }\n            }\n        };\n\n        // atleast参数选填\n        window.onresize = throttle(testFn, 200, 1000);\n        // window.onresize = throttle(testFn, 200);\n    </script>\n</body>\n\n</html>\n```\n\ntestcase2\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>函数节流or函数防抖测试用例</title>\n</head>\n\n<body>\n    <div style=\"height:5000px\">\n        <div id=\"demo\" style=\"position:fixed;\"></div>\n    </div>\n    <script>\n        var COUNT = 0,\n            demo = document.getElementById('demo');\n\n        function testFn() {\n            demo.innerHTML += 'testFn 被调用了 ' + ++COUNT + '次<br>';\n        }\n\n        var throttle = function (fn, delay, atleast) {\n            var timer = null;\n            var previous = null;\n\n            return function () {\n                var now = +new Date();\n\n                if (!previous) previous = now;\n                if (atleast && now - previous > atleast) {\n                    fn();\n                    // 重置上一次开始时间为本次结束时间\n                    previous = now;\n                    clearTimeout(timer);\n                } else {\n                    clearTimeout(timer);\n                    timer = setTimeout(function () {\n                        fn();\n                        previous = null;\n                    }, delay);\n                }\n            }\n        };\n\n        // testCase1\n        window.onscroll = throttle(testFn, 200);\n\n        // testCase2\n        // window.onscroll = throttle(testFn, 500, 1000);\n    </script>\n</body>\n\n</html>\n```\n\n[完整代码](https://github.com/wangweiye01/throttle)","slug":"throttle","published":1,"updated":"2019-12-24T02:00:57.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jxo001v0j9ksqb470h1","content":"<h1 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h1><h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>在浏览器 DOM 事件里面，有一些事件会随着用户的操作不间断触发。比如：重新调整浏览器窗口大小（resize），浏览器页面滚动（scroll），鼠标移动（mousemove）。也就是说用户在触发这些浏览器操作的时候，如果脚本里面绑定了对应的事件处理方法，这个方法就不停的触发。</p>\n<p>这并不是我们想要的，因为有的时候如果事件处理方法比较庞大，DOM 操作比如复杂，还不断的触发此类事件就会造成性能上的损失，导致用户体验下降（UI 反映慢、浏览器卡死等）。所以通常来讲我们会给相应事件添加延迟执行的逻辑。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>函数节流or函数防抖<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>《JavaScript高级程序设计》中把函数防抖的命名错了，导致以后很多人都理解反了。<span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\">        问题：我们要做一个input，根据用户的输入实时搜索，该怎么做？</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>实例1：<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"a.gif\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>实例2：<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"b.gif\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">hr</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> COUNT = <span class=\"number\">0</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> demo = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testFn</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            demo.innerHTML += <span class=\"string\">'testFn 被调用了 '</span> + ++COUNT + <span class=\"string\">'次&lt;br&gt;'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// version0: 《JavaScript高级程序设计》中的方法，把定时器ID存为函数的一个属性</span></span></span><br><span class=\"line\"><span class=\"undefined\">        /*</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">method, context</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            clearTimeout(method.tid);</span></span><br><span class=\"line\"><span class=\"javascript\">            method.tid = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                method.call(context);</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;, 100);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onresize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            throttle(testFn);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        */</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// version1: -&gt; 错误 timer不是相对全局的变量每次resize会生成一个timer</span></span></span><br><span class=\"line\"><span class=\"undefined\">        /*</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onresize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">            clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                testFn();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;, 100);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">        */</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// version2: -&gt; 正确， 但是会多添加一个相对全局的变量，有可能影响业务逻辑</span></span></span><br><span class=\"line\"><span class=\"undefined\">        /*</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onresize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"javascript\">            timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                testFn();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;, 100);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">        */</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// version3: -&gt; 正确，使用闭包。但是到目前为至还有一个问题，如果不间断的触发resize的话fn是永远不会执行的</span></span></span><br><span class=\"line\"><span class=\"undefined\">        /**</span></span><br><span class=\"line\"><span class=\"undefined\">         * 函数节流方法</span></span><br><span class=\"line\"><span class=\"javascript\">         * @param <span class=\"built_in\">Function</span> fn 延时调用函数</span></span><br><span class=\"line\"><span class=\"javascript\">         * @param <span class=\"built_in\">Number</span> delay 延迟多长时间</span></span><br><span class=\"line\"><span class=\"javascript\">         * @<span class=\"keyword\">return</span> <span class=\"built_in\">Function</span> 延迟执行的方法</span></span><br><span class=\"line\"><span class=\"undefined\">         */</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        /*</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, delay</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"javascript\">                timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    fn();</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;, delay);</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">        */</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 第一种调用方式</span></span></span><br><span class=\"line\"><span class=\"undefined\">        /*</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> f = throttle(testFn, <span class=\"number\">200</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onresize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            f();</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">        */</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 第二种调用方式</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">/* window.onresize = throttle(testFn, 200);*/</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// versin4：最终模式</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, delay, atleast</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> previous = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">if</span> (!previous) previous = now;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">if</span> (atleast &amp;&amp; now - previous &gt; atleast) &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    fn();</span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"comment\">// 重置上一次开始时间为本次结束时间</span></span></span><br><span class=\"line\"><span class=\"undefined\">                    previous = now;</span></span><br><span class=\"line\"><span class=\"undefined\">                    clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"javascript\">                &#125; <span class=\"keyword\">else</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"javascript\">                    timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                        fn();</span></span><br><span class=\"line\"><span class=\"javascript\">                        previous = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">                    &#125;, delay);</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// atleast参数选填</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onresize = throttle(testFn, <span class=\"number\">200</span>, <span class=\"number\">1000</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// window.onresize = throttle(testFn, 200);</span></span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>testcase2</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>函数节流or函数防抖测试用例<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height:5000px\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"position:fixed;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> COUNT = <span class=\"number\">0</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">            demo = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testFn</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            demo.innerHTML += <span class=\"string\">'testFn 被调用了 '</span> + ++COUNT + <span class=\"string\">'次&lt;br&gt;'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, delay, atleast</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> previous = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">if</span> (!previous) previous = now;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">if</span> (atleast &amp;&amp; now - previous &gt; atleast) &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    fn();</span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"comment\">// 重置上一次开始时间为本次结束时间</span></span></span><br><span class=\"line\"><span class=\"undefined\">                    previous = now;</span></span><br><span class=\"line\"><span class=\"undefined\">                    clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"javascript\">                &#125; <span class=\"keyword\">else</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"javascript\">                    timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                        fn();</span></span><br><span class=\"line\"><span class=\"javascript\">                        previous = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">                    &#125;, delay);</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// testCase1</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onscroll = throttle(testFn, <span class=\"number\">200</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// testCase2</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// window.onscroll = throttle(testFn, 500, 1000);</span></span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/wangweiye01/throttle\" target=\"_blank\" rel=\"noopener\">完整代码</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h1><h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>在浏览器 DOM 事件里面，有一些事件会随着用户的操作不间断触发。比如：重新调整浏览器窗口大小（resize），浏览器页面滚动（scroll），鼠标移动（mousemove）。也就是说用户在触发这些浏览器操作的时候，如果脚本里面绑定了对应的事件处理方法，这个方法就不停的触发。</p>\n<p>这并不是我们想要的，因为有的时候如果事件处理方法比较庞大，DOM 操作比如复杂，还不断的触发此类事件就会造成性能上的损失，导致用户体验下降（UI 反映慢、浏览器卡死等）。所以通常来讲我们会给相应事件添加延迟执行的逻辑。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>函数节流or函数防抖<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>《JavaScript高级程序设计》中把函数防抖的命名错了，导致以后很多人都理解反了。<span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\">        问题：我们要做一个input，根据用户的输入实时搜索，该怎么做？</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>实例1：<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"a.gif\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>实例2：<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"b.gif\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">hr</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> COUNT = <span class=\"number\">0</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> demo = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testFn</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            demo.innerHTML += <span class=\"string\">'testFn 被调用了 '</span> + ++COUNT + <span class=\"string\">'次&lt;br&gt;'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// version0: 《JavaScript高级程序设计》中的方法，把定时器ID存为函数的一个属性</span></span></span><br><span class=\"line\"><span class=\"undefined\">        /*</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">method, context</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            clearTimeout(method.tid);</span></span><br><span class=\"line\"><span class=\"javascript\">            method.tid = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                method.call(context);</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;, 100);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onresize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            throttle(testFn);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        */</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// version1: -&gt; 错误 timer不是相对全局的变量每次resize会生成一个timer</span></span></span><br><span class=\"line\"><span class=\"undefined\">        /*</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onresize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">            clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                testFn();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;, 100);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">        */</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// version2: -&gt; 正确， 但是会多添加一个相对全局的变量，有可能影响业务逻辑</span></span></span><br><span class=\"line\"><span class=\"undefined\">        /*</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onresize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"javascript\">            timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                testFn();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;, 100);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">        */</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// version3: -&gt; 正确，使用闭包。但是到目前为至还有一个问题，如果不间断的触发resize的话fn是永远不会执行的</span></span></span><br><span class=\"line\"><span class=\"undefined\">        /**</span></span><br><span class=\"line\"><span class=\"undefined\">         * 函数节流方法</span></span><br><span class=\"line\"><span class=\"javascript\">         * @param <span class=\"built_in\">Function</span> fn 延时调用函数</span></span><br><span class=\"line\"><span class=\"javascript\">         * @param <span class=\"built_in\">Number</span> delay 延迟多长时间</span></span><br><span class=\"line\"><span class=\"javascript\">         * @<span class=\"keyword\">return</span> <span class=\"built_in\">Function</span> 延迟执行的方法</span></span><br><span class=\"line\"><span class=\"undefined\">         */</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        /*</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, delay</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"javascript\">                timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    fn();</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;, delay);</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">        */</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 第一种调用方式</span></span></span><br><span class=\"line\"><span class=\"undefined\">        /*</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> f = throttle(testFn, <span class=\"number\">200</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onresize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            f();</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">        */</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 第二种调用方式</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">/* window.onresize = throttle(testFn, 200);*/</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// versin4：最终模式</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, delay, atleast</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> previous = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">if</span> (!previous) previous = now;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">if</span> (atleast &amp;&amp; now - previous &gt; atleast) &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    fn();</span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"comment\">// 重置上一次开始时间为本次结束时间</span></span></span><br><span class=\"line\"><span class=\"undefined\">                    previous = now;</span></span><br><span class=\"line\"><span class=\"undefined\">                    clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"javascript\">                &#125; <span class=\"keyword\">else</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"javascript\">                    timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                        fn();</span></span><br><span class=\"line\"><span class=\"javascript\">                        previous = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">                    &#125;, delay);</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// atleast参数选填</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onresize = throttle(testFn, <span class=\"number\">200</span>, <span class=\"number\">1000</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// window.onresize = throttle(testFn, 200);</span></span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>testcase2</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>函数节流or函数防抖测试用例<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height:5000px\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"position:fixed;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> COUNT = <span class=\"number\">0</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">            demo = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testFn</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            demo.innerHTML += <span class=\"string\">'testFn 被调用了 '</span> + ++COUNT + <span class=\"string\">'次&lt;br&gt;'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn, delay, atleast</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> previous = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">if</span> (!previous) previous = now;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">if</span> (atleast &amp;&amp; now - previous &gt; atleast) &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    fn();</span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"comment\">// 重置上一次开始时间为本次结束时间</span></span></span><br><span class=\"line\"><span class=\"undefined\">                    previous = now;</span></span><br><span class=\"line\"><span class=\"undefined\">                    clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"javascript\">                &#125; <span class=\"keyword\">else</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    clearTimeout(timer);</span></span><br><span class=\"line\"><span class=\"javascript\">                    timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                        fn();</span></span><br><span class=\"line\"><span class=\"javascript\">                        previous = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">                    &#125;, delay);</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// testCase1</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.onscroll = throttle(testFn, <span class=\"number\">200</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// testCase2</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// window.onscroll = throttle(testFn, 500, 1000);</span></span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/wangweiye01/throttle\" target=\"_blank\" rel=\"noopener\">完整代码</a></p>\n"},{"title":"ubuntu更新火狐","date":"2017-11-28T07:49:48.000Z","_content":"# 删除老版本\n\n```\nsudo apt-get remove firefox\n```\n\n# 下载最新软件包\n\n```\nhttp://www.firefox.com.cn/download/\n```\n解压到本地\n\n# 移动文件到/opt文件夹下\n\n```\nsudo mv firefox /opt\n```\n\n# 创建桌面图标\n\n在/usr/share/applications下创建firefox.desktop文件\n```\nsudo touch firefox.desktop\n```\n编辑文件\n```\n[Desktop Entry]\nName=Firefox\nName[zh_CN]=火狐浏览器\nComment=this is firefox\nExec=/opt/firefox/firefox\nIcon=/opt/firefox/icons/fox.png\nTerminal=false\nType=Application\nCategories=Application;Network;\n```\n","source":"_posts/ubuntu_firefox.md","raw":"---\ntitle: ubuntu更新火狐\ndate: 2017-11-28 15:49:48\ntags:\n---\n# 删除老版本\n\n```\nsudo apt-get remove firefox\n```\n\n# 下载最新软件包\n\n```\nhttp://www.firefox.com.cn/download/\n```\n解压到本地\n\n# 移动文件到/opt文件夹下\n\n```\nsudo mv firefox /opt\n```\n\n# 创建桌面图标\n\n在/usr/share/applications下创建firefox.desktop文件\n```\nsudo touch firefox.desktop\n```\n编辑文件\n```\n[Desktop Entry]\nName=Firefox\nName[zh_CN]=火狐浏览器\nComment=this is firefox\nExec=/opt/firefox/firefox\nIcon=/opt/firefox/icons/fox.png\nTerminal=false\nType=Application\nCategories=Application;Network;\n```\n","slug":"ubuntu_firefox","published":1,"updated":"2019-12-24T02:00:57.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jxq001x0j9kw6wqsk27","content":"<h1 id=\"删除老版本\"><a href=\"#删除老版本\" class=\"headerlink\" title=\"删除老版本\"></a>删除老版本</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get remove firefox</span><br></pre></td></tr></table></figure>\n<h1 id=\"下载最新软件包\"><a href=\"#下载最新软件包\" class=\"headerlink\" title=\"下载最新软件包\"></a>下载最新软件包</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.firefox.com.cn/download/</span><br></pre></td></tr></table></figure>\n<p>解压到本地</p>\n<h1 id=\"移动文件到-opt文件夹下\"><a href=\"#移动文件到-opt文件夹下\" class=\"headerlink\" title=\"移动文件到/opt文件夹下\"></a>移动文件到/opt文件夹下</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mv firefox /opt</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建桌面图标\"><a href=\"#创建桌面图标\" class=\"headerlink\" title=\"创建桌面图标\"></a>创建桌面图标</h1><p>在/usr/share/applications下创建firefox.desktop文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo touch firefox.desktop</span><br></pre></td></tr></table></figure></p>\n<p>编辑文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\">Name=Firefox</span><br><span class=\"line\">Name[zh_CN]=火狐浏览器</span><br><span class=\"line\">Comment=this is firefox</span><br><span class=\"line\">Exec=/opt/firefox/firefox</span><br><span class=\"line\">Icon=/opt/firefox/icons/fox.png</span><br><span class=\"line\">Terminal=false</span><br><span class=\"line\">Type=Application</span><br><span class=\"line\">Categories=Application;Network;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"删除老版本\"><a href=\"#删除老版本\" class=\"headerlink\" title=\"删除老版本\"></a>删除老版本</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get remove firefox</span><br></pre></td></tr></table></figure>\n<h1 id=\"下载最新软件包\"><a href=\"#下载最新软件包\" class=\"headerlink\" title=\"下载最新软件包\"></a>下载最新软件包</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.firefox.com.cn/download/</span><br></pre></td></tr></table></figure>\n<p>解压到本地</p>\n<h1 id=\"移动文件到-opt文件夹下\"><a href=\"#移动文件到-opt文件夹下\" class=\"headerlink\" title=\"移动文件到/opt文件夹下\"></a>移动文件到/opt文件夹下</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mv firefox /opt</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建桌面图标\"><a href=\"#创建桌面图标\" class=\"headerlink\" title=\"创建桌面图标\"></a>创建桌面图标</h1><p>在/usr/share/applications下创建firefox.desktop文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo touch firefox.desktop</span><br></pre></td></tr></table></figure></p>\n<p>编辑文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\">Name=Firefox</span><br><span class=\"line\">Name[zh_CN]=火狐浏览器</span><br><span class=\"line\">Comment=this is firefox</span><br><span class=\"line\">Exec=/opt/firefox/firefox</span><br><span class=\"line\">Icon=/opt/firefox/icons/fox.png</span><br><span class=\"line\">Terminal=false</span><br><span class=\"line\">Type=Application</span><br><span class=\"line\">Categories=Application;Network;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Spring Boot实现WebSocket消息推送","date":"2018-03-01T09:05:06.000Z","_content":"\n![pic](http://www.wailian.work/images/2018/03/02/3b41bb4144a7478ef7d1937c3a0ec56975e163f61a9ba-n8Syo1_fw658.jpg)\n\n# 什么是WebSocket\n\nWebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。\n\n# 配置\n\n```\n@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {\n\n\t@Override\n\tpublic void configureMessageBroker(MessageBrokerRegistry config) {\n\t\tconfig.enableSimpleBroker(\"/topic\");\n\t\tconfig.setApplicationDestinationPrefixes(\"/app\");\n\t}\n\n\t@Override\n\tpublic void registerStompEndpoints(StompEndpointRegistry registry) {\n\t\tregistry.addEndpoint(\"/my-websocket\").withSockJS();\n\t}\n}\n```\n\n这里配置了以\"/app\"开头的websocket请求url和名为\"my-websocket\"的endpoint\n\n1. @EnableWebSocketMessageBroker注解表示开启使用STOMP协议来传输基于代理的消息\n2. registerStompEndpoints方法表示注册STOMP协议的节点，并指定映射的URL\n3. `registry.addEndpoint(\"/my-websocket\").withSockJS()`这一行代码用来注册STOMP协议节点，同时指定使用SockJS协议。\n4. configureMessageBroker方法用来配置消息代理，由于我们是实现推送功能，这里的消息代理是/topic\n\n# 推送消息类\n\n```\npublic class SocketMessage {\n\n\tpublic String message;\n\n\tpublic String date;\n\n}\n```\n\n\n# 控制器\n\n```\n@Controller\n@EnableScheduling\n@SpringBootApplication\npublic class App {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(App.class, args);\n\t}\n\n\t@Autowired\n\tprivate SimpMessagingTemplate messagingTemplate;\n\n\t@GetMapping(\"/\")\n\tpublic String index() {\n\t\treturn \"index\";\n\t}\n\n\t@MessageMapping(\"/send\")\n\t@SendTo(\"/topic/send\")\n\tpublic SocketMessage send(SocketMessage message) throws Exception {\n\t\tDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\tmessage.date = df.format(new Date());\n\t\treturn message;\n\t}\n\n\t@Scheduled(fixedRate = 1000)\n\t@SendTo(\"/topic/callback\")\n\tpublic Object callback() throws Exception {\n\t\t// 发现消息\n\t\tDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\tmessagingTemplate.convertAndSend(\"/topic/callback\", df.format(new Date()));\n\t\treturn \"callback\";\n\t}\n}\n```\n\n`@MessageMapping`注解和`@RequestMapping`类似，用来发送消息到特定路径\n\n`@SendTo`注解表示当服务器有消息需要推送的时候，会对订阅了`@SendTo`中路径的客户端发送消息\n\n# 前端脚本\n\n我们这个案例需要三个js脚本文件，分别是STOMP协议的客户端脚本stomp.js、SockJS的客户端脚本sock.js以及jQuery\n\n# 演示页面\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n<title>websocket</title>\n<script src=\"//cdn.bootcss.com/angular.js/1.5.6/angular.min.js\"></script>\n<script src=\"https://cdn.bootcss.com/sockjs-client/1.1.4/sockjs.min.js\"></script>\n<script src=\"https://cdn.bootcss.com/stomp.js/2.3.3/stomp.min.js\"></script>\n<script type=\"text/javascript\">\n\n\tvar stompClient = null;\n\n\tvar app = angular.module('app', []);\n\tapp.controller('MainController', function($rootScope, $scope, $http) {\n\n\t\t$scope.data = {\n\t\t\t//连接状态\n\t\t\tconnected : false,\n\t\t\t//消息\n\t\t\tmessage : '',\n\t\t\trows : []\n\t\t};\n\n\t\t//连接\n\t\t$scope.connect = function() {\n\t\t\tvar socket = new SockJS('/my-websocket');\n\t\t\tstompClient = Stomp.over(socket);\n\t\t\tstompClient.connect({}, function(frame) {\n\t\t\t\t// 注册发送消息\n\t\t\t\tstompClient.subscribe('/topic/send', function(msg) {\n\t\t\t\t\t$scope.data.rows.push(JSON.parse(msg.body));\n\t\t\t\t\t$scope.data.connected = true;\n\t\t\t\t\t$scope.$apply();\n\t\t\t\t});\n\t\t\t\t// 注册推送时间回调\n\t\t\t\tstompClient.subscribe('/topic/callback', function(r) {\n\t\t\t\t\t$scope.data.time = '当前服务器时间：' + r.body;\n\t\t\t\t\t$scope.data.connected = true;\n\t\t\t\t\t$scope.$apply();\n\t\t\t\t});\n\n\t\t\t\t$scope.data.connected = true;\n\t\t\t\t$scope.$apply();\n\t\t\t});\n\t\t};\n\n\t\t$scope.disconnect = function() {\n\t\t\tif (stompClient != null) {\n\t\t\t\tstompClient.disconnect();\n\t\t\t}\n\t\t\t$scope.data.connected = false;\n\t\t}\n\n\t\t$scope.send = function() {\n\t\t\tstompClient.send(\"/app/send\", {}, JSON.stringify({\n\t\t\t\t'message' : $scope.data.message\n\t\t\t}));\n\t\t}\n\t});\n</script>\n</head>\n<body ng-app=\"app\" ng-controller=\"MainController\">\n\t<label>WebSocket连接状态:</label>\n\t<button type=\"button\" ng-disabled=\"data.connected\" ng-click=\"connect()\">连接</button>\n\t<button type=\"button\" ng-click=\"disconnect()\"\n\t\tng-disabled=\"!data.connected\">断开</button>\n\t<br />\n\t<br />\n\t<div ng-show=\"data.connected\">\n\t\t<label>{{data.time}}</label> <br /> <br /> <input type=\"text\"\n\t\t\tng-model=\"data.message\" placeholder=\"请输入内容...\" />\n\t\t<button ng-click=\"send()\" type=\"button\">发送</button>\n\t\t<br /> <br /> 消息列表： <br />\n\t\t<table>\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>内容</th>\n\t\t\t\t\t<th>时间</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t<tr ng-repeat=\"row in data.rows\">\n\t\t\t\t\t<td>{{row.message}}</td>\n\t\t\t\t\t<td>{{row.date}}</td>\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</table>\n\t</div>\n</body>\n</html>\n```\n![演示图](http://www.wailian.work/images/2018/03/02/WX20180302-094543.png)\n\n\n[代码地址](https://github.com/wangweiye01/websocket)\n","source":"_posts/websocket.md","raw":"---\ntitle: Spring Boot实现WebSocket消息推送\ndate: 2018-03-01 17:05:06\ntags:\n---\n\n![pic](http://www.wailian.work/images/2018/03/02/3b41bb4144a7478ef7d1937c3a0ec56975e163f61a9ba-n8Syo1_fw658.jpg)\n\n# 什么是WebSocket\n\nWebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。\n\n# 配置\n\n```\n@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {\n\n\t@Override\n\tpublic void configureMessageBroker(MessageBrokerRegistry config) {\n\t\tconfig.enableSimpleBroker(\"/topic\");\n\t\tconfig.setApplicationDestinationPrefixes(\"/app\");\n\t}\n\n\t@Override\n\tpublic void registerStompEndpoints(StompEndpointRegistry registry) {\n\t\tregistry.addEndpoint(\"/my-websocket\").withSockJS();\n\t}\n}\n```\n\n这里配置了以\"/app\"开头的websocket请求url和名为\"my-websocket\"的endpoint\n\n1. @EnableWebSocketMessageBroker注解表示开启使用STOMP协议来传输基于代理的消息\n2. registerStompEndpoints方法表示注册STOMP协议的节点，并指定映射的URL\n3. `registry.addEndpoint(\"/my-websocket\").withSockJS()`这一行代码用来注册STOMP协议节点，同时指定使用SockJS协议。\n4. configureMessageBroker方法用来配置消息代理，由于我们是实现推送功能，这里的消息代理是/topic\n\n# 推送消息类\n\n```\npublic class SocketMessage {\n\n\tpublic String message;\n\n\tpublic String date;\n\n}\n```\n\n\n# 控制器\n\n```\n@Controller\n@EnableScheduling\n@SpringBootApplication\npublic class App {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(App.class, args);\n\t}\n\n\t@Autowired\n\tprivate SimpMessagingTemplate messagingTemplate;\n\n\t@GetMapping(\"/\")\n\tpublic String index() {\n\t\treturn \"index\";\n\t}\n\n\t@MessageMapping(\"/send\")\n\t@SendTo(\"/topic/send\")\n\tpublic SocketMessage send(SocketMessage message) throws Exception {\n\t\tDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\tmessage.date = df.format(new Date());\n\t\treturn message;\n\t}\n\n\t@Scheduled(fixedRate = 1000)\n\t@SendTo(\"/topic/callback\")\n\tpublic Object callback() throws Exception {\n\t\t// 发现消息\n\t\tDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\tmessagingTemplate.convertAndSend(\"/topic/callback\", df.format(new Date()));\n\t\treturn \"callback\";\n\t}\n}\n```\n\n`@MessageMapping`注解和`@RequestMapping`类似，用来发送消息到特定路径\n\n`@SendTo`注解表示当服务器有消息需要推送的时候，会对订阅了`@SendTo`中路径的客户端发送消息\n\n# 前端脚本\n\n我们这个案例需要三个js脚本文件，分别是STOMP协议的客户端脚本stomp.js、SockJS的客户端脚本sock.js以及jQuery\n\n# 演示页面\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n<title>websocket</title>\n<script src=\"//cdn.bootcss.com/angular.js/1.5.6/angular.min.js\"></script>\n<script src=\"https://cdn.bootcss.com/sockjs-client/1.1.4/sockjs.min.js\"></script>\n<script src=\"https://cdn.bootcss.com/stomp.js/2.3.3/stomp.min.js\"></script>\n<script type=\"text/javascript\">\n\n\tvar stompClient = null;\n\n\tvar app = angular.module('app', []);\n\tapp.controller('MainController', function($rootScope, $scope, $http) {\n\n\t\t$scope.data = {\n\t\t\t//连接状态\n\t\t\tconnected : false,\n\t\t\t//消息\n\t\t\tmessage : '',\n\t\t\trows : []\n\t\t};\n\n\t\t//连接\n\t\t$scope.connect = function() {\n\t\t\tvar socket = new SockJS('/my-websocket');\n\t\t\tstompClient = Stomp.over(socket);\n\t\t\tstompClient.connect({}, function(frame) {\n\t\t\t\t// 注册发送消息\n\t\t\t\tstompClient.subscribe('/topic/send', function(msg) {\n\t\t\t\t\t$scope.data.rows.push(JSON.parse(msg.body));\n\t\t\t\t\t$scope.data.connected = true;\n\t\t\t\t\t$scope.$apply();\n\t\t\t\t});\n\t\t\t\t// 注册推送时间回调\n\t\t\t\tstompClient.subscribe('/topic/callback', function(r) {\n\t\t\t\t\t$scope.data.time = '当前服务器时间：' + r.body;\n\t\t\t\t\t$scope.data.connected = true;\n\t\t\t\t\t$scope.$apply();\n\t\t\t\t});\n\n\t\t\t\t$scope.data.connected = true;\n\t\t\t\t$scope.$apply();\n\t\t\t});\n\t\t};\n\n\t\t$scope.disconnect = function() {\n\t\t\tif (stompClient != null) {\n\t\t\t\tstompClient.disconnect();\n\t\t\t}\n\t\t\t$scope.data.connected = false;\n\t\t}\n\n\t\t$scope.send = function() {\n\t\t\tstompClient.send(\"/app/send\", {}, JSON.stringify({\n\t\t\t\t'message' : $scope.data.message\n\t\t\t}));\n\t\t}\n\t});\n</script>\n</head>\n<body ng-app=\"app\" ng-controller=\"MainController\">\n\t<label>WebSocket连接状态:</label>\n\t<button type=\"button\" ng-disabled=\"data.connected\" ng-click=\"connect()\">连接</button>\n\t<button type=\"button\" ng-click=\"disconnect()\"\n\t\tng-disabled=\"!data.connected\">断开</button>\n\t<br />\n\t<br />\n\t<div ng-show=\"data.connected\">\n\t\t<label>{{data.time}}</label> <br /> <br /> <input type=\"text\"\n\t\t\tng-model=\"data.message\" placeholder=\"请输入内容...\" />\n\t\t<button ng-click=\"send()\" type=\"button\">发送</button>\n\t\t<br /> <br /> 消息列表： <br />\n\t\t<table>\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>内容</th>\n\t\t\t\t\t<th>时间</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t<tr ng-repeat=\"row in data.rows\">\n\t\t\t\t\t<td>{{row.message}}</td>\n\t\t\t\t\t<td>{{row.date}}</td>\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</table>\n\t</div>\n</body>\n</html>\n```\n![演示图](http://www.wailian.work/images/2018/03/02/WX20180302-094543.png)\n\n\n[代码地址](https://github.com/wangweiye01/websocket)\n","slug":"websocket","published":1,"updated":"2019-12-24T02:00:57.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3jxr001z0j9kzzexex99","content":"<p><img src=\"http://www.wailian.work/images/2018/03/02/3b41bb4144a7478ef7d1937c3a0ec56975e163f61a9ba-n8Syo1_fw658.jpg\" alt=\"pic\"></p>\n<h1 id=\"什么是WebSocket\"><a href=\"#什么是WebSocket\" class=\"headerlink\" title=\"什么是WebSocket\"></a>什么是WebSocket</h1><p>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。</p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@EnableWebSocketMessageBroker</span><br><span class=\"line\">public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void configureMessageBroker(MessageBrokerRegistry config) &#123;</span><br><span class=\"line\">\t\tconfig.enableSimpleBroker(&quot;/topic&quot;);</span><br><span class=\"line\">\t\tconfig.setApplicationDestinationPrefixes(&quot;/app&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void registerStompEndpoints(StompEndpointRegistry registry) &#123;</span><br><span class=\"line\">\t\tregistry.addEndpoint(&quot;/my-websocket&quot;).withSockJS();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里配置了以”/app”开头的websocket请求url和名为”my-websocket”的endpoint</p>\n<ol>\n<li>@EnableWebSocketMessageBroker注解表示开启使用STOMP协议来传输基于代理的消息</li>\n<li>registerStompEndpoints方法表示注册STOMP协议的节点，并指定映射的URL</li>\n<li><code>registry.addEndpoint(&quot;/my-websocket&quot;).withSockJS()</code>这一行代码用来注册STOMP协议节点，同时指定使用SockJS协议。</li>\n<li>configureMessageBroker方法用来配置消息代理，由于我们是实现推送功能，这里的消息代理是/topic</li>\n</ol>\n<h1 id=\"推送消息类\"><a href=\"#推送消息类\" class=\"headerlink\" title=\"推送消息类\"></a>推送消息类</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SocketMessage &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String message;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String date;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">@EnableScheduling</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class App &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tSpringApplication.run(App.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Autowired</span><br><span class=\"line\">\tprivate SimpMessagingTemplate messagingTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@GetMapping(&quot;/&quot;)</span><br><span class=\"line\">\tpublic String index() &#123;</span><br><span class=\"line\">\t\treturn &quot;index&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@MessageMapping(&quot;/send&quot;)</span><br><span class=\"line\">\t@SendTo(&quot;/topic/send&quot;)</span><br><span class=\"line\">\tpublic SocketMessage send(SocketMessage message) throws Exception &#123;</span><br><span class=\"line\">\t\tDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class=\"line\">\t\tmessage.date = df.format(new Date());</span><br><span class=\"line\">\t\treturn message;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Scheduled(fixedRate = 1000)</span><br><span class=\"line\">\t@SendTo(&quot;/topic/callback&quot;)</span><br><span class=\"line\">\tpublic Object callback() throws Exception &#123;</span><br><span class=\"line\">\t\t// 发现消息</span><br><span class=\"line\">\t\tDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class=\"line\">\t\tmessagingTemplate.convertAndSend(&quot;/topic/callback&quot;, df.format(new Date()));</span><br><span class=\"line\">\t\treturn &quot;callback&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@MessageMapping</code>注解和<code>@RequestMapping</code>类似，用来发送消息到特定路径</p>\n<p><code>@SendTo</code>注解表示当服务器有消息需要推送的时候，会对订阅了<code>@SendTo</code>中路径的客户端发送消息</p>\n<h1 id=\"前端脚本\"><a href=\"#前端脚本\" class=\"headerlink\" title=\"前端脚本\"></a>前端脚本</h1><p>我们这个案例需要三个js脚本文件，分别是STOMP协议的客户端脚本stomp.js、SockJS的客户端脚本sock.js以及jQuery</p>\n<h1 id=\"演示页面\"><a href=\"#演示页面\" class=\"headerlink\" title=\"演示页面\"></a>演示页面</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;websocket&lt;/title&gt;</span><br><span class=\"line\">&lt;script src=&quot;//cdn.bootcss.com/angular.js/1.5.6/angular.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/sockjs-client/1.1.4/sockjs.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/stomp.js/2.3.3/stomp.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar stompClient = null;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar app = angular.module(&apos;app&apos;, []);</span><br><span class=\"line\">\tapp.controller(&apos;MainController&apos;, function($rootScope, $scope, $http) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t$scope.data = &#123;</span><br><span class=\"line\">\t\t\t//连接状态</span><br><span class=\"line\">\t\t\tconnected : false,</span><br><span class=\"line\">\t\t\t//消息</span><br><span class=\"line\">\t\t\tmessage : &apos;&apos;,</span><br><span class=\"line\">\t\t\trows : []</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//连接</span><br><span class=\"line\">\t\t$scope.connect = function() &#123;</span><br><span class=\"line\">\t\t\tvar socket = new SockJS(&apos;/my-websocket&apos;);</span><br><span class=\"line\">\t\t\tstompClient = Stomp.over(socket);</span><br><span class=\"line\">\t\t\tstompClient.connect(&#123;&#125;, function(frame) &#123;</span><br><span class=\"line\">\t\t\t\t// 注册发送消息</span><br><span class=\"line\">\t\t\t\tstompClient.subscribe(&apos;/topic/send&apos;, function(msg) &#123;</span><br><span class=\"line\">\t\t\t\t\t$scope.data.rows.push(JSON.parse(msg.body));</span><br><span class=\"line\">\t\t\t\t\t$scope.data.connected = true;</span><br><span class=\"line\">\t\t\t\t\t$scope.$apply();</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t// 注册推送时间回调</span><br><span class=\"line\">\t\t\t\tstompClient.subscribe(&apos;/topic/callback&apos;, function(r) &#123;</span><br><span class=\"line\">\t\t\t\t\t$scope.data.time = &apos;当前服务器时间：&apos; + r.body;</span><br><span class=\"line\">\t\t\t\t\t$scope.data.connected = true;</span><br><span class=\"line\">\t\t\t\t\t$scope.$apply();</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t$scope.data.connected = true;</span><br><span class=\"line\">\t\t\t\t$scope.$apply();</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t$scope.disconnect = function() &#123;</span><br><span class=\"line\">\t\t\tif (stompClient != null) &#123;</span><br><span class=\"line\">\t\t\t\tstompClient.disconnect();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t$scope.data.connected = false;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t$scope.send = function() &#123;</span><br><span class=\"line\">\t\t\tstompClient.send(&quot;/app/send&quot;, &#123;&#125;, JSON.stringify(&#123;</span><br><span class=\"line\">\t\t\t\t&apos;message&apos; : $scope.data.message</span><br><span class=\"line\">\t\t\t&#125;));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body ng-app=&quot;app&quot; ng-controller=&quot;MainController&quot;&gt;</span><br><span class=\"line\">\t&lt;label&gt;WebSocket连接状态:&lt;/label&gt;</span><br><span class=\"line\">\t&lt;button type=&quot;button&quot; ng-disabled=&quot;data.connected&quot; ng-click=&quot;connect()&quot;&gt;连接&lt;/button&gt;</span><br><span class=\"line\">\t&lt;button type=&quot;button&quot; ng-click=&quot;disconnect()&quot;</span><br><span class=\"line\">\t\tng-disabled=&quot;!data.connected&quot;&gt;断开&lt;/button&gt;</span><br><span class=\"line\">\t&lt;br /&gt;</span><br><span class=\"line\">\t&lt;br /&gt;</span><br><span class=\"line\">\t&lt;div ng-show=&quot;data.connected&quot;&gt;</span><br><span class=\"line\">\t\t&lt;label&gt;&#123;&#123;data.time&#125;&#125;&lt;/label&gt; &lt;br /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot;</span><br><span class=\"line\">\t\t\tng-model=&quot;data.message&quot; placeholder=&quot;请输入内容...&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;button ng-click=&quot;send()&quot; type=&quot;button&quot;&gt;发送&lt;/button&gt;</span><br><span class=\"line\">\t\t&lt;br /&gt; &lt;br /&gt; 消息列表： &lt;br /&gt;</span><br><span class=\"line\">\t\t&lt;table&gt;</span><br><span class=\"line\">\t\t\t&lt;thead&gt;</span><br><span class=\"line\">\t\t\t\t&lt;tr&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;th&gt;内容&lt;/th&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;th&gt;时间&lt;/th&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/tr&gt;</span><br><span class=\"line\">\t\t\t&lt;/thead&gt;</span><br><span class=\"line\">\t\t\t&lt;tbody&gt;</span><br><span class=\"line\">\t\t\t\t&lt;tr ng-repeat=&quot;row in data.rows&quot;&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;td&gt;&#123;&#123;row.message&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;td&gt;&#123;&#123;row.date&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/tr&gt;</span><br><span class=\"line\">\t\t\t&lt;/tbody&gt;</span><br><span class=\"line\">\t\t&lt;/table&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/03/02/WX20180302-094543.png\" alt=\"演示图\"></p>\n<p><a href=\"https://github.com/wangweiye01/websocket\" target=\"_blank\" rel=\"noopener\">代码地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/03/02/3b41bb4144a7478ef7d1937c3a0ec56975e163f61a9ba-n8Syo1_fw658.jpg\" alt=\"pic\"></p>\n<h1 id=\"什么是WebSocket\"><a href=\"#什么是WebSocket\" class=\"headerlink\" title=\"什么是WebSocket\"></a>什么是WebSocket</h1><p>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。</p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@EnableWebSocketMessageBroker</span><br><span class=\"line\">public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void configureMessageBroker(MessageBrokerRegistry config) &#123;</span><br><span class=\"line\">\t\tconfig.enableSimpleBroker(&quot;/topic&quot;);</span><br><span class=\"line\">\t\tconfig.setApplicationDestinationPrefixes(&quot;/app&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void registerStompEndpoints(StompEndpointRegistry registry) &#123;</span><br><span class=\"line\">\t\tregistry.addEndpoint(&quot;/my-websocket&quot;).withSockJS();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里配置了以”/app”开头的websocket请求url和名为”my-websocket”的endpoint</p>\n<ol>\n<li>@EnableWebSocketMessageBroker注解表示开启使用STOMP协议来传输基于代理的消息</li>\n<li>registerStompEndpoints方法表示注册STOMP协议的节点，并指定映射的URL</li>\n<li><code>registry.addEndpoint(&quot;/my-websocket&quot;).withSockJS()</code>这一行代码用来注册STOMP协议节点，同时指定使用SockJS协议。</li>\n<li>configureMessageBroker方法用来配置消息代理，由于我们是实现推送功能，这里的消息代理是/topic</li>\n</ol>\n<h1 id=\"推送消息类\"><a href=\"#推送消息类\" class=\"headerlink\" title=\"推送消息类\"></a>推送消息类</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SocketMessage &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String message;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String date;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">@EnableScheduling</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class App &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tSpringApplication.run(App.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Autowired</span><br><span class=\"line\">\tprivate SimpMessagingTemplate messagingTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@GetMapping(&quot;/&quot;)</span><br><span class=\"line\">\tpublic String index() &#123;</span><br><span class=\"line\">\t\treturn &quot;index&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@MessageMapping(&quot;/send&quot;)</span><br><span class=\"line\">\t@SendTo(&quot;/topic/send&quot;)</span><br><span class=\"line\">\tpublic SocketMessage send(SocketMessage message) throws Exception &#123;</span><br><span class=\"line\">\t\tDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class=\"line\">\t\tmessage.date = df.format(new Date());</span><br><span class=\"line\">\t\treturn message;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Scheduled(fixedRate = 1000)</span><br><span class=\"line\">\t@SendTo(&quot;/topic/callback&quot;)</span><br><span class=\"line\">\tpublic Object callback() throws Exception &#123;</span><br><span class=\"line\">\t\t// 发现消息</span><br><span class=\"line\">\t\tDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class=\"line\">\t\tmessagingTemplate.convertAndSend(&quot;/topic/callback&quot;, df.format(new Date()));</span><br><span class=\"line\">\t\treturn &quot;callback&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@MessageMapping</code>注解和<code>@RequestMapping</code>类似，用来发送消息到特定路径</p>\n<p><code>@SendTo</code>注解表示当服务器有消息需要推送的时候，会对订阅了<code>@SendTo</code>中路径的客户端发送消息</p>\n<h1 id=\"前端脚本\"><a href=\"#前端脚本\" class=\"headerlink\" title=\"前端脚本\"></a>前端脚本</h1><p>我们这个案例需要三个js脚本文件，分别是STOMP协议的客户端脚本stomp.js、SockJS的客户端脚本sock.js以及jQuery</p>\n<h1 id=\"演示页面\"><a href=\"#演示页面\" class=\"headerlink\" title=\"演示页面\"></a>演示页面</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;websocket&lt;/title&gt;</span><br><span class=\"line\">&lt;script src=&quot;//cdn.bootcss.com/angular.js/1.5.6/angular.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/sockjs-client/1.1.4/sockjs.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/stomp.js/2.3.3/stomp.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar stompClient = null;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar app = angular.module(&apos;app&apos;, []);</span><br><span class=\"line\">\tapp.controller(&apos;MainController&apos;, function($rootScope, $scope, $http) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t$scope.data = &#123;</span><br><span class=\"line\">\t\t\t//连接状态</span><br><span class=\"line\">\t\t\tconnected : false,</span><br><span class=\"line\">\t\t\t//消息</span><br><span class=\"line\">\t\t\tmessage : &apos;&apos;,</span><br><span class=\"line\">\t\t\trows : []</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//连接</span><br><span class=\"line\">\t\t$scope.connect = function() &#123;</span><br><span class=\"line\">\t\t\tvar socket = new SockJS(&apos;/my-websocket&apos;);</span><br><span class=\"line\">\t\t\tstompClient = Stomp.over(socket);</span><br><span class=\"line\">\t\t\tstompClient.connect(&#123;&#125;, function(frame) &#123;</span><br><span class=\"line\">\t\t\t\t// 注册发送消息</span><br><span class=\"line\">\t\t\t\tstompClient.subscribe(&apos;/topic/send&apos;, function(msg) &#123;</span><br><span class=\"line\">\t\t\t\t\t$scope.data.rows.push(JSON.parse(msg.body));</span><br><span class=\"line\">\t\t\t\t\t$scope.data.connected = true;</span><br><span class=\"line\">\t\t\t\t\t$scope.$apply();</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t// 注册推送时间回调</span><br><span class=\"line\">\t\t\t\tstompClient.subscribe(&apos;/topic/callback&apos;, function(r) &#123;</span><br><span class=\"line\">\t\t\t\t\t$scope.data.time = &apos;当前服务器时间：&apos; + r.body;</span><br><span class=\"line\">\t\t\t\t\t$scope.data.connected = true;</span><br><span class=\"line\">\t\t\t\t\t$scope.$apply();</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t$scope.data.connected = true;</span><br><span class=\"line\">\t\t\t\t$scope.$apply();</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t$scope.disconnect = function() &#123;</span><br><span class=\"line\">\t\t\tif (stompClient != null) &#123;</span><br><span class=\"line\">\t\t\t\tstompClient.disconnect();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t$scope.data.connected = false;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t$scope.send = function() &#123;</span><br><span class=\"line\">\t\t\tstompClient.send(&quot;/app/send&quot;, &#123;&#125;, JSON.stringify(&#123;</span><br><span class=\"line\">\t\t\t\t&apos;message&apos; : $scope.data.message</span><br><span class=\"line\">\t\t\t&#125;));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body ng-app=&quot;app&quot; ng-controller=&quot;MainController&quot;&gt;</span><br><span class=\"line\">\t&lt;label&gt;WebSocket连接状态:&lt;/label&gt;</span><br><span class=\"line\">\t&lt;button type=&quot;button&quot; ng-disabled=&quot;data.connected&quot; ng-click=&quot;connect()&quot;&gt;连接&lt;/button&gt;</span><br><span class=\"line\">\t&lt;button type=&quot;button&quot; ng-click=&quot;disconnect()&quot;</span><br><span class=\"line\">\t\tng-disabled=&quot;!data.connected&quot;&gt;断开&lt;/button&gt;</span><br><span class=\"line\">\t&lt;br /&gt;</span><br><span class=\"line\">\t&lt;br /&gt;</span><br><span class=\"line\">\t&lt;div ng-show=&quot;data.connected&quot;&gt;</span><br><span class=\"line\">\t\t&lt;label&gt;&#123;&#123;data.time&#125;&#125;&lt;/label&gt; &lt;br /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot;</span><br><span class=\"line\">\t\t\tng-model=&quot;data.message&quot; placeholder=&quot;请输入内容...&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;button ng-click=&quot;send()&quot; type=&quot;button&quot;&gt;发送&lt;/button&gt;</span><br><span class=\"line\">\t\t&lt;br /&gt; &lt;br /&gt; 消息列表： &lt;br /&gt;</span><br><span class=\"line\">\t\t&lt;table&gt;</span><br><span class=\"line\">\t\t\t&lt;thead&gt;</span><br><span class=\"line\">\t\t\t\t&lt;tr&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;th&gt;内容&lt;/th&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;th&gt;时间&lt;/th&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/tr&gt;</span><br><span class=\"line\">\t\t\t&lt;/thead&gt;</span><br><span class=\"line\">\t\t\t&lt;tbody&gt;</span><br><span class=\"line\">\t\t\t\t&lt;tr ng-repeat=&quot;row in data.rows&quot;&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;td&gt;&#123;&#123;row.message&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;td&gt;&#123;&#123;row.date&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/tr&gt;</span><br><span class=\"line\">\t\t\t&lt;/tbody&gt;</span><br><span class=\"line\">\t\t&lt;/table&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/03/02/WX20180302-094543.png\" alt=\"演示图\"></p>\n<p><a href=\"https://github.com/wangweiye01/websocket\" target=\"_blank\" rel=\"noopener\">代码地址</a></p>\n"},{"title":"区块链的理解","date":"2018-01-19T01:49:44.000Z","_content":"![pic](http://s1.wailian.download/2018/01/19/f7a1eb169a2ac8556d241cd7173ca9a5d9ede3cb161fa5-eeMK3M_fw658.jpg)\n> 最近在各个媒体中出现了区块链的概念，抽时间了解了一下\n\n# 区块链的本质\n\n区块链是什么？它就是一种特殊的分布式数据库。\n\n首先，区块链的主要作用是储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取，所以它是数据库。\n\n其次，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。\n\n# 区块链的最大特点\n\n分布式数据库并非新发明，市场上早有此类产品。但是，区块链有一个革命性特点。\n\n区块链没有管理员，它是彻底无中心的。其他的数据库都有管理员，但是区块链没有。如果有人想对区块链添加审核，也实现不了，因为它的设计目标就是防止出现居于中心地位的管理当局。\n\n正是因为无法管理，区块链才能做到无法被控制。否则一旦大公司大集团控制了管理权，他们就会控制整个平台，其他使用者都必须听命于他们了。\n\n但是，没有了管理员，人人都可以往里面写入数据，怎么才能保证数据的可信呢？被坏人改了怎么办？请接着往下读，着就是区块链的奇妙之处。\n\n# 区块\n\n区块链由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。类似于数据结构当中的链表。\n\n![blockchain](http://s1.wailian.download/2018/01/19/bg2017122703.png)\n\n每个区块包含两部分。\n\n- Head：记录当前区块的元信息\n- Body：实际数据\n\n区块头包含了当前区块的多项元信息。\n\n- 生成时间\n- 实际数据的Hash\n- 上一区块的Hash\n- ...\n\n这里，你需要理解什么叫 Hash，这是理解区块链必需的。\n\n![hash](http://s1.wailian.download/2018/01/19/bg2017122704.png)\n\n所谓 Hash 就是计算机可以对任意内容，计算出一个长度相同的特征值。区块链的 Hash 长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的 Hash 一定是不同的。\n\n举例来说，字符串123的 Hash 是a8fdc205a9f19cc1c7507a60c4f01b13d11d7fd0（十六进制），转成二进制就是256位，而且只有123能得到这个 Hash。\n\n因此，就有两个重要的推论。\n\n- 每个区块的 Hash 都是不一样的，可以通过 Hash 标识区块。\n- 如果区块的内容变了，它的 Hash 一定会改变。\n\n# Hash 的不可修改性\n\n区块与 Hash 是一一对应的，每个区块的 Hash 都是针对\"区块头\"（Head）计算的。\n\n> Hash = SHA256(区块头)\n\n上面就是区块 Hash 的计算公式，Hash 由区块头唯一决定，SHA256是区块链的 Hash 算法。\n\n前面说过，区块头包含很多内容，其中有当前区块体的 Hash（注意是\"区块体\"的 Hash，而不是整个区块），还有上一个区块的 Hash。这意味着，如果当前区块的内容变了，或者上一个区块的 Hash 变了，一定会引起当前区块的 Hash 改变。\n\n这一点对区块链有重大意义。如果有人修改了一个区块，该区块的 Hash 就变了。为了让后面的区块还能连到它，该人必须同时修改后面所有的区块，否则被改掉的区块就脱离区块链了。由于后面要提到的原因，Hash 的计算很耗时，同时修改多个区块几乎不可能发生，除非有人掌握了全网51%以上的计算能力。\n\n正是通过这种联动机制，区块链保证了自身的可靠性，数据一旦写入，就无法被篡改。这就像历史一样，发生了就是发生了，从此再无法改变。\n\n![](http://s1.wailian.download/2018/01/19/bg2017122705.png)\n每个区块都连着上一个区块，这也是\"区块链\"这个名字的由来。\n\n# 采矿\n\n由于必须保证节点之间的同步，所以新区块的添加速度不能太快。试想一下，你刚刚同步了一个区块，准备基于它生成下一个区块，但这时别的节点又有新区块生成，你不得不放弃做了一半的计算，再次去同步。因为每个区块的后面，只能跟着一个区块，你永远只能在最新区块的后面，生成下一个区块。所以，你别无选择，一听到信号，就必须立刻同步。\n\n所以，区块链的发明者中本聪（这是假名，真实身份至今未知）故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个。\n\n这种产出速度不是通过命令达成的，而是故意设置了海量的计算。也就是说，只有通过极其大量的计算，才能得到当前区块的有效 Hash，从而把新区块添加到区块链。由于计算量太大，所以快不起来。\n\n这个过程就叫做采矿（mining），因为计算有效 Hash 的难度，好比在全世界的沙子里面，找到一粒符合条件的沙子。计算 Hash 的机器就叫做矿机，操作矿机的人就叫做矿工。\n\n# 难度系数\n读到这里，你可能会有一个疑问，人们都说采矿很难，可是采矿不就是用计算机算出一个 Hash 吗，这正是计算机的强项啊，怎么会变得很难，迟迟算不出来呢？\n\n原来不是任意一个 Hash 都可以，只有满足条件的 Hash 才会被区块链接受。这个条件特别苛刻，使得绝大部分 Hash 都不满足要求，必须重算。\n\n原来，区块头包含一个难度系数（difficulty），这个值决定了计算 Hash 的难度。举例来说，第100000个区块的难度系数是 14484.16236122。\n\n![](http://s1.wailian.download/2018/01/19/bg2017122707.png)\n区块链协议规定，使用一个常量除以难度系数，可以得到目标值（target）。显然，难度系数越大，目标值就越小。\n\n![](http://s1.wailian.download/2018/01/19/bg2017122708.png)\n\nHash 的有效性跟目标值密切相关，只有小于目标值的 Hash 才是有效的，否则 Hash 无效，必须重算。由于目标值非常小，Hash 小于该值的机会极其渺茫，可能计算10亿次，才算中一次。这就是采矿如此之慢的根本原因。\n\n区块头里面还有一个 Nonce 值，记录了 Hash 重算的次数。第 100000 个区块的 Nonce 值是274148111，即计算了 2.74 亿次，才得到了一个有效的 Hash，该区块才能加入区块链。\n\n# 难度系数的动态调节\n\n就算采矿很难，但也没法保证，正好十分钟产出一个区块，有时一分钟就算出来了，有时几个小时可能也没结果。总体来看，随着硬件设备的提升，以及矿机的数量增长，计算速度一定会越来越快。\n\n为了将产出速率恒定在十分钟，中本聪还设计了难度系数的动态调节机制。他规定，难度系数每两周（2016个区块）调整一次。如果这两周里面，区块的平均生成速度是9分钟，就意味着比法定速度快了10%，因此难度系数就要调高10%；如果平均生成速度是11分钟，就意味着比法定速度慢了10%，因此难度系数就要调低10%。\n\n难度系数越调越高（目标值越来越小），导致了采矿越来越难。\n\n# 区块链的分叉\n\n即使区块链是可靠的，现在还有一个问题没有解决：如果两个人同时向区块链写入数据，也就是说，同时有两个区块加入，因为它们都连着前一个区块，就形成了分叉。这时应该采纳哪一个区块呢？\n\n![](http://s1.wailian.download/2018/01/19/bg2017122709.png)\n\n现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为\"六次确认\"）。按照10分钟一个区块计算，一小时就可以确认。\n\n![](http://s1.wailian.download/2018/01/19/bg2017122710.png)\n\n由于新区块的生成速度由计算能力决定，所以这条规则就是说，拥有大多数计算能力的那条分支，就是正宗的比特链。\n\n# 总结\n\n区块链作为无人管理的分布式数据库，从2009年开始已经运行了8年，没有出现大的问题。这证明它是可行的。\n\n但是，为了保证数据的可靠性，区块链也有自己的代价。一是效率，数据写入区块链，最少要等待十分钟，所有节点都同步数据，则需要更多的时间；二是能耗，区块的生成需要矿工进行无数无意义的计算，这是非常耗费能源的。\n\n因此，区块链的适用场景，其实非常有限。\n\n- 不存在所有成员都信任的管理当局\n- 写入的数据不要求实时使用\n- 挖矿的收益能够弥补本身的成本\n\n目前，区块链最大的应用场景（可能也是唯一的应用场景），就是以比特币为代表的加密货币\n\n> 参考自[阮一峰](http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html)\n","source":"_posts/blockchain.md","raw":"---\ntitle: 区块链的理解\ndate: 2018-01-19 09:49:44\ntags:\n---\n![pic](http://s1.wailian.download/2018/01/19/f7a1eb169a2ac8556d241cd7173ca9a5d9ede3cb161fa5-eeMK3M_fw658.jpg)\n> 最近在各个媒体中出现了区块链的概念，抽时间了解了一下\n\n# 区块链的本质\n\n区块链是什么？它就是一种特殊的分布式数据库。\n\n首先，区块链的主要作用是储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取，所以它是数据库。\n\n其次，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。\n\n# 区块链的最大特点\n\n分布式数据库并非新发明，市场上早有此类产品。但是，区块链有一个革命性特点。\n\n区块链没有管理员，它是彻底无中心的。其他的数据库都有管理员，但是区块链没有。如果有人想对区块链添加审核，也实现不了，因为它的设计目标就是防止出现居于中心地位的管理当局。\n\n正是因为无法管理，区块链才能做到无法被控制。否则一旦大公司大集团控制了管理权，他们就会控制整个平台，其他使用者都必须听命于他们了。\n\n但是，没有了管理员，人人都可以往里面写入数据，怎么才能保证数据的可信呢？被坏人改了怎么办？请接着往下读，着就是区块链的奇妙之处。\n\n# 区块\n\n区块链由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。类似于数据结构当中的链表。\n\n![blockchain](http://s1.wailian.download/2018/01/19/bg2017122703.png)\n\n每个区块包含两部分。\n\n- Head：记录当前区块的元信息\n- Body：实际数据\n\n区块头包含了当前区块的多项元信息。\n\n- 生成时间\n- 实际数据的Hash\n- 上一区块的Hash\n- ...\n\n这里，你需要理解什么叫 Hash，这是理解区块链必需的。\n\n![hash](http://s1.wailian.download/2018/01/19/bg2017122704.png)\n\n所谓 Hash 就是计算机可以对任意内容，计算出一个长度相同的特征值。区块链的 Hash 长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的 Hash 一定是不同的。\n\n举例来说，字符串123的 Hash 是a8fdc205a9f19cc1c7507a60c4f01b13d11d7fd0（十六进制），转成二进制就是256位，而且只有123能得到这个 Hash。\n\n因此，就有两个重要的推论。\n\n- 每个区块的 Hash 都是不一样的，可以通过 Hash 标识区块。\n- 如果区块的内容变了，它的 Hash 一定会改变。\n\n# Hash 的不可修改性\n\n区块与 Hash 是一一对应的，每个区块的 Hash 都是针对\"区块头\"（Head）计算的。\n\n> Hash = SHA256(区块头)\n\n上面就是区块 Hash 的计算公式，Hash 由区块头唯一决定，SHA256是区块链的 Hash 算法。\n\n前面说过，区块头包含很多内容，其中有当前区块体的 Hash（注意是\"区块体\"的 Hash，而不是整个区块），还有上一个区块的 Hash。这意味着，如果当前区块的内容变了，或者上一个区块的 Hash 变了，一定会引起当前区块的 Hash 改变。\n\n这一点对区块链有重大意义。如果有人修改了一个区块，该区块的 Hash 就变了。为了让后面的区块还能连到它，该人必须同时修改后面所有的区块，否则被改掉的区块就脱离区块链了。由于后面要提到的原因，Hash 的计算很耗时，同时修改多个区块几乎不可能发生，除非有人掌握了全网51%以上的计算能力。\n\n正是通过这种联动机制，区块链保证了自身的可靠性，数据一旦写入，就无法被篡改。这就像历史一样，发生了就是发生了，从此再无法改变。\n\n![](http://s1.wailian.download/2018/01/19/bg2017122705.png)\n每个区块都连着上一个区块，这也是\"区块链\"这个名字的由来。\n\n# 采矿\n\n由于必须保证节点之间的同步，所以新区块的添加速度不能太快。试想一下，你刚刚同步了一个区块，准备基于它生成下一个区块，但这时别的节点又有新区块生成，你不得不放弃做了一半的计算，再次去同步。因为每个区块的后面，只能跟着一个区块，你永远只能在最新区块的后面，生成下一个区块。所以，你别无选择，一听到信号，就必须立刻同步。\n\n所以，区块链的发明者中本聪（这是假名，真实身份至今未知）故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个。\n\n这种产出速度不是通过命令达成的，而是故意设置了海量的计算。也就是说，只有通过极其大量的计算，才能得到当前区块的有效 Hash，从而把新区块添加到区块链。由于计算量太大，所以快不起来。\n\n这个过程就叫做采矿（mining），因为计算有效 Hash 的难度，好比在全世界的沙子里面，找到一粒符合条件的沙子。计算 Hash 的机器就叫做矿机，操作矿机的人就叫做矿工。\n\n# 难度系数\n读到这里，你可能会有一个疑问，人们都说采矿很难，可是采矿不就是用计算机算出一个 Hash 吗，这正是计算机的强项啊，怎么会变得很难，迟迟算不出来呢？\n\n原来不是任意一个 Hash 都可以，只有满足条件的 Hash 才会被区块链接受。这个条件特别苛刻，使得绝大部分 Hash 都不满足要求，必须重算。\n\n原来，区块头包含一个难度系数（difficulty），这个值决定了计算 Hash 的难度。举例来说，第100000个区块的难度系数是 14484.16236122。\n\n![](http://s1.wailian.download/2018/01/19/bg2017122707.png)\n区块链协议规定，使用一个常量除以难度系数，可以得到目标值（target）。显然，难度系数越大，目标值就越小。\n\n![](http://s1.wailian.download/2018/01/19/bg2017122708.png)\n\nHash 的有效性跟目标值密切相关，只有小于目标值的 Hash 才是有效的，否则 Hash 无效，必须重算。由于目标值非常小，Hash 小于该值的机会极其渺茫，可能计算10亿次，才算中一次。这就是采矿如此之慢的根本原因。\n\n区块头里面还有一个 Nonce 值，记录了 Hash 重算的次数。第 100000 个区块的 Nonce 值是274148111，即计算了 2.74 亿次，才得到了一个有效的 Hash，该区块才能加入区块链。\n\n# 难度系数的动态调节\n\n就算采矿很难，但也没法保证，正好十分钟产出一个区块，有时一分钟就算出来了，有时几个小时可能也没结果。总体来看，随着硬件设备的提升，以及矿机的数量增长，计算速度一定会越来越快。\n\n为了将产出速率恒定在十分钟，中本聪还设计了难度系数的动态调节机制。他规定，难度系数每两周（2016个区块）调整一次。如果这两周里面，区块的平均生成速度是9分钟，就意味着比法定速度快了10%，因此难度系数就要调高10%；如果平均生成速度是11分钟，就意味着比法定速度慢了10%，因此难度系数就要调低10%。\n\n难度系数越调越高（目标值越来越小），导致了采矿越来越难。\n\n# 区块链的分叉\n\n即使区块链是可靠的，现在还有一个问题没有解决：如果两个人同时向区块链写入数据，也就是说，同时有两个区块加入，因为它们都连着前一个区块，就形成了分叉。这时应该采纳哪一个区块呢？\n\n![](http://s1.wailian.download/2018/01/19/bg2017122709.png)\n\n现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为\"六次确认\"）。按照10分钟一个区块计算，一小时就可以确认。\n\n![](http://s1.wailian.download/2018/01/19/bg2017122710.png)\n\n由于新区块的生成速度由计算能力决定，所以这条规则就是说，拥有大多数计算能力的那条分支，就是正宗的比特链。\n\n# 总结\n\n区块链作为无人管理的分布式数据库，从2009年开始已经运行了8年，没有出现大的问题。这证明它是可行的。\n\n但是，为了保证数据的可靠性，区块链也有自己的代价。一是效率，数据写入区块链，最少要等待十分钟，所有节点都同步数据，则需要更多的时间；二是能耗，区块的生成需要矿工进行无数无意义的计算，这是非常耗费能源的。\n\n因此，区块链的适用场景，其实非常有限。\n\n- 不存在所有成员都信任的管理当局\n- 写入的数据不要求实时使用\n- 挖矿的收益能够弥补本身的成本\n\n目前，区块链最大的应用场景（可能也是唯一的应用场景），就是以比特币为代表的加密货币\n\n> 参考自[阮一峰](http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html)\n","slug":"blockchain","published":1,"updated":"2019-12-24T02:00:57.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3k3c00200j9k0juva076","content":"<p><img src=\"http://s1.wailian.download/2018/01/19/f7a1eb169a2ac8556d241cd7173ca9a5d9ede3cb161fa5-eeMK3M_fw658.jpg\" alt=\"pic\"></p>\n<blockquote>\n<p>最近在各个媒体中出现了区块链的概念，抽时间了解了一下</p>\n</blockquote>\n<h1 id=\"区块链的本质\"><a href=\"#区块链的本质\" class=\"headerlink\" title=\"区块链的本质\"></a>区块链的本质</h1><p>区块链是什么？它就是一种特殊的分布式数据库。</p>\n<p>首先，区块链的主要作用是储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取，所以它是数据库。</p>\n<p>其次，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。</p>\n<h1 id=\"区块链的最大特点\"><a href=\"#区块链的最大特点\" class=\"headerlink\" title=\"区块链的最大特点\"></a>区块链的最大特点</h1><p>分布式数据库并非新发明，市场上早有此类产品。但是，区块链有一个革命性特点。</p>\n<p>区块链没有管理员，它是彻底无中心的。其他的数据库都有管理员，但是区块链没有。如果有人想对区块链添加审核，也实现不了，因为它的设计目标就是防止出现居于中心地位的管理当局。</p>\n<p>正是因为无法管理，区块链才能做到无法被控制。否则一旦大公司大集团控制了管理权，他们就会控制整个平台，其他使用者都必须听命于他们了。</p>\n<p>但是，没有了管理员，人人都可以往里面写入数据，怎么才能保证数据的可信呢？被坏人改了怎么办？请接着往下读，着就是区块链的奇妙之处。</p>\n<h1 id=\"区块\"><a href=\"#区块\" class=\"headerlink\" title=\"区块\"></a>区块</h1><p>区块链由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。类似于数据结构当中的链表。</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122703.png\" alt=\"blockchain\"></p>\n<p>每个区块包含两部分。</p>\n<ul>\n<li>Head：记录当前区块的元信息</li>\n<li>Body：实际数据</li>\n</ul>\n<p>区块头包含了当前区块的多项元信息。</p>\n<ul>\n<li>生成时间</li>\n<li>实际数据的Hash</li>\n<li>上一区块的Hash</li>\n<li>…</li>\n</ul>\n<p>这里，你需要理解什么叫 Hash，这是理解区块链必需的。</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122704.png\" alt=\"hash\"></p>\n<p>所谓 Hash 就是计算机可以对任意内容，计算出一个长度相同的特征值。区块链的 Hash 长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的 Hash 一定是不同的。</p>\n<p>举例来说，字符串123的 Hash 是a8fdc205a9f19cc1c7507a60c4f01b13d11d7fd0（十六进制），转成二进制就是256位，而且只有123能得到这个 Hash。</p>\n<p>因此，就有两个重要的推论。</p>\n<ul>\n<li>每个区块的 Hash 都是不一样的，可以通过 Hash 标识区块。</li>\n<li>如果区块的内容变了，它的 Hash 一定会改变。</li>\n</ul>\n<h1 id=\"Hash-的不可修改性\"><a href=\"#Hash-的不可修改性\" class=\"headerlink\" title=\"Hash 的不可修改性\"></a>Hash 的不可修改性</h1><p>区块与 Hash 是一一对应的，每个区块的 Hash 都是针对”区块头”（Head）计算的。</p>\n<blockquote>\n<p>Hash = SHA256(区块头)</p>\n</blockquote>\n<p>上面就是区块 Hash 的计算公式，Hash 由区块头唯一决定，SHA256是区块链的 Hash 算法。</p>\n<p>前面说过，区块头包含很多内容，其中有当前区块体的 Hash（注意是”区块体”的 Hash，而不是整个区块），还有上一个区块的 Hash。这意味着，如果当前区块的内容变了，或者上一个区块的 Hash 变了，一定会引起当前区块的 Hash 改变。</p>\n<p>这一点对区块链有重大意义。如果有人修改了一个区块，该区块的 Hash 就变了。为了让后面的区块还能连到它，该人必须同时修改后面所有的区块，否则被改掉的区块就脱离区块链了。由于后面要提到的原因，Hash 的计算很耗时，同时修改多个区块几乎不可能发生，除非有人掌握了全网51%以上的计算能力。</p>\n<p>正是通过这种联动机制，区块链保证了自身的可靠性，数据一旦写入，就无法被篡改。这就像历史一样，发生了就是发生了，从此再无法改变。</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122705.png\" alt=\"\"><br>每个区块都连着上一个区块，这也是”区块链”这个名字的由来。</p>\n<h1 id=\"采矿\"><a href=\"#采矿\" class=\"headerlink\" title=\"采矿\"></a>采矿</h1><p>由于必须保证节点之间的同步，所以新区块的添加速度不能太快。试想一下，你刚刚同步了一个区块，准备基于它生成下一个区块，但这时别的节点又有新区块生成，你不得不放弃做了一半的计算，再次去同步。因为每个区块的后面，只能跟着一个区块，你永远只能在最新区块的后面，生成下一个区块。所以，你别无选择，一听到信号，就必须立刻同步。</p>\n<p>所以，区块链的发明者中本聪（这是假名，真实身份至今未知）故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个。</p>\n<p>这种产出速度不是通过命令达成的，而是故意设置了海量的计算。也就是说，只有通过极其大量的计算，才能得到当前区块的有效 Hash，从而把新区块添加到区块链。由于计算量太大，所以快不起来。</p>\n<p>这个过程就叫做采矿（mining），因为计算有效 Hash 的难度，好比在全世界的沙子里面，找到一粒符合条件的沙子。计算 Hash 的机器就叫做矿机，操作矿机的人就叫做矿工。</p>\n<h1 id=\"难度系数\"><a href=\"#难度系数\" class=\"headerlink\" title=\"难度系数\"></a>难度系数</h1><p>读到这里，你可能会有一个疑问，人们都说采矿很难，可是采矿不就是用计算机算出一个 Hash 吗，这正是计算机的强项啊，怎么会变得很难，迟迟算不出来呢？</p>\n<p>原来不是任意一个 Hash 都可以，只有满足条件的 Hash 才会被区块链接受。这个条件特别苛刻，使得绝大部分 Hash 都不满足要求，必须重算。</p>\n<p>原来，区块头包含一个难度系数（difficulty），这个值决定了计算 Hash 的难度。举例来说，第100000个区块的难度系数是 14484.16236122。</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122707.png\" alt=\"\"><br>区块链协议规定，使用一个常量除以难度系数，可以得到目标值（target）。显然，难度系数越大，目标值就越小。</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122708.png\" alt=\"\"></p>\n<p>Hash 的有效性跟目标值密切相关，只有小于目标值的 Hash 才是有效的，否则 Hash 无效，必须重算。由于目标值非常小，Hash 小于该值的机会极其渺茫，可能计算10亿次，才算中一次。这就是采矿如此之慢的根本原因。</p>\n<p>区块头里面还有一个 Nonce 值，记录了 Hash 重算的次数。第 100000 个区块的 Nonce 值是274148111，即计算了 2.74 亿次，才得到了一个有效的 Hash，该区块才能加入区块链。</p>\n<h1 id=\"难度系数的动态调节\"><a href=\"#难度系数的动态调节\" class=\"headerlink\" title=\"难度系数的动态调节\"></a>难度系数的动态调节</h1><p>就算采矿很难，但也没法保证，正好十分钟产出一个区块，有时一分钟就算出来了，有时几个小时可能也没结果。总体来看，随着硬件设备的提升，以及矿机的数量增长，计算速度一定会越来越快。</p>\n<p>为了将产出速率恒定在十分钟，中本聪还设计了难度系数的动态调节机制。他规定，难度系数每两周（2016个区块）调整一次。如果这两周里面，区块的平均生成速度是9分钟，就意味着比法定速度快了10%，因此难度系数就要调高10%；如果平均生成速度是11分钟，就意味着比法定速度慢了10%，因此难度系数就要调低10%。</p>\n<p>难度系数越调越高（目标值越来越小），导致了采矿越来越难。</p>\n<h1 id=\"区块链的分叉\"><a href=\"#区块链的分叉\" class=\"headerlink\" title=\"区块链的分叉\"></a>区块链的分叉</h1><p>即使区块链是可靠的，现在还有一个问题没有解决：如果两个人同时向区块链写入数据，也就是说，同时有两个区块加入，因为它们都连着前一个区块，就形成了分叉。这时应该采纳哪一个区块呢？</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122709.png\" alt=\"\"></p>\n<p>现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为”六次确认”）。按照10分钟一个区块计算，一小时就可以确认。</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122710.png\" alt=\"\"></p>\n<p>由于新区块的生成速度由计算能力决定，所以这条规则就是说，拥有大多数计算能力的那条分支，就是正宗的比特链。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>区块链作为无人管理的分布式数据库，从2009年开始已经运行了8年，没有出现大的问题。这证明它是可行的。</p>\n<p>但是，为了保证数据的可靠性，区块链也有自己的代价。一是效率，数据写入区块链，最少要等待十分钟，所有节点都同步数据，则需要更多的时间；二是能耗，区块的生成需要矿工进行无数无意义的计算，这是非常耗费能源的。</p>\n<p>因此，区块链的适用场景，其实非常有限。</p>\n<ul>\n<li>不存在所有成员都信任的管理当局</li>\n<li>写入的数据不要求实时使用</li>\n<li>挖矿的收益能够弥补本身的成本</li>\n</ul>\n<p>目前，区块链最大的应用场景（可能也是唯一的应用场景），就是以比特币为代表的加密货币</p>\n<blockquote>\n<p>参考自<a href=\"http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html\" target=\"_blank\" rel=\"noopener\">阮一峰</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://s1.wailian.download/2018/01/19/f7a1eb169a2ac8556d241cd7173ca9a5d9ede3cb161fa5-eeMK3M_fw658.jpg\" alt=\"pic\"></p>\n<blockquote>\n<p>最近在各个媒体中出现了区块链的概念，抽时间了解了一下</p>\n</blockquote>\n<h1 id=\"区块链的本质\"><a href=\"#区块链的本质\" class=\"headerlink\" title=\"区块链的本质\"></a>区块链的本质</h1><p>区块链是什么？它就是一种特殊的分布式数据库。</p>\n<p>首先，区块链的主要作用是储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取，所以它是数据库。</p>\n<p>其次，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。</p>\n<h1 id=\"区块链的最大特点\"><a href=\"#区块链的最大特点\" class=\"headerlink\" title=\"区块链的最大特点\"></a>区块链的最大特点</h1><p>分布式数据库并非新发明，市场上早有此类产品。但是，区块链有一个革命性特点。</p>\n<p>区块链没有管理员，它是彻底无中心的。其他的数据库都有管理员，但是区块链没有。如果有人想对区块链添加审核，也实现不了，因为它的设计目标就是防止出现居于中心地位的管理当局。</p>\n<p>正是因为无法管理，区块链才能做到无法被控制。否则一旦大公司大集团控制了管理权，他们就会控制整个平台，其他使用者都必须听命于他们了。</p>\n<p>但是，没有了管理员，人人都可以往里面写入数据，怎么才能保证数据的可信呢？被坏人改了怎么办？请接着往下读，着就是区块链的奇妙之处。</p>\n<h1 id=\"区块\"><a href=\"#区块\" class=\"headerlink\" title=\"区块\"></a>区块</h1><p>区块链由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。类似于数据结构当中的链表。</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122703.png\" alt=\"blockchain\"></p>\n<p>每个区块包含两部分。</p>\n<ul>\n<li>Head：记录当前区块的元信息</li>\n<li>Body：实际数据</li>\n</ul>\n<p>区块头包含了当前区块的多项元信息。</p>\n<ul>\n<li>生成时间</li>\n<li>实际数据的Hash</li>\n<li>上一区块的Hash</li>\n<li>…</li>\n</ul>\n<p>这里，你需要理解什么叫 Hash，这是理解区块链必需的。</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122704.png\" alt=\"hash\"></p>\n<p>所谓 Hash 就是计算机可以对任意内容，计算出一个长度相同的特征值。区块链的 Hash 长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的 Hash 一定是不同的。</p>\n<p>举例来说，字符串123的 Hash 是a8fdc205a9f19cc1c7507a60c4f01b13d11d7fd0（十六进制），转成二进制就是256位，而且只有123能得到这个 Hash。</p>\n<p>因此，就有两个重要的推论。</p>\n<ul>\n<li>每个区块的 Hash 都是不一样的，可以通过 Hash 标识区块。</li>\n<li>如果区块的内容变了，它的 Hash 一定会改变。</li>\n</ul>\n<h1 id=\"Hash-的不可修改性\"><a href=\"#Hash-的不可修改性\" class=\"headerlink\" title=\"Hash 的不可修改性\"></a>Hash 的不可修改性</h1><p>区块与 Hash 是一一对应的，每个区块的 Hash 都是针对”区块头”（Head）计算的。</p>\n<blockquote>\n<p>Hash = SHA256(区块头)</p>\n</blockquote>\n<p>上面就是区块 Hash 的计算公式，Hash 由区块头唯一决定，SHA256是区块链的 Hash 算法。</p>\n<p>前面说过，区块头包含很多内容，其中有当前区块体的 Hash（注意是”区块体”的 Hash，而不是整个区块），还有上一个区块的 Hash。这意味着，如果当前区块的内容变了，或者上一个区块的 Hash 变了，一定会引起当前区块的 Hash 改变。</p>\n<p>这一点对区块链有重大意义。如果有人修改了一个区块，该区块的 Hash 就变了。为了让后面的区块还能连到它，该人必须同时修改后面所有的区块，否则被改掉的区块就脱离区块链了。由于后面要提到的原因，Hash 的计算很耗时，同时修改多个区块几乎不可能发生，除非有人掌握了全网51%以上的计算能力。</p>\n<p>正是通过这种联动机制，区块链保证了自身的可靠性，数据一旦写入，就无法被篡改。这就像历史一样，发生了就是发生了，从此再无法改变。</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122705.png\" alt=\"\"><br>每个区块都连着上一个区块，这也是”区块链”这个名字的由来。</p>\n<h1 id=\"采矿\"><a href=\"#采矿\" class=\"headerlink\" title=\"采矿\"></a>采矿</h1><p>由于必须保证节点之间的同步，所以新区块的添加速度不能太快。试想一下，你刚刚同步了一个区块，准备基于它生成下一个区块，但这时别的节点又有新区块生成，你不得不放弃做了一半的计算，再次去同步。因为每个区块的后面，只能跟着一个区块，你永远只能在最新区块的后面，生成下一个区块。所以，你别无选择，一听到信号，就必须立刻同步。</p>\n<p>所以，区块链的发明者中本聪（这是假名，真实身份至今未知）故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个。</p>\n<p>这种产出速度不是通过命令达成的，而是故意设置了海量的计算。也就是说，只有通过极其大量的计算，才能得到当前区块的有效 Hash，从而把新区块添加到区块链。由于计算量太大，所以快不起来。</p>\n<p>这个过程就叫做采矿（mining），因为计算有效 Hash 的难度，好比在全世界的沙子里面，找到一粒符合条件的沙子。计算 Hash 的机器就叫做矿机，操作矿机的人就叫做矿工。</p>\n<h1 id=\"难度系数\"><a href=\"#难度系数\" class=\"headerlink\" title=\"难度系数\"></a>难度系数</h1><p>读到这里，你可能会有一个疑问，人们都说采矿很难，可是采矿不就是用计算机算出一个 Hash 吗，这正是计算机的强项啊，怎么会变得很难，迟迟算不出来呢？</p>\n<p>原来不是任意一个 Hash 都可以，只有满足条件的 Hash 才会被区块链接受。这个条件特别苛刻，使得绝大部分 Hash 都不满足要求，必须重算。</p>\n<p>原来，区块头包含一个难度系数（difficulty），这个值决定了计算 Hash 的难度。举例来说，第100000个区块的难度系数是 14484.16236122。</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122707.png\" alt=\"\"><br>区块链协议规定，使用一个常量除以难度系数，可以得到目标值（target）。显然，难度系数越大，目标值就越小。</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122708.png\" alt=\"\"></p>\n<p>Hash 的有效性跟目标值密切相关，只有小于目标值的 Hash 才是有效的，否则 Hash 无效，必须重算。由于目标值非常小，Hash 小于该值的机会极其渺茫，可能计算10亿次，才算中一次。这就是采矿如此之慢的根本原因。</p>\n<p>区块头里面还有一个 Nonce 值，记录了 Hash 重算的次数。第 100000 个区块的 Nonce 值是274148111，即计算了 2.74 亿次，才得到了一个有效的 Hash，该区块才能加入区块链。</p>\n<h1 id=\"难度系数的动态调节\"><a href=\"#难度系数的动态调节\" class=\"headerlink\" title=\"难度系数的动态调节\"></a>难度系数的动态调节</h1><p>就算采矿很难，但也没法保证，正好十分钟产出一个区块，有时一分钟就算出来了，有时几个小时可能也没结果。总体来看，随着硬件设备的提升，以及矿机的数量增长，计算速度一定会越来越快。</p>\n<p>为了将产出速率恒定在十分钟，中本聪还设计了难度系数的动态调节机制。他规定，难度系数每两周（2016个区块）调整一次。如果这两周里面，区块的平均生成速度是9分钟，就意味着比法定速度快了10%，因此难度系数就要调高10%；如果平均生成速度是11分钟，就意味着比法定速度慢了10%，因此难度系数就要调低10%。</p>\n<p>难度系数越调越高（目标值越来越小），导致了采矿越来越难。</p>\n<h1 id=\"区块链的分叉\"><a href=\"#区块链的分叉\" class=\"headerlink\" title=\"区块链的分叉\"></a>区块链的分叉</h1><p>即使区块链是可靠的，现在还有一个问题没有解决：如果两个人同时向区块链写入数据，也就是说，同时有两个区块加入，因为它们都连着前一个区块，就形成了分叉。这时应该采纳哪一个区块呢？</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122709.png\" alt=\"\"></p>\n<p>现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为”六次确认”）。按照10分钟一个区块计算，一小时就可以确认。</p>\n<p><img src=\"http://s1.wailian.download/2018/01/19/bg2017122710.png\" alt=\"\"></p>\n<p>由于新区块的生成速度由计算能力决定，所以这条规则就是说，拥有大多数计算能力的那条分支，就是正宗的比特链。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>区块链作为无人管理的分布式数据库，从2009年开始已经运行了8年，没有出现大的问题。这证明它是可行的。</p>\n<p>但是，为了保证数据的可靠性，区块链也有自己的代价。一是效率，数据写入区块链，最少要等待十分钟，所有节点都同步数据，则需要更多的时间；二是能耗，区块的生成需要矿工进行无数无意义的计算，这是非常耗费能源的。</p>\n<p>因此，区块链的适用场景，其实非常有限。</p>\n<ul>\n<li>不存在所有成员都信任的管理当局</li>\n<li>写入的数据不要求实时使用</li>\n<li>挖矿的收益能够弥补本身的成本</li>\n</ul>\n<p>目前，区块链最大的应用场景（可能也是唯一的应用场景），就是以比特币为代表的加密货币</p>\n<blockquote>\n<p>参考自<a href=\"http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html\" target=\"_blank\" rel=\"noopener\">阮一峰</a></p>\n</blockquote>\n"},{"title":"延时队列的使用","date":"2018-02-02T02:40:03.000Z","_content":"![](http://www.wailian.work/images/2018/02/02/61b7aea823aaba020bbe85f9b2cc4deeae67d58f12106-3PVHe7_fw658.jpg)\n\n# 什么是DelayQueue\n\nDelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。\n\n# 应用场景\n\n## 订单超时关闭\n\n订单业务中总是出现订单未支付过期关闭的情形。最简单的解决方式是定时任务轮询订单，这种方式浪费资源并不优雅。延时队列能够轻松应对这种情形。\n\n### 创建订单类\n\n放入DelayQueue的对象需要实现Delayed接口\n\n```\nclass Order implements Delayed {\n\tpublic static AtomicInteger genId = new AtomicInteger(1);\n\n\tprivate final long delay; // 延迟时间\n\tprivate final long expire; // 到期时间\n\tprivate final long now; // 创建时间\n\n\tprivate Integer id; // 订单ID\n\tprivate Integer state; // 订单状态\n\n\tpublic Integer getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(Integer id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic Integer getState() {\n\t\treturn state;\n\t}\n\n\tpublic void setState(Integer state) {\n\t\tthis.state = state;\n\t}\n\n\tpublic Order(long delay, String msg) {\n\t\tthis.delay = delay;\n\t\texpire = System.currentTimeMillis() + delay; // 到期时间 = 当前时间+延迟时间\n\t\tnow = System.currentTimeMillis();\n\n\t\tthis.state = 0;\n\t}\n\n\t/**\n\t * 需要实现的接口，获得延迟时间 用过期时间-当前时间\n\t *\n\t * @param unit\n\t * @return\n\t */\n\t@Override\n\tpublic long getDelay(TimeUnit unit) {\n\t\treturn unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n\t}\n\n\t/**\n\t * 用于延迟队列内部比较排序 当前时间的延迟时间 - 比较对象的延迟时间\n\t *\n\t * @param o\n\t * @return\n\t */\n\t@Override\n\tpublic int compareTo(Delayed o) {\n\t\treturn (int) (this.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));\n\t}\n}\n```\n\n### 生成订单\n\n```\nprivate static void producer(final DelayQueue<Order> delayQueue) {\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    TimeUnit.MILLISECONDS.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n                Order element = new Order(new Random().nextInt(1000) * 10, \"test\");\n\n                element.setId(Order.genId.getAndIncrement());\n\n                delayQueue.offer(element);\n            }\n        }\n    }).start();\n\n    /**\n     * 每秒打印延迟队列中的对象个数\n     */\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    TimeUnit.MILLISECONDS.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"delayQueue size:\" + delayQueue.size());\n            }\n        }\n    }).start();\n}\n```\n\n### 处理超时订单\n\n```\nprivate static void consumer(final DelayQueue<Order> delayQueue) {\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            while (true) {\n                Order element = null;\n                try {\n                    element = delayQueue.take();\n\n                    if (element.getState().intValue() == 0) {\n                        // 如果现在订单状态还未支付，关闭订单\n                        element.setState(1);\n\n                        System.out.println(\"订单\" + element.getId() + \"超时关闭\");\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }).start();\n}\n```\n\nDelayQueue还是一个阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，此时调用 poll() 将直接返回 null，调用 take() 将会发生阻塞，直到有元素发生到期，take() 才会返回。\n\n### 测试\n\n```\npublic static void main(String[] args) {\n    DelayQueue<Order> delayQueue = new DelayQueue<Order>();\n\n    // 生产者\n    producer(delayQueue);\n\n    // 消费者\n    consumer(delayQueue);\n\n    while (true) {\n        try {\n            TimeUnit.HOURS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n![](http://www.wailian.work/images/2018/02/02/WX20180202-110453.png)\n\n## 多考生考试\n\n1. 考试总时间为10秒，至少2秒后才可进行交卷。\n2. 考生可在2-10秒这段时间内的任意时间交卷。\n3. 考试时间一到，所有未交卷的学生必须交卷。\n\n使用enum定义时间常量\n\n```\nenum Times {\n    SUMMIT_TIME(10), //考试总时间\n    SUMBMIT_LIMIT(2), // 交卷限制时间\n    MAX_RAND_TIME(15); // 模拟考生所需最大时间\n\n    private final int value;\n\n    private Times(int value) {\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n}\n```\n\n### 学生类\n\n```\nclass Student implements Delayed {\n    private String name;\n    private long delay; // 考试花费时间，单位为毫秒\n    private long expire; // 交卷时间，单位为毫秒\n\n    // 此构造可随机生成考试花费时间\n    public Student(String name) {\n        this.name = name;\n        this.delay = TimeUnit.MILLISECONDS.convert(getRandomSeconds(), TimeUnit.SECONDS);\n        this.expire = System.currentTimeMillis() + this.delay;\n    }\n\n    //此构造可指定考试花费时间\n    public Student(String name, long delay, TimeUnit unit) {\n        this.name = name;\n        this.delay = TimeUnit.MILLISECONDS.convert(delay, unit);\n        this.expire = System.currentTimeMillis() + this.delay;\n    }\n\n    // ...\n\n    public int getRandomSeconds() {\n        // 获取随机花费时间，范围：2-10秒\n        return new Random().nextInt(Times.MAX_RAND_TIME.getValue() - Times.SUMBMIT_LIMIT.getValue())\n                    + Times.SUMBMIT_LIMIT.getValue();\n    }\n    \n    @Override\n    public int compareTo(Delayed o) {\n        // 此方法的实现用于定义优先级\n        long td = this.getDelay(TimeUnit.MILLISECONDS);\n        long od = o.getDelay(TimeUnit.MILLISECONDS);\n        return td > od ? 1 : td == od ? 0 : -1;\n    }\n\n    @Override\n    public long getDelay(TimeUnit unit) {\n        // 这里返回的是剩余延时，当延时为0时，此元素延时期满，可从take()取出\n        return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n    }\n}\n```\n\n### 主方法实现\n\n1. 初始化对象\n\n```\nDelayQueue<Student> queue = new DelayQueue<>();\n```\n\n2. 添加测试数据\n\n```\nqueue.add(new Student(\"范冰冰\"));\nqueue.add(new Student(\"成  龙\"));\nqueue.add(new Student(\"李一桐\"));\nqueue.add(new Student(\"宋小宝\"));\nqueue.add(new Student(\"吴  京\"));\nqueue.add(new Student(\"绿巨人\"));\nqueue.add(new Student(\"洪金宝\"));\nqueue.add(new Student(\"李云龙\"));\nqueue.add(new Student(\"钢铁侠\"));\nqueue.add(new Student(\"刘德华\"));\nqueue.add(new Student(\"戴安娜\"));\n```\n\n3. 添加一条用于考试结束时强制交卷的属性\n\n```\nqueue.add(new Student(\"submit\", Times.SUBMIT_TIME.getValue(),TimeUnit.SECONDS));\n```\n\n4. 开始考试\n\n```\nwhile (true) {\n    Student s = queue.take(); // 必要时进行阻塞等待\n    if (s.getName().equals(\"submit\")) {\n        System.out.println(\"时间已到，全部交卷！\");\n        // 利用Java8 Stream特性使尚未交卷学生交卷\n        queue.parallelStream()\n             .filter(v -> v.getExpire() >= s.getExpire())\n             .map(Student::submit)\n             .forEach(System.out::println);\n        System.exit(0);\n    }\n    System.out.println(s);\n}\n```\n\n### 测试结果\n\n![](http://www.wailian.work/images/2018/02/02/WX20180202-115504.png)\n\n### 完整代码\n\n```\npackage cn.gss.juc;\n\nimport java.text.DateFormat;\nimport java.util.Date;\nimport java.util.Random;\nimport java.util.concurrent.DelayQueue;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.TimeUnit;\n\nenum Times {\n    SUBMIT_TIME(10), SUMBMIT_LIMIT(2), MAX_RAND_TIME(15);\n    private final int value;\n\n    private Times(int value) {\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n}\n/**\n * DelayQueue实现多考生考试\n * @author Gss\n */\npublic class TestDelayedQueue {\n\n    public static void main(String[] args) throws InterruptedException {\n        DelayQueue<Student> queue = new DelayQueue<>();\n        queue.add(new Student(\"范冰冰\"));\n        queue.add(new Student(\"成  龙\"));\n        queue.add(new Student(\"李一桐\"));\n        queue.add(new Student(\"宋小宝\"));\n        queue.add(new Student(\"吴  京\"));\n        queue.add(new Student(\"绿巨人\"));\n        queue.add(new Student(\"洪金宝\"));\n        queue.add(new Student(\"李云龙\"));\n        queue.add(new Student(\"钢铁侠\"));\n        queue.add(new Student(\"刘德华\"));\n        queue.add(new Student(\"戴安娜\"));\n        queue.add(new Student(\"submit\", Times.SUBMIT_TIME.getValue(), TimeUnit.SECONDS));\n        while (true) {\n            Student s = queue.take(); // 必要时进行阻塞等待\n            if (s.getName().equals(\"submit\")) {\n                System.out.println(\"时间已到，全部交卷！\");\n                // 利用Java8 Stream使尚未交卷学生交卷\n                queue.parallelStream()\n                     .filter(v -> v.getExpire() >= s.getExpire())\n                     .map(Student::submit)\n                     .forEach(System.out::println);\n                System.exit(0);\n            }\n            System.out.println(s);\n        }\n    }\n\n}\n\nclass Student implements Delayed {\n    private String name;\n    private long delay; // 考试花费时间，单位为毫秒\n    private long expire; // 交卷时间，单位为毫秒\n\n    // 此构造可随机生成考试花费时间\n    public Student(String name) {\n        this.name = name;\n        this.delay = TimeUnit.MILLISECONDS.convert(getRandomSeconds(), TimeUnit.SECONDS); // 随机生成考试花费时间\n        this.expire = System.currentTimeMillis() + this.delay;\n    }\n\n    // 此构造可指定考试花费时间\n    public Student(String name, long delay, TimeUnit unit) {\n        this.name = name;\n        this.delay = TimeUnit.MILLISECONDS.convert(delay, unit);\n        this.expire = System.currentTimeMillis() + this.delay;\n    }\n\n    public int getRandomSeconds() { // 获取随机花费时间\n        return new Random().nextInt(Times.MAX_RAND_TIME.getValue() - Times.SUMBMIT_LIMIT.getValue())\n                + Times.SUMBMIT_LIMIT.getValue();\n    }\n\n    public Student submit() { // 设置花费时间和交卷时间，考试时间结束强制交卷时调用此方法\n        setDelay(Times.SUBMIT_TIME.getValue(), TimeUnit.SECONDS);\n        setExpire(System.currentTimeMillis());\n        return this;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public long getExpire() {\n        return expire;\n    }\n\n    public void setDelay(long delay, TimeUnit unit) {\n        this.delay = TimeUnit.MILLISECONDS.convert(delay, TimeUnit.SECONDS);\n    }\n\n    public void setExpire(long expire) {\n        this.expire = expire;\n    }\n\n    @Override\n    public int compareTo(Delayed o) { // 此方法的实现用于定义优先级\n        long td = this.getDelay(TimeUnit.MILLISECONDS);\n        long od = o.getDelay(TimeUnit.MILLISECONDS);\n        return td > od ? 1 : td == od ? 0 : -1;\n    }\n\n    @Override\n    public long getDelay(TimeUnit unit) { // 这里返回的是剩余延时，当延时为0时，此元素延时期满，可从take()取出\n        return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n    }\n\n    @Override\n    public String toString() {\n        return \"学生姓名：\" + this.name + \",考试用时：\" + TimeUnit.SECONDS.convert(delay, TimeUnit.MILLISECONDS) + \",交卷时间：\"\n                + DateFormat.getDateTimeInstance().format(new Date(this.expire));\n    }\n}\n```\n\n# 源码地址\n\n[GitHub](https://github.com/wangweiye01/DelayQueueTest/tree/master)\n","source":"_posts/delay-queue.md","raw":"---\ntitle: 延时队列的使用\ndate: 2018-02-02 10:40:03\ntags:\n---\n![](http://www.wailian.work/images/2018/02/02/61b7aea823aaba020bbe85f9b2cc4deeae67d58f12106-3PVHe7_fw658.jpg)\n\n# 什么是DelayQueue\n\nDelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。\n\n# 应用场景\n\n## 订单超时关闭\n\n订单业务中总是出现订单未支付过期关闭的情形。最简单的解决方式是定时任务轮询订单，这种方式浪费资源并不优雅。延时队列能够轻松应对这种情形。\n\n### 创建订单类\n\n放入DelayQueue的对象需要实现Delayed接口\n\n```\nclass Order implements Delayed {\n\tpublic static AtomicInteger genId = new AtomicInteger(1);\n\n\tprivate final long delay; // 延迟时间\n\tprivate final long expire; // 到期时间\n\tprivate final long now; // 创建时间\n\n\tprivate Integer id; // 订单ID\n\tprivate Integer state; // 订单状态\n\n\tpublic Integer getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(Integer id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic Integer getState() {\n\t\treturn state;\n\t}\n\n\tpublic void setState(Integer state) {\n\t\tthis.state = state;\n\t}\n\n\tpublic Order(long delay, String msg) {\n\t\tthis.delay = delay;\n\t\texpire = System.currentTimeMillis() + delay; // 到期时间 = 当前时间+延迟时间\n\t\tnow = System.currentTimeMillis();\n\n\t\tthis.state = 0;\n\t}\n\n\t/**\n\t * 需要实现的接口，获得延迟时间 用过期时间-当前时间\n\t *\n\t * @param unit\n\t * @return\n\t */\n\t@Override\n\tpublic long getDelay(TimeUnit unit) {\n\t\treturn unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n\t}\n\n\t/**\n\t * 用于延迟队列内部比较排序 当前时间的延迟时间 - 比较对象的延迟时间\n\t *\n\t * @param o\n\t * @return\n\t */\n\t@Override\n\tpublic int compareTo(Delayed o) {\n\t\treturn (int) (this.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));\n\t}\n}\n```\n\n### 生成订单\n\n```\nprivate static void producer(final DelayQueue<Order> delayQueue) {\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    TimeUnit.MILLISECONDS.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n                Order element = new Order(new Random().nextInt(1000) * 10, \"test\");\n\n                element.setId(Order.genId.getAndIncrement());\n\n                delayQueue.offer(element);\n            }\n        }\n    }).start();\n\n    /**\n     * 每秒打印延迟队列中的对象个数\n     */\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    TimeUnit.MILLISECONDS.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"delayQueue size:\" + delayQueue.size());\n            }\n        }\n    }).start();\n}\n```\n\n### 处理超时订单\n\n```\nprivate static void consumer(final DelayQueue<Order> delayQueue) {\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            while (true) {\n                Order element = null;\n                try {\n                    element = delayQueue.take();\n\n                    if (element.getState().intValue() == 0) {\n                        // 如果现在订单状态还未支付，关闭订单\n                        element.setState(1);\n\n                        System.out.println(\"订单\" + element.getId() + \"超时关闭\");\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }).start();\n}\n```\n\nDelayQueue还是一个阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，此时调用 poll() 将直接返回 null，调用 take() 将会发生阻塞，直到有元素发生到期，take() 才会返回。\n\n### 测试\n\n```\npublic static void main(String[] args) {\n    DelayQueue<Order> delayQueue = new DelayQueue<Order>();\n\n    // 生产者\n    producer(delayQueue);\n\n    // 消费者\n    consumer(delayQueue);\n\n    while (true) {\n        try {\n            TimeUnit.HOURS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n![](http://www.wailian.work/images/2018/02/02/WX20180202-110453.png)\n\n## 多考生考试\n\n1. 考试总时间为10秒，至少2秒后才可进行交卷。\n2. 考生可在2-10秒这段时间内的任意时间交卷。\n3. 考试时间一到，所有未交卷的学生必须交卷。\n\n使用enum定义时间常量\n\n```\nenum Times {\n    SUMMIT_TIME(10), //考试总时间\n    SUMBMIT_LIMIT(2), // 交卷限制时间\n    MAX_RAND_TIME(15); // 模拟考生所需最大时间\n\n    private final int value;\n\n    private Times(int value) {\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n}\n```\n\n### 学生类\n\n```\nclass Student implements Delayed {\n    private String name;\n    private long delay; // 考试花费时间，单位为毫秒\n    private long expire; // 交卷时间，单位为毫秒\n\n    // 此构造可随机生成考试花费时间\n    public Student(String name) {\n        this.name = name;\n        this.delay = TimeUnit.MILLISECONDS.convert(getRandomSeconds(), TimeUnit.SECONDS);\n        this.expire = System.currentTimeMillis() + this.delay;\n    }\n\n    //此构造可指定考试花费时间\n    public Student(String name, long delay, TimeUnit unit) {\n        this.name = name;\n        this.delay = TimeUnit.MILLISECONDS.convert(delay, unit);\n        this.expire = System.currentTimeMillis() + this.delay;\n    }\n\n    // ...\n\n    public int getRandomSeconds() {\n        // 获取随机花费时间，范围：2-10秒\n        return new Random().nextInt(Times.MAX_RAND_TIME.getValue() - Times.SUMBMIT_LIMIT.getValue())\n                    + Times.SUMBMIT_LIMIT.getValue();\n    }\n    \n    @Override\n    public int compareTo(Delayed o) {\n        // 此方法的实现用于定义优先级\n        long td = this.getDelay(TimeUnit.MILLISECONDS);\n        long od = o.getDelay(TimeUnit.MILLISECONDS);\n        return td > od ? 1 : td == od ? 0 : -1;\n    }\n\n    @Override\n    public long getDelay(TimeUnit unit) {\n        // 这里返回的是剩余延时，当延时为0时，此元素延时期满，可从take()取出\n        return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n    }\n}\n```\n\n### 主方法实现\n\n1. 初始化对象\n\n```\nDelayQueue<Student> queue = new DelayQueue<>();\n```\n\n2. 添加测试数据\n\n```\nqueue.add(new Student(\"范冰冰\"));\nqueue.add(new Student(\"成  龙\"));\nqueue.add(new Student(\"李一桐\"));\nqueue.add(new Student(\"宋小宝\"));\nqueue.add(new Student(\"吴  京\"));\nqueue.add(new Student(\"绿巨人\"));\nqueue.add(new Student(\"洪金宝\"));\nqueue.add(new Student(\"李云龙\"));\nqueue.add(new Student(\"钢铁侠\"));\nqueue.add(new Student(\"刘德华\"));\nqueue.add(new Student(\"戴安娜\"));\n```\n\n3. 添加一条用于考试结束时强制交卷的属性\n\n```\nqueue.add(new Student(\"submit\", Times.SUBMIT_TIME.getValue(),TimeUnit.SECONDS));\n```\n\n4. 开始考试\n\n```\nwhile (true) {\n    Student s = queue.take(); // 必要时进行阻塞等待\n    if (s.getName().equals(\"submit\")) {\n        System.out.println(\"时间已到，全部交卷！\");\n        // 利用Java8 Stream特性使尚未交卷学生交卷\n        queue.parallelStream()\n             .filter(v -> v.getExpire() >= s.getExpire())\n             .map(Student::submit)\n             .forEach(System.out::println);\n        System.exit(0);\n    }\n    System.out.println(s);\n}\n```\n\n### 测试结果\n\n![](http://www.wailian.work/images/2018/02/02/WX20180202-115504.png)\n\n### 完整代码\n\n```\npackage cn.gss.juc;\n\nimport java.text.DateFormat;\nimport java.util.Date;\nimport java.util.Random;\nimport java.util.concurrent.DelayQueue;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.TimeUnit;\n\nenum Times {\n    SUBMIT_TIME(10), SUMBMIT_LIMIT(2), MAX_RAND_TIME(15);\n    private final int value;\n\n    private Times(int value) {\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n}\n/**\n * DelayQueue实现多考生考试\n * @author Gss\n */\npublic class TestDelayedQueue {\n\n    public static void main(String[] args) throws InterruptedException {\n        DelayQueue<Student> queue = new DelayQueue<>();\n        queue.add(new Student(\"范冰冰\"));\n        queue.add(new Student(\"成  龙\"));\n        queue.add(new Student(\"李一桐\"));\n        queue.add(new Student(\"宋小宝\"));\n        queue.add(new Student(\"吴  京\"));\n        queue.add(new Student(\"绿巨人\"));\n        queue.add(new Student(\"洪金宝\"));\n        queue.add(new Student(\"李云龙\"));\n        queue.add(new Student(\"钢铁侠\"));\n        queue.add(new Student(\"刘德华\"));\n        queue.add(new Student(\"戴安娜\"));\n        queue.add(new Student(\"submit\", Times.SUBMIT_TIME.getValue(), TimeUnit.SECONDS));\n        while (true) {\n            Student s = queue.take(); // 必要时进行阻塞等待\n            if (s.getName().equals(\"submit\")) {\n                System.out.println(\"时间已到，全部交卷！\");\n                // 利用Java8 Stream使尚未交卷学生交卷\n                queue.parallelStream()\n                     .filter(v -> v.getExpire() >= s.getExpire())\n                     .map(Student::submit)\n                     .forEach(System.out::println);\n                System.exit(0);\n            }\n            System.out.println(s);\n        }\n    }\n\n}\n\nclass Student implements Delayed {\n    private String name;\n    private long delay; // 考试花费时间，单位为毫秒\n    private long expire; // 交卷时间，单位为毫秒\n\n    // 此构造可随机生成考试花费时间\n    public Student(String name) {\n        this.name = name;\n        this.delay = TimeUnit.MILLISECONDS.convert(getRandomSeconds(), TimeUnit.SECONDS); // 随机生成考试花费时间\n        this.expire = System.currentTimeMillis() + this.delay;\n    }\n\n    // 此构造可指定考试花费时间\n    public Student(String name, long delay, TimeUnit unit) {\n        this.name = name;\n        this.delay = TimeUnit.MILLISECONDS.convert(delay, unit);\n        this.expire = System.currentTimeMillis() + this.delay;\n    }\n\n    public int getRandomSeconds() { // 获取随机花费时间\n        return new Random().nextInt(Times.MAX_RAND_TIME.getValue() - Times.SUMBMIT_LIMIT.getValue())\n                + Times.SUMBMIT_LIMIT.getValue();\n    }\n\n    public Student submit() { // 设置花费时间和交卷时间，考试时间结束强制交卷时调用此方法\n        setDelay(Times.SUBMIT_TIME.getValue(), TimeUnit.SECONDS);\n        setExpire(System.currentTimeMillis());\n        return this;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public long getExpire() {\n        return expire;\n    }\n\n    public void setDelay(long delay, TimeUnit unit) {\n        this.delay = TimeUnit.MILLISECONDS.convert(delay, TimeUnit.SECONDS);\n    }\n\n    public void setExpire(long expire) {\n        this.expire = expire;\n    }\n\n    @Override\n    public int compareTo(Delayed o) { // 此方法的实现用于定义优先级\n        long td = this.getDelay(TimeUnit.MILLISECONDS);\n        long od = o.getDelay(TimeUnit.MILLISECONDS);\n        return td > od ? 1 : td == od ? 0 : -1;\n    }\n\n    @Override\n    public long getDelay(TimeUnit unit) { // 这里返回的是剩余延时，当延时为0时，此元素延时期满，可从take()取出\n        return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n    }\n\n    @Override\n    public String toString() {\n        return \"学生姓名：\" + this.name + \",考试用时：\" + TimeUnit.SECONDS.convert(delay, TimeUnit.MILLISECONDS) + \",交卷时间：\"\n                + DateFormat.getDateTimeInstance().format(new Date(this.expire));\n    }\n}\n```\n\n# 源码地址\n\n[GitHub](https://github.com/wangweiye01/DelayQueueTest/tree/master)\n","slug":"delay-queue","published":1,"updated":"2019-12-24T02:00:57.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3k3d00210j9ktzew57wm","content":"<p><img src=\"http://www.wailian.work/images/2018/02/02/61b7aea823aaba020bbe85f9b2cc4deeae67d58f12106-3PVHe7_fw658.jpg\" alt=\"\"></p>\n<h1 id=\"什么是DelayQueue\"><a href=\"#什么是DelayQueue\" class=\"headerlink\" title=\"什么是DelayQueue\"></a>什么是DelayQueue</h1><p>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。</p>\n<h1 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h1><h2 id=\"订单超时关闭\"><a href=\"#订单超时关闭\" class=\"headerlink\" title=\"订单超时关闭\"></a>订单超时关闭</h2><p>订单业务中总是出现订单未支付过期关闭的情形。最简单的解决方式是定时任务轮询订单，这种方式浪费资源并不优雅。延时队列能够轻松应对这种情形。</p>\n<h3 id=\"创建订单类\"><a href=\"#创建订单类\" class=\"headerlink\" title=\"创建订单类\"></a>创建订单类</h3><p>放入DelayQueue的对象需要实现Delayed接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Order implements Delayed &#123;</span><br><span class=\"line\">\tpublic static AtomicInteger genId = new AtomicInteger(1);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate final long delay; // 延迟时间</span><br><span class=\"line\">\tprivate final long expire; // 到期时间</span><br><span class=\"line\">\tprivate final long now; // 创建时间</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate Integer id; // 订单ID</span><br><span class=\"line\">\tprivate Integer state; // 订单状态</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Integer getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(Integer id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Integer getState() &#123;</span><br><span class=\"line\">\t\treturn state;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setState(Integer state) &#123;</span><br><span class=\"line\">\t\tthis.state = state;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Order(long delay, String msg) &#123;</span><br><span class=\"line\">\t\tthis.delay = delay;</span><br><span class=\"line\">\t\texpire = System.currentTimeMillis() + delay; // 到期时间 = 当前时间+延迟时间</span><br><span class=\"line\">\t\tnow = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tthis.state = 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 需要实现的接口，获得延迟时间 用过期时间-当前时间</span><br><span class=\"line\">\t *</span><br><span class=\"line\">\t * @param unit</span><br><span class=\"line\">\t * @return</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic long getDelay(TimeUnit unit) &#123;</span><br><span class=\"line\">\t\treturn unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 用于延迟队列内部比较排序 当前时间的延迟时间 - 比较对象的延迟时间</span><br><span class=\"line\">\t *</span><br><span class=\"line\">\t * @param o</span><br><span class=\"line\">\t * @return</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic int compareTo(Delayed o) &#123;</span><br><span class=\"line\">\t\treturn (int) (this.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成订单\"><a href=\"#生成订单\" class=\"headerlink\" title=\"生成订单\"></a>生成订单</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void producer(final DelayQueue&lt;Order&gt; delayQueue) &#123;</span><br><span class=\"line\">    new Thread(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    TimeUnit.MILLISECONDS.sleep(100);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                Order element = new Order(new Random().nextInt(1000) * 10, &quot;test&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">                element.setId(Order.genId.getAndIncrement());</span><br><span class=\"line\"></span><br><span class=\"line\">                delayQueue.offer(element);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 每秒打印延迟队列中的对象个数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    new Thread(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    TimeUnit.MILLISECONDS.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(&quot;delayQueue size:&quot; + delayQueue.size());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理超时订单\"><a href=\"#处理超时订单\" class=\"headerlink\" title=\"处理超时订单\"></a>处理超时订单</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void consumer(final DelayQueue&lt;Order&gt; delayQueue) &#123;</span><br><span class=\"line\">    new Thread(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                Order element = null;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    element = delayQueue.take();</span><br><span class=\"line\"></span><br><span class=\"line\">                    if (element.getState().intValue() == 0) &#123;</span><br><span class=\"line\">                        // 如果现在订单状态还未支付，关闭订单</span><br><span class=\"line\">                        element.setState(1);</span><br><span class=\"line\"></span><br><span class=\"line\">                        System.out.println(&quot;订单&quot; + element.getId() + &quot;超时关闭&quot;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DelayQueue还是一个阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，此时调用 poll() 将直接返回 null，调用 take() 将会发生阻塞，直到有元素发生到期，take() 才会返回。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    DelayQueue&lt;Order&gt; delayQueue = new DelayQueue&lt;Order&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 生产者</span><br><span class=\"line\">    producer(delayQueue);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 消费者</span><br><span class=\"line\">    consumer(delayQueue);</span><br><span class=\"line\"></span><br><span class=\"line\">    while (true) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            TimeUnit.HOURS.sleep(1);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/02/02/WX20180202-110453.png\" alt=\"\"></p>\n<h2 id=\"多考生考试\"><a href=\"#多考生考试\" class=\"headerlink\" title=\"多考生考试\"></a>多考生考试</h2><ol>\n<li>考试总时间为10秒，至少2秒后才可进行交卷。</li>\n<li>考生可在2-10秒这段时间内的任意时间交卷。</li>\n<li>考试时间一到，所有未交卷的学生必须交卷。</li>\n</ol>\n<p>使用enum定义时间常量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Times &#123;</span><br><span class=\"line\">    SUMMIT_TIME(10), //考试总时间</span><br><span class=\"line\">    SUMBMIT_LIMIT(2), // 交卷限制时间</span><br><span class=\"line\">    MAX_RAND_TIME(15); // 模拟考生所需最大时间</span><br><span class=\"line\"></span><br><span class=\"line\">    private final int value;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Times(int value) &#123;</span><br><span class=\"line\">        this.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getValue() &#123;</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"学生类\"><a href=\"#学生类\" class=\"headerlink\" title=\"学生类\"></a>学生类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student implements Delayed &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private long delay; // 考试花费时间，单位为毫秒</span><br><span class=\"line\">    private long expire; // 交卷时间，单位为毫秒</span><br><span class=\"line\"></span><br><span class=\"line\">    // 此构造可随机生成考试花费时间</span><br><span class=\"line\">    public Student(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.delay = TimeUnit.MILLISECONDS.convert(getRandomSeconds(), TimeUnit.SECONDS);</span><br><span class=\"line\">        this.expire = System.currentTimeMillis() + this.delay;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //此构造可指定考试花费时间</span><br><span class=\"line\">    public Student(String name, long delay, TimeUnit unit) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.delay = TimeUnit.MILLISECONDS.convert(delay, unit);</span><br><span class=\"line\">        this.expire = System.currentTimeMillis() + this.delay;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getRandomSeconds() &#123;</span><br><span class=\"line\">        // 获取随机花费时间，范围：2-10秒</span><br><span class=\"line\">        return new Random().nextInt(Times.MAX_RAND_TIME.getValue() - Times.SUMBMIT_LIMIT.getValue())</span><br><span class=\"line\">                    + Times.SUMBMIT_LIMIT.getValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int compareTo(Delayed o) &#123;</span><br><span class=\"line\">        // 此方法的实现用于定义优先级</span><br><span class=\"line\">        long td = this.getDelay(TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        long od = o.getDelay(TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        return td &gt; od ? 1 : td == od ? 0 : -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public long getDelay(TimeUnit unit) &#123;</span><br><span class=\"line\">        // 这里返回的是剩余延时，当延时为0时，此元素延时期满，可从take()取出</span><br><span class=\"line\">        return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"主方法实现\"><a href=\"#主方法实现\" class=\"headerlink\" title=\"主方法实现\"></a>主方法实现</h3><ol>\n<li>初始化对象</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DelayQueue&lt;Student&gt; queue = new DelayQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<ol>\n<li>添加测试数据</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue.add(new Student(&quot;范冰冰&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;成  龙&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;李一桐&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;宋小宝&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;吴  京&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;绿巨人&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;洪金宝&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;李云龙&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;钢铁侠&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;刘德华&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;戴安娜&quot;));</span><br></pre></td></tr></table></figure>\n<ol>\n<li>添加一条用于考试结束时强制交卷的属性</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue.add(new Student(&quot;submit&quot;, Times.SUBMIT_TIME.getValue(),TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure>\n<ol>\n<li>开始考试</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while (true) &#123;</span><br><span class=\"line\">    Student s = queue.take(); // 必要时进行阻塞等待</span><br><span class=\"line\">    if (s.getName().equals(&quot;submit&quot;)) &#123;</span><br><span class=\"line\">        System.out.println(&quot;时间已到，全部交卷！&quot;);</span><br><span class=\"line\">        // 利用Java8 Stream特性使尚未交卷学生交卷</span><br><span class=\"line\">        queue.parallelStream()</span><br><span class=\"line\">             .filter(v -&gt; v.getExpire() &gt;= s.getExpire())</span><br><span class=\"line\">             .map(Student::submit)</span><br><span class=\"line\">             .forEach(System.out::println);</span><br><span class=\"line\">        System.exit(0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h3><p><img src=\"http://www.wailian.work/images/2018/02/02/WX20180202-115504.png\" alt=\"\"></p>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.gss.juc;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.text.DateFormat;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.Random;</span><br><span class=\"line\">import java.util.concurrent.DelayQueue;</span><br><span class=\"line\">import java.util.concurrent.Delayed;</span><br><span class=\"line\">import java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\">enum Times &#123;</span><br><span class=\"line\">    SUBMIT_TIME(10), SUMBMIT_LIMIT(2), MAX_RAND_TIME(15);</span><br><span class=\"line\">    private final int value;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Times(int value) &#123;</span><br><span class=\"line\">        this.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getValue() &#123;</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * DelayQueue实现多考生考试</span><br><span class=\"line\"> * @author Gss</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class TestDelayedQueue &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        DelayQueue&lt;Student&gt; queue = new DelayQueue&lt;&gt;();</span><br><span class=\"line\">        queue.add(new Student(&quot;范冰冰&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;成  龙&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;李一桐&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;宋小宝&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;吴  京&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;绿巨人&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;洪金宝&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;李云龙&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;钢铁侠&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;刘德华&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;戴安娜&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;submit&quot;, Times.SUBMIT_TIME.getValue(), TimeUnit.SECONDS));</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            Student s = queue.take(); // 必要时进行阻塞等待</span><br><span class=\"line\">            if (s.getName().equals(&quot;submit&quot;)) &#123;</span><br><span class=\"line\">                System.out.println(&quot;时间已到，全部交卷！&quot;);</span><br><span class=\"line\">                // 利用Java8 Stream使尚未交卷学生交卷</span><br><span class=\"line\">                queue.parallelStream()</span><br><span class=\"line\">                     .filter(v -&gt; v.getExpire() &gt;= s.getExpire())</span><br><span class=\"line\">                     .map(Student::submit)</span><br><span class=\"line\">                     .forEach(System.out::println);</span><br><span class=\"line\">                System.exit(0);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Student implements Delayed &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private long delay; // 考试花费时间，单位为毫秒</span><br><span class=\"line\">    private long expire; // 交卷时间，单位为毫秒</span><br><span class=\"line\"></span><br><span class=\"line\">    // 此构造可随机生成考试花费时间</span><br><span class=\"line\">    public Student(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.delay = TimeUnit.MILLISECONDS.convert(getRandomSeconds(), TimeUnit.SECONDS); // 随机生成考试花费时间</span><br><span class=\"line\">        this.expire = System.currentTimeMillis() + this.delay;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 此构造可指定考试花费时间</span><br><span class=\"line\">    public Student(String name, long delay, TimeUnit unit) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.delay = TimeUnit.MILLISECONDS.convert(delay, unit);</span><br><span class=\"line\">        this.expire = System.currentTimeMillis() + this.delay;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getRandomSeconds() &#123; // 获取随机花费时间</span><br><span class=\"line\">        return new Random().nextInt(Times.MAX_RAND_TIME.getValue() - Times.SUMBMIT_LIMIT.getValue())</span><br><span class=\"line\">                + Times.SUMBMIT_LIMIT.getValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Student submit() &#123; // 设置花费时间和交卷时间，考试时间结束强制交卷时调用此方法</span><br><span class=\"line\">        setDelay(Times.SUBMIT_TIME.getValue(), TimeUnit.SECONDS);</span><br><span class=\"line\">        setExpire(System.currentTimeMillis());</span><br><span class=\"line\">        return this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public long getExpire() &#123;</span><br><span class=\"line\">        return expire;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setDelay(long delay, TimeUnit unit) &#123;</span><br><span class=\"line\">        this.delay = TimeUnit.MILLISECONDS.convert(delay, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setExpire(long expire) &#123;</span><br><span class=\"line\">        this.expire = expire;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int compareTo(Delayed o) &#123; // 此方法的实现用于定义优先级</span><br><span class=\"line\">        long td = this.getDelay(TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        long od = o.getDelay(TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        return td &gt; od ? 1 : td == od ? 0 : -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public long getDelay(TimeUnit unit) &#123; // 这里返回的是剩余延时，当延时为0时，此元素延时期满，可从take()取出</span><br><span class=\"line\">        return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;学生姓名：&quot; + this.name + &quot;,考试用时：&quot; + TimeUnit.SECONDS.convert(delay, TimeUnit.MILLISECONDS) + &quot;,交卷时间：&quot;</span><br><span class=\"line\">                + DateFormat.getDateTimeInstance().format(new Date(this.expire));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a>源码地址</h1><p><a href=\"https://github.com/wangweiye01/DelayQueueTest/tree/master\" target=\"_blank\" rel=\"noopener\">GitHub</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/02/02/61b7aea823aaba020bbe85f9b2cc4deeae67d58f12106-3PVHe7_fw658.jpg\" alt=\"\"></p>\n<h1 id=\"什么是DelayQueue\"><a href=\"#什么是DelayQueue\" class=\"headerlink\" title=\"什么是DelayQueue\"></a>什么是DelayQueue</h1><p>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。</p>\n<h1 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h1><h2 id=\"订单超时关闭\"><a href=\"#订单超时关闭\" class=\"headerlink\" title=\"订单超时关闭\"></a>订单超时关闭</h2><p>订单业务中总是出现订单未支付过期关闭的情形。最简单的解决方式是定时任务轮询订单，这种方式浪费资源并不优雅。延时队列能够轻松应对这种情形。</p>\n<h3 id=\"创建订单类\"><a href=\"#创建订单类\" class=\"headerlink\" title=\"创建订单类\"></a>创建订单类</h3><p>放入DelayQueue的对象需要实现Delayed接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Order implements Delayed &#123;</span><br><span class=\"line\">\tpublic static AtomicInteger genId = new AtomicInteger(1);</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate final long delay; // 延迟时间</span><br><span class=\"line\">\tprivate final long expire; // 到期时间</span><br><span class=\"line\">\tprivate final long now; // 创建时间</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate Integer id; // 订单ID</span><br><span class=\"line\">\tprivate Integer state; // 订单状态</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Integer getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(Integer id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Integer getState() &#123;</span><br><span class=\"line\">\t\treturn state;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setState(Integer state) &#123;</span><br><span class=\"line\">\t\tthis.state = state;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Order(long delay, String msg) &#123;</span><br><span class=\"line\">\t\tthis.delay = delay;</span><br><span class=\"line\">\t\texpire = System.currentTimeMillis() + delay; // 到期时间 = 当前时间+延迟时间</span><br><span class=\"line\">\t\tnow = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tthis.state = 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 需要实现的接口，获得延迟时间 用过期时间-当前时间</span><br><span class=\"line\">\t *</span><br><span class=\"line\">\t * @param unit</span><br><span class=\"line\">\t * @return</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic long getDelay(TimeUnit unit) &#123;</span><br><span class=\"line\">\t\treturn unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 用于延迟队列内部比较排序 当前时间的延迟时间 - 比较对象的延迟时间</span><br><span class=\"line\">\t *</span><br><span class=\"line\">\t * @param o</span><br><span class=\"line\">\t * @return</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic int compareTo(Delayed o) &#123;</span><br><span class=\"line\">\t\treturn (int) (this.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成订单\"><a href=\"#生成订单\" class=\"headerlink\" title=\"生成订单\"></a>生成订单</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void producer(final DelayQueue&lt;Order&gt; delayQueue) &#123;</span><br><span class=\"line\">    new Thread(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    TimeUnit.MILLISECONDS.sleep(100);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                Order element = new Order(new Random().nextInt(1000) * 10, &quot;test&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">                element.setId(Order.genId.getAndIncrement());</span><br><span class=\"line\"></span><br><span class=\"line\">                delayQueue.offer(element);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 每秒打印延迟队列中的对象个数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    new Thread(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    TimeUnit.MILLISECONDS.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(&quot;delayQueue size:&quot; + delayQueue.size());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理超时订单\"><a href=\"#处理超时订单\" class=\"headerlink\" title=\"处理超时订单\"></a>处理超时订单</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void consumer(final DelayQueue&lt;Order&gt; delayQueue) &#123;</span><br><span class=\"line\">    new Thread(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                Order element = null;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    element = delayQueue.take();</span><br><span class=\"line\"></span><br><span class=\"line\">                    if (element.getState().intValue() == 0) &#123;</span><br><span class=\"line\">                        // 如果现在订单状态还未支付，关闭订单</span><br><span class=\"line\">                        element.setState(1);</span><br><span class=\"line\"></span><br><span class=\"line\">                        System.out.println(&quot;订单&quot; + element.getId() + &quot;超时关闭&quot;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DelayQueue还是一个阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，此时调用 poll() 将直接返回 null，调用 take() 将会发生阻塞，直到有元素发生到期，take() 才会返回。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    DelayQueue&lt;Order&gt; delayQueue = new DelayQueue&lt;Order&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 生产者</span><br><span class=\"line\">    producer(delayQueue);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 消费者</span><br><span class=\"line\">    consumer(delayQueue);</span><br><span class=\"line\"></span><br><span class=\"line\">    while (true) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            TimeUnit.HOURS.sleep(1);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/02/02/WX20180202-110453.png\" alt=\"\"></p>\n<h2 id=\"多考生考试\"><a href=\"#多考生考试\" class=\"headerlink\" title=\"多考生考试\"></a>多考生考试</h2><ol>\n<li>考试总时间为10秒，至少2秒后才可进行交卷。</li>\n<li>考生可在2-10秒这段时间内的任意时间交卷。</li>\n<li>考试时间一到，所有未交卷的学生必须交卷。</li>\n</ol>\n<p>使用enum定义时间常量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Times &#123;</span><br><span class=\"line\">    SUMMIT_TIME(10), //考试总时间</span><br><span class=\"line\">    SUMBMIT_LIMIT(2), // 交卷限制时间</span><br><span class=\"line\">    MAX_RAND_TIME(15); // 模拟考生所需最大时间</span><br><span class=\"line\"></span><br><span class=\"line\">    private final int value;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Times(int value) &#123;</span><br><span class=\"line\">        this.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getValue() &#123;</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"学生类\"><a href=\"#学生类\" class=\"headerlink\" title=\"学生类\"></a>学生类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student implements Delayed &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private long delay; // 考试花费时间，单位为毫秒</span><br><span class=\"line\">    private long expire; // 交卷时间，单位为毫秒</span><br><span class=\"line\"></span><br><span class=\"line\">    // 此构造可随机生成考试花费时间</span><br><span class=\"line\">    public Student(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.delay = TimeUnit.MILLISECONDS.convert(getRandomSeconds(), TimeUnit.SECONDS);</span><br><span class=\"line\">        this.expire = System.currentTimeMillis() + this.delay;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //此构造可指定考试花费时间</span><br><span class=\"line\">    public Student(String name, long delay, TimeUnit unit) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.delay = TimeUnit.MILLISECONDS.convert(delay, unit);</span><br><span class=\"line\">        this.expire = System.currentTimeMillis() + this.delay;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getRandomSeconds() &#123;</span><br><span class=\"line\">        // 获取随机花费时间，范围：2-10秒</span><br><span class=\"line\">        return new Random().nextInt(Times.MAX_RAND_TIME.getValue() - Times.SUMBMIT_LIMIT.getValue())</span><br><span class=\"line\">                    + Times.SUMBMIT_LIMIT.getValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int compareTo(Delayed o) &#123;</span><br><span class=\"line\">        // 此方法的实现用于定义优先级</span><br><span class=\"line\">        long td = this.getDelay(TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        long od = o.getDelay(TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        return td &gt; od ? 1 : td == od ? 0 : -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public long getDelay(TimeUnit unit) &#123;</span><br><span class=\"line\">        // 这里返回的是剩余延时，当延时为0时，此元素延时期满，可从take()取出</span><br><span class=\"line\">        return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"主方法实现\"><a href=\"#主方法实现\" class=\"headerlink\" title=\"主方法实现\"></a>主方法实现</h3><ol>\n<li>初始化对象</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DelayQueue&lt;Student&gt; queue = new DelayQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<ol>\n<li>添加测试数据</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue.add(new Student(&quot;范冰冰&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;成  龙&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;李一桐&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;宋小宝&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;吴  京&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;绿巨人&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;洪金宝&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;李云龙&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;钢铁侠&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;刘德华&quot;));</span><br><span class=\"line\">queue.add(new Student(&quot;戴安娜&quot;));</span><br></pre></td></tr></table></figure>\n<ol>\n<li>添加一条用于考试结束时强制交卷的属性</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue.add(new Student(&quot;submit&quot;, Times.SUBMIT_TIME.getValue(),TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure>\n<ol>\n<li>开始考试</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while (true) &#123;</span><br><span class=\"line\">    Student s = queue.take(); // 必要时进行阻塞等待</span><br><span class=\"line\">    if (s.getName().equals(&quot;submit&quot;)) &#123;</span><br><span class=\"line\">        System.out.println(&quot;时间已到，全部交卷！&quot;);</span><br><span class=\"line\">        // 利用Java8 Stream特性使尚未交卷学生交卷</span><br><span class=\"line\">        queue.parallelStream()</span><br><span class=\"line\">             .filter(v -&gt; v.getExpire() &gt;= s.getExpire())</span><br><span class=\"line\">             .map(Student::submit)</span><br><span class=\"line\">             .forEach(System.out::println);</span><br><span class=\"line\">        System.exit(0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h3><p><img src=\"http://www.wailian.work/images/2018/02/02/WX20180202-115504.png\" alt=\"\"></p>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.gss.juc;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.text.DateFormat;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.Random;</span><br><span class=\"line\">import java.util.concurrent.DelayQueue;</span><br><span class=\"line\">import java.util.concurrent.Delayed;</span><br><span class=\"line\">import java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\">enum Times &#123;</span><br><span class=\"line\">    SUBMIT_TIME(10), SUMBMIT_LIMIT(2), MAX_RAND_TIME(15);</span><br><span class=\"line\">    private final int value;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Times(int value) &#123;</span><br><span class=\"line\">        this.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getValue() &#123;</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * DelayQueue实现多考生考试</span><br><span class=\"line\"> * @author Gss</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class TestDelayedQueue &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        DelayQueue&lt;Student&gt; queue = new DelayQueue&lt;&gt;();</span><br><span class=\"line\">        queue.add(new Student(&quot;范冰冰&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;成  龙&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;李一桐&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;宋小宝&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;吴  京&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;绿巨人&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;洪金宝&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;李云龙&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;钢铁侠&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;刘德华&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;戴安娜&quot;));</span><br><span class=\"line\">        queue.add(new Student(&quot;submit&quot;, Times.SUBMIT_TIME.getValue(), TimeUnit.SECONDS));</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            Student s = queue.take(); // 必要时进行阻塞等待</span><br><span class=\"line\">            if (s.getName().equals(&quot;submit&quot;)) &#123;</span><br><span class=\"line\">                System.out.println(&quot;时间已到，全部交卷！&quot;);</span><br><span class=\"line\">                // 利用Java8 Stream使尚未交卷学生交卷</span><br><span class=\"line\">                queue.parallelStream()</span><br><span class=\"line\">                     .filter(v -&gt; v.getExpire() &gt;= s.getExpire())</span><br><span class=\"line\">                     .map(Student::submit)</span><br><span class=\"line\">                     .forEach(System.out::println);</span><br><span class=\"line\">                System.exit(0);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Student implements Delayed &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private long delay; // 考试花费时间，单位为毫秒</span><br><span class=\"line\">    private long expire; // 交卷时间，单位为毫秒</span><br><span class=\"line\"></span><br><span class=\"line\">    // 此构造可随机生成考试花费时间</span><br><span class=\"line\">    public Student(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.delay = TimeUnit.MILLISECONDS.convert(getRandomSeconds(), TimeUnit.SECONDS); // 随机生成考试花费时间</span><br><span class=\"line\">        this.expire = System.currentTimeMillis() + this.delay;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 此构造可指定考试花费时间</span><br><span class=\"line\">    public Student(String name, long delay, TimeUnit unit) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.delay = TimeUnit.MILLISECONDS.convert(delay, unit);</span><br><span class=\"line\">        this.expire = System.currentTimeMillis() + this.delay;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getRandomSeconds() &#123; // 获取随机花费时间</span><br><span class=\"line\">        return new Random().nextInt(Times.MAX_RAND_TIME.getValue() - Times.SUMBMIT_LIMIT.getValue())</span><br><span class=\"line\">                + Times.SUMBMIT_LIMIT.getValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Student submit() &#123; // 设置花费时间和交卷时间，考试时间结束强制交卷时调用此方法</span><br><span class=\"line\">        setDelay(Times.SUBMIT_TIME.getValue(), TimeUnit.SECONDS);</span><br><span class=\"line\">        setExpire(System.currentTimeMillis());</span><br><span class=\"line\">        return this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public long getExpire() &#123;</span><br><span class=\"line\">        return expire;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setDelay(long delay, TimeUnit unit) &#123;</span><br><span class=\"line\">        this.delay = TimeUnit.MILLISECONDS.convert(delay, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setExpire(long expire) &#123;</span><br><span class=\"line\">        this.expire = expire;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int compareTo(Delayed o) &#123; // 此方法的实现用于定义优先级</span><br><span class=\"line\">        long td = this.getDelay(TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        long od = o.getDelay(TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        return td &gt; od ? 1 : td == od ? 0 : -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public long getDelay(TimeUnit unit) &#123; // 这里返回的是剩余延时，当延时为0时，此元素延时期满，可从take()取出</span><br><span class=\"line\">        return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;学生姓名：&quot; + this.name + &quot;,考试用时：&quot; + TimeUnit.SECONDS.convert(delay, TimeUnit.MILLISECONDS) + &quot;,交卷时间：&quot;</span><br><span class=\"line\">                + DateFormat.getDateTimeInstance().format(new Date(this.expire));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a>源码地址</h1><p><a href=\"https://github.com/wangweiye01/DelayQueueTest/tree/master\" target=\"_blank\" rel=\"noopener\">GitHub</a></p>\n"},{"title":"设计模式-观察者模式","date":"2018-06-08T07:27:38.000Z","top":111,"_content":"\n# 定义\n\n观察者模式（有时又被称为发布-订阅模式、模型-视图模式、源-收听者模式或从属者模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。\n\n上面的定义当中，主要有这样几个意思，首先是有一个目标的物件，通俗点讲就是一个类，它管理了所有依赖于它的观察者物件，或者通俗点说是观察者类，并在它自己状态发生变化时，主动发出通知。\n\n简单点概括成通俗的话来说，就是一个类管理着所有依赖于它的观察者类，并且它状态变化时会主动给这些依赖它的类发出通知。\n\n# 应用\n\n通常意义上如果一个对象状态的改变需要通知很多对这个对象关注的一系列对象，就可以使用观察者模式。\n\n# 类图\n\n![](http://www.wailian.work/images/2018/06/08/20130626145005968.jpg)\n\n可以看到，我们的被观察者类Observable只关联了一个Observer的列表，然后在自己状态变化时，使用notifyObservers方法通知这些Observer，具体这些Observer都是什么，被观察者是不关心也不需要知道的。\n\n上面就将观察者和被观察者二者的耦合度降到很低了，而我们具体的观察者是必须要知道自己观察的是谁，所以它依赖于被观察者。\n\n# 实现\n\n实现一个简单的观察者模式，使用JAVA简单诠释一下上面的类图\n\n观察者接口:\n\n```\n // 这个接口时为了提供一个统一的观察者做出相应行为的方法\npublic interface Observer {\n    void update(Observable o);\n}\n```\n\n具体观察者（观察者接口的实现）\n\n```\npublic class ConcreteObserver1 implements Observer {\n    @Override\n    public void update(Observable o) {\n        System.out.println(\"观察者1观察到\" + o.getClass().getSimpleName() + \"发生变化\");\n        System.out.println(\"观察者1做出相应变化\");\n    }\n}\n```\n\n```\npublic class ConcreteObserver2 implements Observer {\n    @Override\n    public void update(Observable o) {\n        System.out.println(\"观察者2观察到\" + o.getClass().getSimpleName() + \"发生变化\");\n        System.out.println(\"观察者2做出相应变化\");\n    }\n}\n```\n\n下面是被观察者，它有一个观察者的列表，并且有一个通知所有观察者的方法，通知的方式就是调用观察者通用的接口行为update方法\n\n```\npublic class Observable {\n    List<Observer> observers = new ArrayList<>();\n\n    public void addObserver(Observer o) {\n        observers.add(o);\n    }\n\n    public void changed() {\n        System.out.println(\"==我是被观察者，我发生了变化==\");\n\n        // 通知观察我的所有观察者\n        notifyObservers();\n    }\n\n    public void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(this);\n        }\n    }\n}\n```\n\n这里面很简单，新增两个方法，一个是为了改变自己的同时通知观察者们，一个是为了给客户端一个添加观察者的公共接口\n\n下面测试一下\n\n```\npublic void testObserver() {\n    Observable observable = new Observable();\n    observable.addObserver(new ConcreteObserver1());\n    observable.addObserver(new ConcreteObserver2());\n\n    observable.changed();\n}\n```\n\n运行结果如下\n\n![](http://www.wailian.work/images/2018/06/08/WX20180608-154314.png)\n\n可以看到我们在操作被观察者时，只要调用changed方法，观察者们就会做出相应的动作，而添加观察者这个行为算是准备阶段，将具体的观察者关联到被观察者上面去\n\n下面给出一个有实际意义的例子，比如我们经常看的小说网站，都有这样的功能，就是读者可以订阅作者，这当中就有明显的观察者模式案例，就是作者和读者。他们的关系是一旦读者关注了一个作者，那么这个作者一旦有什么新书，就都要通知读者们，这明显是一个观察者模式的案例，所以我们可以使用观察者模式解决。\n\n读者类，要实现观察者接口\n\n```\nimport java.util.Observable;\nimport java.util.Observer;\n\npublic class Reader implements Observer {\n    private String name;\n\n    public Reader(String name) {\n        super();\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    // 当关注的作者发布新小说时，会通知读者去看\n    @Override\n        public void update(Observable o, Object arg) {\n            if (o instanceof Writer) {\n                Writer writer = (Writer) o;\n                System.out.println(name + \"知道\" + writer.getName() + \"发布了新书《\" + writer.getLastNovel() + \"》非要去看\");\n            }\n        }\n\n    //读者可以关注某一位作者，关注则代表把自己加到作者的观察者列表里\n    public void subscribe(String writerName) {\n        WriterManager.getInstance().getWriter(writerName).addObserver(this);\n    }\n\n    //读者可以取消关注某一位作者，取消关注则代表把自己从作者的观察者列表里删除\n    public void unsubscribe(String writerName) {\n        WriterManager.getInstance().getWriter(writerName).deleteObserver(this);\n    }\n}\n```\n\n作者类\n\n```\nimport java.util.Observable;\n\npublic class Writer extends Observable {\n    private String name; // 作者名称\n\n    private String lastNovel; //作者最新发布的小说\n\n    public String getName() {\n        return this.name;\n    }\n\n    public Writer(String name) {\n        super();\n        this.name = name;\n        WriterManager.getInstance().add(this);\n    }\n\n    // 作者发布新小说，要通知所有关注自己的读者\n    public void addNovel(String novel) {\n        System.out.println(name + \"发布了新书《\" + novel + \"》\");\n\n        lastNovel = novel;\n\n        setChanged();\n\n        notifyObservers();\n    }\n\n    public String getLastNovel() {\n        return this.lastNovel;\n    }\n}\n```\n\n然后我们还需要一个管理器帮我们管理这些作者\n\n```\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class WriterManager {\n    private static WriterManager writerManager;\n\n    private Map<String, Writer> writerMap = new HashMap<>();\n\n    // 添加作者\n    public void add(Writer writer) {\n        writerMap.put(writer.getName(), writer);\n    }\n\n    // 根据作者名获得作者\n    public Writer getWriter(String name) {\n        return writerMap.get(name);\n    }\n\n    // 单例模式(私有构造函数)\n    private WriterManager() {\n\n    }\n\n    public static WriterManager getInstance() {\n        if (writerManager == null) {\n            synchronized (WriterManager.class) {\n                if (writerManager == null) {\n                    writerManager = new WriterManager();\n                }\n            }\n        }\n\n        return writerManager;\n    }\n}\n```\n\n 好了，这下我们的观察者模式就做好了，这个简单的DEMO可以支持读者关注作者，当作者发布新书时，读者会观察到这个事情，会产生相应的动作。下面我们写个测试用例测试一下\n\n ```\n public void testJdkObserver() {\n     //假设四个读者，两个作者\n     Reader r1 = new Reader(\"谢广坤\");\n     Reader r2 = new Reader(\"赵四\");\n     Reader r3 = new Reader(\"七哥\");\n     Reader r4 = new Reader(\"刘能\");\n     Writer w1 = new Writer(\"谢大脚\");\n     Writer w2 = new Writer(\"王小蒙\");\n     //四人关注了谢大脚\n     r1.subscribe(\"谢大脚\");\n     r2.subscribe(\"谢大脚\");\n     r3.subscribe(\"谢大脚\");\n     r4.subscribe(\"谢大脚\");\n     //七哥和刘能还关注了王小蒙\n     r3.subscribe(\"王小蒙\");\n     r4.subscribe(\"王小蒙\");\n\n     //作者发布新书就会通知关注的读者\n     //谢大脚写了设计模式\n     w1.addNovel(\"设计模式\");\n     //王小蒙写了JAVA编程思想\n     w2.addNovel(\"JAVA编程思想\");\n     //谢广坤取消关注谢大脚\n     r1.unsubscribe(\"谢大脚\");\n     //谢大脚再写书将不会通知谢广坤\n     w1.addNovel(\"观察者模式\");\n }\n ```\n\n ![](http://www.wailian.work/images/2018/06/08/121313.png)\n\n我们使用观察者模式的用意是为了作者不再需要关心他发布新书时都要去通知谁，更重要的是他不需要关心他通知的是读者还是其它什么人，他只知道这个人是实现了观察者接口的，即我们的被观察者依赖的只是一个抽象的接口观察者接口，而不关心具体的观察者都有谁都是什么，比如以后要是游客也可以关注作者了，那么只要游客类实现观察者接口，那么一样可以将游客列入到作者的观察者列表中\n\n另外，我们让读者自己来选择自己关注的对象，这相当于被观察者将维护通知对象的职能转化给了观察者，这样做的好处是由于一个被观察者可能有N多观察者，所以让被观察者自己维护这个列表会很艰难，这就像一个老师被许多学生认识，那么是所有的学生都记住老师的名字简单，还是让老师记住N多学生的名字简单？答案显而易见，让学生们都记住一个老师的名字是最简单的\n\n观察者模式分离了观察者和被观察者二者的责任，这样让类之间各自维护自己的功能，专注于自己的功能，会提高系统的可维护性和可重用性\n\n***\n\n作者：zuoxiaolong（左潇龙）\n\n出处：博客园左潇龙的技术博客--http://www.cnblogs.com/zuoxiaolong\n\n您的支持是对博主最大的鼓励，感谢您的认真阅读。\n\n本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。\n","source":"_posts/observer.md","raw":"---\ntitle: 设计模式-观察者模式\ndate: 2018-06-08 15:27:38\ntags:\ntop: 111\ncategories: 设计模式\n---\n\n# 定义\n\n观察者模式（有时又被称为发布-订阅模式、模型-视图模式、源-收听者模式或从属者模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。\n\n上面的定义当中，主要有这样几个意思，首先是有一个目标的物件，通俗点讲就是一个类，它管理了所有依赖于它的观察者物件，或者通俗点说是观察者类，并在它自己状态发生变化时，主动发出通知。\n\n简单点概括成通俗的话来说，就是一个类管理着所有依赖于它的观察者类，并且它状态变化时会主动给这些依赖它的类发出通知。\n\n# 应用\n\n通常意义上如果一个对象状态的改变需要通知很多对这个对象关注的一系列对象，就可以使用观察者模式。\n\n# 类图\n\n![](http://www.wailian.work/images/2018/06/08/20130626145005968.jpg)\n\n可以看到，我们的被观察者类Observable只关联了一个Observer的列表，然后在自己状态变化时，使用notifyObservers方法通知这些Observer，具体这些Observer都是什么，被观察者是不关心也不需要知道的。\n\n上面就将观察者和被观察者二者的耦合度降到很低了，而我们具体的观察者是必须要知道自己观察的是谁，所以它依赖于被观察者。\n\n# 实现\n\n实现一个简单的观察者模式，使用JAVA简单诠释一下上面的类图\n\n观察者接口:\n\n```\n // 这个接口时为了提供一个统一的观察者做出相应行为的方法\npublic interface Observer {\n    void update(Observable o);\n}\n```\n\n具体观察者（观察者接口的实现）\n\n```\npublic class ConcreteObserver1 implements Observer {\n    @Override\n    public void update(Observable o) {\n        System.out.println(\"观察者1观察到\" + o.getClass().getSimpleName() + \"发生变化\");\n        System.out.println(\"观察者1做出相应变化\");\n    }\n}\n```\n\n```\npublic class ConcreteObserver2 implements Observer {\n    @Override\n    public void update(Observable o) {\n        System.out.println(\"观察者2观察到\" + o.getClass().getSimpleName() + \"发生变化\");\n        System.out.println(\"观察者2做出相应变化\");\n    }\n}\n```\n\n下面是被观察者，它有一个观察者的列表，并且有一个通知所有观察者的方法，通知的方式就是调用观察者通用的接口行为update方法\n\n```\npublic class Observable {\n    List<Observer> observers = new ArrayList<>();\n\n    public void addObserver(Observer o) {\n        observers.add(o);\n    }\n\n    public void changed() {\n        System.out.println(\"==我是被观察者，我发生了变化==\");\n\n        // 通知观察我的所有观察者\n        notifyObservers();\n    }\n\n    public void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(this);\n        }\n    }\n}\n```\n\n这里面很简单，新增两个方法，一个是为了改变自己的同时通知观察者们，一个是为了给客户端一个添加观察者的公共接口\n\n下面测试一下\n\n```\npublic void testObserver() {\n    Observable observable = new Observable();\n    observable.addObserver(new ConcreteObserver1());\n    observable.addObserver(new ConcreteObserver2());\n\n    observable.changed();\n}\n```\n\n运行结果如下\n\n![](http://www.wailian.work/images/2018/06/08/WX20180608-154314.png)\n\n可以看到我们在操作被观察者时，只要调用changed方法，观察者们就会做出相应的动作，而添加观察者这个行为算是准备阶段，将具体的观察者关联到被观察者上面去\n\n下面给出一个有实际意义的例子，比如我们经常看的小说网站，都有这样的功能，就是读者可以订阅作者，这当中就有明显的观察者模式案例，就是作者和读者。他们的关系是一旦读者关注了一个作者，那么这个作者一旦有什么新书，就都要通知读者们，这明显是一个观察者模式的案例，所以我们可以使用观察者模式解决。\n\n读者类，要实现观察者接口\n\n```\nimport java.util.Observable;\nimport java.util.Observer;\n\npublic class Reader implements Observer {\n    private String name;\n\n    public Reader(String name) {\n        super();\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    // 当关注的作者发布新小说时，会通知读者去看\n    @Override\n        public void update(Observable o, Object arg) {\n            if (o instanceof Writer) {\n                Writer writer = (Writer) o;\n                System.out.println(name + \"知道\" + writer.getName() + \"发布了新书《\" + writer.getLastNovel() + \"》非要去看\");\n            }\n        }\n\n    //读者可以关注某一位作者，关注则代表把自己加到作者的观察者列表里\n    public void subscribe(String writerName) {\n        WriterManager.getInstance().getWriter(writerName).addObserver(this);\n    }\n\n    //读者可以取消关注某一位作者，取消关注则代表把自己从作者的观察者列表里删除\n    public void unsubscribe(String writerName) {\n        WriterManager.getInstance().getWriter(writerName).deleteObserver(this);\n    }\n}\n```\n\n作者类\n\n```\nimport java.util.Observable;\n\npublic class Writer extends Observable {\n    private String name; // 作者名称\n\n    private String lastNovel; //作者最新发布的小说\n\n    public String getName() {\n        return this.name;\n    }\n\n    public Writer(String name) {\n        super();\n        this.name = name;\n        WriterManager.getInstance().add(this);\n    }\n\n    // 作者发布新小说，要通知所有关注自己的读者\n    public void addNovel(String novel) {\n        System.out.println(name + \"发布了新书《\" + novel + \"》\");\n\n        lastNovel = novel;\n\n        setChanged();\n\n        notifyObservers();\n    }\n\n    public String getLastNovel() {\n        return this.lastNovel;\n    }\n}\n```\n\n然后我们还需要一个管理器帮我们管理这些作者\n\n```\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class WriterManager {\n    private static WriterManager writerManager;\n\n    private Map<String, Writer> writerMap = new HashMap<>();\n\n    // 添加作者\n    public void add(Writer writer) {\n        writerMap.put(writer.getName(), writer);\n    }\n\n    // 根据作者名获得作者\n    public Writer getWriter(String name) {\n        return writerMap.get(name);\n    }\n\n    // 单例模式(私有构造函数)\n    private WriterManager() {\n\n    }\n\n    public static WriterManager getInstance() {\n        if (writerManager == null) {\n            synchronized (WriterManager.class) {\n                if (writerManager == null) {\n                    writerManager = new WriterManager();\n                }\n            }\n        }\n\n        return writerManager;\n    }\n}\n```\n\n 好了，这下我们的观察者模式就做好了，这个简单的DEMO可以支持读者关注作者，当作者发布新书时，读者会观察到这个事情，会产生相应的动作。下面我们写个测试用例测试一下\n\n ```\n public void testJdkObserver() {\n     //假设四个读者，两个作者\n     Reader r1 = new Reader(\"谢广坤\");\n     Reader r2 = new Reader(\"赵四\");\n     Reader r3 = new Reader(\"七哥\");\n     Reader r4 = new Reader(\"刘能\");\n     Writer w1 = new Writer(\"谢大脚\");\n     Writer w2 = new Writer(\"王小蒙\");\n     //四人关注了谢大脚\n     r1.subscribe(\"谢大脚\");\n     r2.subscribe(\"谢大脚\");\n     r3.subscribe(\"谢大脚\");\n     r4.subscribe(\"谢大脚\");\n     //七哥和刘能还关注了王小蒙\n     r3.subscribe(\"王小蒙\");\n     r4.subscribe(\"王小蒙\");\n\n     //作者发布新书就会通知关注的读者\n     //谢大脚写了设计模式\n     w1.addNovel(\"设计模式\");\n     //王小蒙写了JAVA编程思想\n     w2.addNovel(\"JAVA编程思想\");\n     //谢广坤取消关注谢大脚\n     r1.unsubscribe(\"谢大脚\");\n     //谢大脚再写书将不会通知谢广坤\n     w1.addNovel(\"观察者模式\");\n }\n ```\n\n ![](http://www.wailian.work/images/2018/06/08/121313.png)\n\n我们使用观察者模式的用意是为了作者不再需要关心他发布新书时都要去通知谁，更重要的是他不需要关心他通知的是读者还是其它什么人，他只知道这个人是实现了观察者接口的，即我们的被观察者依赖的只是一个抽象的接口观察者接口，而不关心具体的观察者都有谁都是什么，比如以后要是游客也可以关注作者了，那么只要游客类实现观察者接口，那么一样可以将游客列入到作者的观察者列表中\n\n另外，我们让读者自己来选择自己关注的对象，这相当于被观察者将维护通知对象的职能转化给了观察者，这样做的好处是由于一个被观察者可能有N多观察者，所以让被观察者自己维护这个列表会很艰难，这就像一个老师被许多学生认识，那么是所有的学生都记住老师的名字简单，还是让老师记住N多学生的名字简单？答案显而易见，让学生们都记住一个老师的名字是最简单的\n\n观察者模式分离了观察者和被观察者二者的责任，这样让类之间各自维护自己的功能，专注于自己的功能，会提高系统的可维护性和可重用性\n\n***\n\n作者：zuoxiaolong（左潇龙）\n\n出处：博客园左潇龙的技术博客--http://www.cnblogs.com/zuoxiaolong\n\n您的支持是对博主最大的鼓励，感谢您的认真阅读。\n\n本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。\n","slug":"observer","published":1,"updated":"2019-12-24T02:00:57.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3k3f00220j9knsz833iq","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>观察者模式（有时又被称为发布-订阅模式、模型-视图模式、源-收听者模式或从属者模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。</p>\n<p>上面的定义当中，主要有这样几个意思，首先是有一个目标的物件，通俗点讲就是一个类，它管理了所有依赖于它的观察者物件，或者通俗点说是观察者类，并在它自己状态发生变化时，主动发出通知。</p>\n<p>简单点概括成通俗的话来说，就是一个类管理着所有依赖于它的观察者类，并且它状态变化时会主动给这些依赖它的类发出通知。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p>通常意义上如果一个对象状态的改变需要通知很多对这个对象关注的一系列对象，就可以使用观察者模式。</p>\n<h1 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h1><p><img src=\"http://www.wailian.work/images/2018/06/08/20130626145005968.jpg\" alt=\"\"></p>\n<p>可以看到，我们的被观察者类Observable只关联了一个Observer的列表，然后在自己状态变化时，使用notifyObservers方法通知这些Observer，具体这些Observer都是什么，被观察者是不关心也不需要知道的。</p>\n<p>上面就将观察者和被观察者二者的耦合度降到很低了，而我们具体的观察者是必须要知道自己观察的是谁，所以它依赖于被观察者。</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p>实现一个简单的观察者模式，使用JAVA简单诠释一下上面的类图</p>\n<p>观察者接口:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // 这个接口时为了提供一个统一的观察者做出相应行为的方法</span><br><span class=\"line\">public interface Observer &#123;</span><br><span class=\"line\">    void update(Observable o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体观察者（观察者接口的实现）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ConcreteObserver1 implements Observer &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void update(Observable o) &#123;</span><br><span class=\"line\">        System.out.println(&quot;观察者1观察到&quot; + o.getClass().getSimpleName() + &quot;发生变化&quot;);</span><br><span class=\"line\">        System.out.println(&quot;观察者1做出相应变化&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ConcreteObserver2 implements Observer &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void update(Observable o) &#123;</span><br><span class=\"line\">        System.out.println(&quot;观察者2观察到&quot; + o.getClass().getSimpleName() + &quot;发生变化&quot;);</span><br><span class=\"line\">        System.out.println(&quot;观察者2做出相应变化&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是被观察者，它有一个观察者的列表，并且有一个通知所有观察者的方法，通知的方式就是调用观察者通用的接口行为update方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Observable &#123;</span><br><span class=\"line\">    List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public void addObserver(Observer o) &#123;</span><br><span class=\"line\">        observers.add(o);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void changed() &#123;</span><br><span class=\"line\">        System.out.println(&quot;==我是被观察者，我发生了变化==&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 通知观察我的所有观察者</span><br><span class=\"line\">        notifyObservers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void notifyObservers() &#123;</span><br><span class=\"line\">        for (Observer observer : observers) &#123;</span><br><span class=\"line\">            observer.update(this);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里面很简单，新增两个方法，一个是为了改变自己的同时通知观察者们，一个是为了给客户端一个添加观察者的公共接口</p>\n<p>下面测试一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void testObserver() &#123;</span><br><span class=\"line\">    Observable observable = new Observable();</span><br><span class=\"line\">    observable.addObserver(new ConcreteObserver1());</span><br><span class=\"line\">    observable.addObserver(new ConcreteObserver2());</span><br><span class=\"line\"></span><br><span class=\"line\">    observable.changed();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果如下</p>\n<p><img src=\"http://www.wailian.work/images/2018/06/08/WX20180608-154314.png\" alt=\"\"></p>\n<p>可以看到我们在操作被观察者时，只要调用changed方法，观察者们就会做出相应的动作，而添加观察者这个行为算是准备阶段，将具体的观察者关联到被观察者上面去</p>\n<p>下面给出一个有实际意义的例子，比如我们经常看的小说网站，都有这样的功能，就是读者可以订阅作者，这当中就有明显的观察者模式案例，就是作者和读者。他们的关系是一旦读者关注了一个作者，那么这个作者一旦有什么新书，就都要通知读者们，这明显是一个观察者模式的案例，所以我们可以使用观察者模式解决。</p>\n<p>读者类，要实现观察者接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Observable;</span><br><span class=\"line\">import java.util.Observer;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Reader implements Observer &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Reader(String name) &#123;</span><br><span class=\"line\">        super();</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 当关注的作者发布新小说时，会通知读者去看</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">        public void update(Observable o, Object arg) &#123;</span><br><span class=\"line\">            if (o instanceof Writer) &#123;</span><br><span class=\"line\">                Writer writer = (Writer) o;</span><br><span class=\"line\">                System.out.println(name + &quot;知道&quot; + writer.getName() + &quot;发布了新书《&quot; + writer.getLastNovel() + &quot;》非要去看&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //读者可以关注某一位作者，关注则代表把自己加到作者的观察者列表里</span><br><span class=\"line\">    public void subscribe(String writerName) &#123;</span><br><span class=\"line\">        WriterManager.getInstance().getWriter(writerName).addObserver(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //读者可以取消关注某一位作者，取消关注则代表把自己从作者的观察者列表里删除</span><br><span class=\"line\">    public void unsubscribe(String writerName) &#123;</span><br><span class=\"line\">        WriterManager.getInstance().getWriter(writerName).deleteObserver(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>作者类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Observable;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Writer extends Observable &#123;</span><br><span class=\"line\">    private String name; // 作者名称</span><br><span class=\"line\"></span><br><span class=\"line\">    private String lastNovel; //作者最新发布的小说</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return this.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Writer(String name) &#123;</span><br><span class=\"line\">        super();</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        WriterManager.getInstance().add(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 作者发布新小说，要通知所有关注自己的读者</span><br><span class=\"line\">    public void addNovel(String novel) &#123;</span><br><span class=\"line\">        System.out.println(name + &quot;发布了新书《&quot; + novel + &quot;》&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        lastNovel = novel;</span><br><span class=\"line\"></span><br><span class=\"line\">        setChanged();</span><br><span class=\"line\"></span><br><span class=\"line\">        notifyObservers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getLastNovel() &#123;</span><br><span class=\"line\">        return this.lastNovel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们还需要一个管理器帮我们管理这些作者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">public class WriterManager &#123;</span><br><span class=\"line\">    private static WriterManager writerManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Map&lt;String, Writer&gt; writerMap = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 添加作者</span><br><span class=\"line\">    public void add(Writer writer) &#123;</span><br><span class=\"line\">        writerMap.put(writer.getName(), writer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 根据作者名获得作者</span><br><span class=\"line\">    public Writer getWriter(String name) &#123;</span><br><span class=\"line\">        return writerMap.get(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 单例模式(私有构造函数)</span><br><span class=\"line\">    private WriterManager() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static WriterManager getInstance() &#123;</span><br><span class=\"line\">        if (writerManager == null) &#123;</span><br><span class=\"line\">            synchronized (WriterManager.class) &#123;</span><br><span class=\"line\">                if (writerManager == null) &#123;</span><br><span class=\"line\">                    writerManager = new WriterManager();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return writerManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 好了，这下我们的观察者模式就做好了，这个简单的DEMO可以支持读者关注作者，当作者发布新书时，读者会观察到这个事情，会产生相应的动作。下面我们写个测试用例测试一下</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void testJdkObserver() &#123;</span><br><span class=\"line\">    //假设四个读者，两个作者</span><br><span class=\"line\">    Reader r1 = new Reader(&quot;谢广坤&quot;);</span><br><span class=\"line\">    Reader r2 = new Reader(&quot;赵四&quot;);</span><br><span class=\"line\">    Reader r3 = new Reader(&quot;七哥&quot;);</span><br><span class=\"line\">    Reader r4 = new Reader(&quot;刘能&quot;);</span><br><span class=\"line\">    Writer w1 = new Writer(&quot;谢大脚&quot;);</span><br><span class=\"line\">    Writer w2 = new Writer(&quot;王小蒙&quot;);</span><br><span class=\"line\">    //四人关注了谢大脚</span><br><span class=\"line\">    r1.subscribe(&quot;谢大脚&quot;);</span><br><span class=\"line\">    r2.subscribe(&quot;谢大脚&quot;);</span><br><span class=\"line\">    r3.subscribe(&quot;谢大脚&quot;);</span><br><span class=\"line\">    r4.subscribe(&quot;谢大脚&quot;);</span><br><span class=\"line\">    //七哥和刘能还关注了王小蒙</span><br><span class=\"line\">    r3.subscribe(&quot;王小蒙&quot;);</span><br><span class=\"line\">    r4.subscribe(&quot;王小蒙&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //作者发布新书就会通知关注的读者</span><br><span class=\"line\">    //谢大脚写了设计模式</span><br><span class=\"line\">    w1.addNovel(&quot;设计模式&quot;);</span><br><span class=\"line\">    //王小蒙写了JAVA编程思想</span><br><span class=\"line\">    w2.addNovel(&quot;JAVA编程思想&quot;);</span><br><span class=\"line\">    //谢广坤取消关注谢大脚</span><br><span class=\"line\">    r1.unsubscribe(&quot;谢大脚&quot;);</span><br><span class=\"line\">    //谢大脚再写书将不会通知谢广坤</span><br><span class=\"line\">    w1.addNovel(&quot;观察者模式&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> <img src=\"http://www.wailian.work/images/2018/06/08/121313.png\" alt=\"\"></p>\n<p>我们使用观察者模式的用意是为了作者不再需要关心他发布新书时都要去通知谁，更重要的是他不需要关心他通知的是读者还是其它什么人，他只知道这个人是实现了观察者接口的，即我们的被观察者依赖的只是一个抽象的接口观察者接口，而不关心具体的观察者都有谁都是什么，比如以后要是游客也可以关注作者了，那么只要游客类实现观察者接口，那么一样可以将游客列入到作者的观察者列表中</p>\n<p>另外，我们让读者自己来选择自己关注的对象，这相当于被观察者将维护通知对象的职能转化给了观察者，这样做的好处是由于一个被观察者可能有N多观察者，所以让被观察者自己维护这个列表会很艰难，这就像一个老师被许多学生认识，那么是所有的学生都记住老师的名字简单，还是让老师记住N多学生的名字简单？答案显而易见，让学生们都记住一个老师的名字是最简单的</p>\n<p>观察者模式分离了观察者和被观察者二者的责任，这样让类之间各自维护自己的功能，专注于自己的功能，会提高系统的可维护性和可重用性</p>\n<hr>\n<p>作者：zuoxiaolong（左潇龙）</p>\n<p>出处：博客园左潇龙的技术博客–<a href=\"http://www.cnblogs.com/zuoxiaolong\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/zuoxiaolong</a></p>\n<p>您的支持是对博主最大的鼓励，感谢您的认真阅读。</p>\n<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>观察者模式（有时又被称为发布-订阅模式、模型-视图模式、源-收听者模式或从属者模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。</p>\n<p>上面的定义当中，主要有这样几个意思，首先是有一个目标的物件，通俗点讲就是一个类，它管理了所有依赖于它的观察者物件，或者通俗点说是观察者类，并在它自己状态发生变化时，主动发出通知。</p>\n<p>简单点概括成通俗的话来说，就是一个类管理着所有依赖于它的观察者类，并且它状态变化时会主动给这些依赖它的类发出通知。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p>通常意义上如果一个对象状态的改变需要通知很多对这个对象关注的一系列对象，就可以使用观察者模式。</p>\n<h1 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h1><p><img src=\"http://www.wailian.work/images/2018/06/08/20130626145005968.jpg\" alt=\"\"></p>\n<p>可以看到，我们的被观察者类Observable只关联了一个Observer的列表，然后在自己状态变化时，使用notifyObservers方法通知这些Observer，具体这些Observer都是什么，被观察者是不关心也不需要知道的。</p>\n<p>上面就将观察者和被观察者二者的耦合度降到很低了，而我们具体的观察者是必须要知道自己观察的是谁，所以它依赖于被观察者。</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p>实现一个简单的观察者模式，使用JAVA简单诠释一下上面的类图</p>\n<p>观察者接口:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // 这个接口时为了提供一个统一的观察者做出相应行为的方法</span><br><span class=\"line\">public interface Observer &#123;</span><br><span class=\"line\">    void update(Observable o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体观察者（观察者接口的实现）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ConcreteObserver1 implements Observer &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void update(Observable o) &#123;</span><br><span class=\"line\">        System.out.println(&quot;观察者1观察到&quot; + o.getClass().getSimpleName() + &quot;发生变化&quot;);</span><br><span class=\"line\">        System.out.println(&quot;观察者1做出相应变化&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ConcreteObserver2 implements Observer &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void update(Observable o) &#123;</span><br><span class=\"line\">        System.out.println(&quot;观察者2观察到&quot; + o.getClass().getSimpleName() + &quot;发生变化&quot;);</span><br><span class=\"line\">        System.out.println(&quot;观察者2做出相应变化&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是被观察者，它有一个观察者的列表，并且有一个通知所有观察者的方法，通知的方式就是调用观察者通用的接口行为update方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Observable &#123;</span><br><span class=\"line\">    List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public void addObserver(Observer o) &#123;</span><br><span class=\"line\">        observers.add(o);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void changed() &#123;</span><br><span class=\"line\">        System.out.println(&quot;==我是被观察者，我发生了变化==&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 通知观察我的所有观察者</span><br><span class=\"line\">        notifyObservers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void notifyObservers() &#123;</span><br><span class=\"line\">        for (Observer observer : observers) &#123;</span><br><span class=\"line\">            observer.update(this);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里面很简单，新增两个方法，一个是为了改变自己的同时通知观察者们，一个是为了给客户端一个添加观察者的公共接口</p>\n<p>下面测试一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void testObserver() &#123;</span><br><span class=\"line\">    Observable observable = new Observable();</span><br><span class=\"line\">    observable.addObserver(new ConcreteObserver1());</span><br><span class=\"line\">    observable.addObserver(new ConcreteObserver2());</span><br><span class=\"line\"></span><br><span class=\"line\">    observable.changed();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果如下</p>\n<p><img src=\"http://www.wailian.work/images/2018/06/08/WX20180608-154314.png\" alt=\"\"></p>\n<p>可以看到我们在操作被观察者时，只要调用changed方法，观察者们就会做出相应的动作，而添加观察者这个行为算是准备阶段，将具体的观察者关联到被观察者上面去</p>\n<p>下面给出一个有实际意义的例子，比如我们经常看的小说网站，都有这样的功能，就是读者可以订阅作者，这当中就有明显的观察者模式案例，就是作者和读者。他们的关系是一旦读者关注了一个作者，那么这个作者一旦有什么新书，就都要通知读者们，这明显是一个观察者模式的案例，所以我们可以使用观察者模式解决。</p>\n<p>读者类，要实现观察者接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Observable;</span><br><span class=\"line\">import java.util.Observer;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Reader implements Observer &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Reader(String name) &#123;</span><br><span class=\"line\">        super();</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 当关注的作者发布新小说时，会通知读者去看</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">        public void update(Observable o, Object arg) &#123;</span><br><span class=\"line\">            if (o instanceof Writer) &#123;</span><br><span class=\"line\">                Writer writer = (Writer) o;</span><br><span class=\"line\">                System.out.println(name + &quot;知道&quot; + writer.getName() + &quot;发布了新书《&quot; + writer.getLastNovel() + &quot;》非要去看&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //读者可以关注某一位作者，关注则代表把自己加到作者的观察者列表里</span><br><span class=\"line\">    public void subscribe(String writerName) &#123;</span><br><span class=\"line\">        WriterManager.getInstance().getWriter(writerName).addObserver(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //读者可以取消关注某一位作者，取消关注则代表把自己从作者的观察者列表里删除</span><br><span class=\"line\">    public void unsubscribe(String writerName) &#123;</span><br><span class=\"line\">        WriterManager.getInstance().getWriter(writerName).deleteObserver(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>作者类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Observable;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Writer extends Observable &#123;</span><br><span class=\"line\">    private String name; // 作者名称</span><br><span class=\"line\"></span><br><span class=\"line\">    private String lastNovel; //作者最新发布的小说</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return this.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Writer(String name) &#123;</span><br><span class=\"line\">        super();</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        WriterManager.getInstance().add(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 作者发布新小说，要通知所有关注自己的读者</span><br><span class=\"line\">    public void addNovel(String novel) &#123;</span><br><span class=\"line\">        System.out.println(name + &quot;发布了新书《&quot; + novel + &quot;》&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        lastNovel = novel;</span><br><span class=\"line\"></span><br><span class=\"line\">        setChanged();</span><br><span class=\"line\"></span><br><span class=\"line\">        notifyObservers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getLastNovel() &#123;</span><br><span class=\"line\">        return this.lastNovel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们还需要一个管理器帮我们管理这些作者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">public class WriterManager &#123;</span><br><span class=\"line\">    private static WriterManager writerManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Map&lt;String, Writer&gt; writerMap = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 添加作者</span><br><span class=\"line\">    public void add(Writer writer) &#123;</span><br><span class=\"line\">        writerMap.put(writer.getName(), writer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 根据作者名获得作者</span><br><span class=\"line\">    public Writer getWriter(String name) &#123;</span><br><span class=\"line\">        return writerMap.get(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 单例模式(私有构造函数)</span><br><span class=\"line\">    private WriterManager() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static WriterManager getInstance() &#123;</span><br><span class=\"line\">        if (writerManager == null) &#123;</span><br><span class=\"line\">            synchronized (WriterManager.class) &#123;</span><br><span class=\"line\">                if (writerManager == null) &#123;</span><br><span class=\"line\">                    writerManager = new WriterManager();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return writerManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 好了，这下我们的观察者模式就做好了，这个简单的DEMO可以支持读者关注作者，当作者发布新书时，读者会观察到这个事情，会产生相应的动作。下面我们写个测试用例测试一下</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void testJdkObserver() &#123;</span><br><span class=\"line\">    //假设四个读者，两个作者</span><br><span class=\"line\">    Reader r1 = new Reader(&quot;谢广坤&quot;);</span><br><span class=\"line\">    Reader r2 = new Reader(&quot;赵四&quot;);</span><br><span class=\"line\">    Reader r3 = new Reader(&quot;七哥&quot;);</span><br><span class=\"line\">    Reader r4 = new Reader(&quot;刘能&quot;);</span><br><span class=\"line\">    Writer w1 = new Writer(&quot;谢大脚&quot;);</span><br><span class=\"line\">    Writer w2 = new Writer(&quot;王小蒙&quot;);</span><br><span class=\"line\">    //四人关注了谢大脚</span><br><span class=\"line\">    r1.subscribe(&quot;谢大脚&quot;);</span><br><span class=\"line\">    r2.subscribe(&quot;谢大脚&quot;);</span><br><span class=\"line\">    r3.subscribe(&quot;谢大脚&quot;);</span><br><span class=\"line\">    r4.subscribe(&quot;谢大脚&quot;);</span><br><span class=\"line\">    //七哥和刘能还关注了王小蒙</span><br><span class=\"line\">    r3.subscribe(&quot;王小蒙&quot;);</span><br><span class=\"line\">    r4.subscribe(&quot;王小蒙&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //作者发布新书就会通知关注的读者</span><br><span class=\"line\">    //谢大脚写了设计模式</span><br><span class=\"line\">    w1.addNovel(&quot;设计模式&quot;);</span><br><span class=\"line\">    //王小蒙写了JAVA编程思想</span><br><span class=\"line\">    w2.addNovel(&quot;JAVA编程思想&quot;);</span><br><span class=\"line\">    //谢广坤取消关注谢大脚</span><br><span class=\"line\">    r1.unsubscribe(&quot;谢大脚&quot;);</span><br><span class=\"line\">    //谢大脚再写书将不会通知谢广坤</span><br><span class=\"line\">    w1.addNovel(&quot;观察者模式&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> <img src=\"http://www.wailian.work/images/2018/06/08/121313.png\" alt=\"\"></p>\n<p>我们使用观察者模式的用意是为了作者不再需要关心他发布新书时都要去通知谁，更重要的是他不需要关心他通知的是读者还是其它什么人，他只知道这个人是实现了观察者接口的，即我们的被观察者依赖的只是一个抽象的接口观察者接口，而不关心具体的观察者都有谁都是什么，比如以后要是游客也可以关注作者了，那么只要游客类实现观察者接口，那么一样可以将游客列入到作者的观察者列表中</p>\n<p>另外，我们让读者自己来选择自己关注的对象，这相当于被观察者将维护通知对象的职能转化给了观察者，这样做的好处是由于一个被观察者可能有N多观察者，所以让被观察者自己维护这个列表会很艰难，这就像一个老师被许多学生认识，那么是所有的学生都记住老师的名字简单，还是让老师记住N多学生的名字简单？答案显而易见，让学生们都记住一个老师的名字是最简单的</p>\n<p>观察者模式分离了观察者和被观察者二者的责任，这样让类之间各自维护自己的功能，专注于自己的功能，会提高系统的可维护性和可重用性</p>\n<hr>\n<p>作者：zuoxiaolong（左潇龙）</p>\n<p>出处：博客园左潇龙的技术博客–<a href=\"http://www.cnblogs.com/zuoxiaolong\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/zuoxiaolong</a></p>\n<p>您的支持是对博主最大的鼓励，感谢您的认真阅读。</p>\n<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>\n"},{"title":"socket实现服务端客户端通讯","date":"2017-12-03T05:00:29.000Z","_content":"# server服务端\n\n## 主线程\n\n### 构建页面\n### 创建serverSocket\n### 添加send按钮的点击事件\n\n## 子线程\n\n### 死循环接收消息\n\n## 服务端代码如下:\n\n```\n/**\n * 主线程发送消息\n * 子线程接收消息\n */\npackage com.yatai.web;\n\nimport java.awt.BorderLayout;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTextArea;\nimport javax.swing.JTextField;\n\n/**\n * @author 王伟业 2014年5月28日\n */\npublic class ChatServer implements ActionListener, Runnable {\n    // 用来存放客户端连接数量\n    public static ArrayList<Socket> socketList = new ArrayList<Socket>();\n    // 显示历史聊天记录\n    private JTextArea showArea;\n    // 待发送的字符区域\n    private JTextField msgText;\n    // 窗口\n    private JFrame mainJframe;\n    // 发送按钮\n    private JButton sentBtn;\n    // 滚动面板\n    private JScrollPane JSPane;\n    // 普通面板\n    private JPanel pane;\n    // 最大的容器\n    private Container con;\n    // 线程处理信息\n    private Thread thread = null;\n    private ServerSocket serverSocket;\n    private Socket connectToClient;\n    private DataInputStream inFromClient;\n    private DataOutputStream outToClient;\n\n    /**\n     * 构造函数用来设置界面，处理事件\n     */\n    public ChatServer() {\n        // TODO Auto-generated constructor stub\n        // 设置页面\n        mainJframe = new JFrame(\"服务器端\");\n        // 初始化容器\n        con = mainJframe.getContentPane();\n        showArea = new JTextArea();\n        showArea.setEditable(false); // 历史聊天窗口中的文字域不能编辑，只供查看\n        showArea.setLineWrap(true); // 自动换行\n        JSPane = new JScrollPane(showArea);\n        // 待发送文字区域\n        msgText = new JTextField();\n        msgText.setColumns(35);\n        // 事件监听\n        msgText.addActionListener(this);\n        sentBtn = new JButton(\"Send\");\n        sentBtn.addActionListener(this);\n        // 界面下部\n        pane = new JPanel();\n        pane.setLayout(new FlowLayout());\n        pane.add(msgText);\n        pane.add(sentBtn);\n\n        con.add(JSPane, BorderLayout.CENTER);\n        con.add(pane, BorderLayout.SOUTH);\n        mainJframe.setSize(500, 400);\n        mainJframe.setLocation(600, 200);\n        mainJframe.setVisible(true);\n        mainJframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        try {\n            serverSocket = new ServerSocket(8888);\n            showArea.append(\"  正在等待对话请求\\n\");\n            // 监听端口\n            connectToClient = serverSocket.accept();\n            inFromClient = new DataInputStream(connectToClient.getInputStream());\n            outToClient = new DataOutputStream(connectToClient.getOutputStream());\n            // 启动线程\n            thread = new Thread(this);\n            thread.setPriority(Thread.MIN_PRIORITY);\n            thread.start();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            // 出现此异常说明服务器未创建成功\n            showArea.append(\"  对不起，不能创建服务器\\n\");\n            // 待发送文字区域不能编辑\n            msgText.setEditable(false);\n            // 发送按钮不可用\n            sentBtn.setEnabled(false);\n        }\n\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see java.lang.Runnable#run()\n     */\n    @Override\n        public void run() {\n            // TODO Auto-generated method stub\n            // 此线程用来接收客户端传来的信息\n            while (true) {\n                try {\n                    showArea.append(\"  对方说：\" + inFromClient.readUTF() + \"\\n\");\n                    Thread.sleep(1000);\n                } catch (IOException | InterruptedException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n\n        }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see\n     * java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)\n     */\n    @Override\n        public void actionPerformed(ActionEvent e) {\n            // TODO Auto-generated method stub\n            // 响应按钮事件\n            String s = msgText.getText();\n            // 如果待发送文字区域存在文字\n            if (s.length() > 0) {\n                try {\n                    // 将文字写入到流中\n                    outToClient.writeUTF(s);\n                    outToClient.flush();\n                    // 历史聊天记录增添内容\n                    showArea.append(\"  我说：\" + msgText.getText() + \"\\n\");\n                    // 待发送文字区域设为空\n                    msgText.setText(null);\n                } catch (IOException e1) {\n                    // TODO Auto-generated catch block\n                    // 出现此异常说明消息未发送成功\n                    showArea.append(\"  你的消息：\" + \"“\" + msgText.getText() + \"”\" + \"未能发送成功\\n\");\n                }\n            }\n        }\n\n    public static void main(String[] args) {\n        // 主线程用来发送消息\n        new ChatServer();\n    }\n\n}\n```\n\n# client客户端\n\n## 主线程\n\n### 构建页面\n### 连接serverSocket\n### 添加send按钮的监听事件\n\n## 子线程\n\n### 死循环接收消息\n\n### 客户端代码如下：\n```\n/**\n * \n */\npackage com.yatai.web;\n\nimport java.awt.BorderLayout;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTextArea;\nimport javax.swing.JTextField;\n\n/**\n * @author 王伟业 2014年5月28日\n */\npublic class ChatClient implements ActionListener, Runnable {\n    // 相同的界面形式\n    private JTextArea showArea;\n    private JTextField msgText;\n    private JFrame mainJframe;\n    private JButton sentBtn;\n    private JScrollPane JSPane;\n    private JPanel pane;\n    private Container con;\n    // 相似的处理方法\n    private Thread thread = null;\n    private Socket connectToServer;\n    private DataInputStream inFromServer;\n    private DataOutputStream outToServer;\n\n    /**\n     * \n     */\n    public ChatClient() {\n        // TODO Auto-generated constructor stub\n        // 构造函数下完成以下内容\n        mainJframe = new JFrame(\"客户端\");\n        con = mainJframe.getContentPane();\n        showArea = new JTextArea();\n        showArea.setEditable(false);\n        showArea.setLineWrap(true);\n        showArea.setWrapStyleWord(true);\n        JSPane = new JScrollPane(showArea);\n        msgText = new JTextField();\n        msgText.setColumns(35);\n        msgText.addActionListener(this);\n        sentBtn = new JButton(\"Send\");\n        sentBtn.addActionListener(this);\n        pane = new JPanel();\n        pane.setLayout(new FlowLayout());\n        pane.add(msgText);\n        pane.add(sentBtn);\n        con.add(JSPane, BorderLayout.CENTER);\n        con.add(pane, BorderLayout.SOUTH);\n        mainJframe.setSize(500, 400);\n        mainJframe.setLocation(80, 200);\n        mainJframe.setVisible(true);\n        mainJframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        try {\n            connectToServer = new Socket(\"localhost\", 8888);\n            inFromServer = new DataInputStream(connectToServer.getInputStream());\n            outToServer = new DataOutputStream(connectToServer.getOutputStream());\n            showArea.append(\"  连接成功，可以通信\\n\");\n\n            // 创建线程\n            thread = new Thread(this);\n            thread.setPriority(Thread.MIN_PRIORITY);\n            thread.start();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            // 出现异常说明连接失败\n            // 向历史聊天区域打印提示信息\n            showArea.append(\"  对不起，连接服务器失败\\n\");\n            // 异常连接时输入框不可用\n            msgText.setEditable(false);\n            msgText.setEnabled(false);\n        }\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see java.lang.Runnable#run()\n     */\n    @Override\n        public void run() {\n            // TODO Auto-generated method stub\n            // 该线程用来接收传来的消息\n            while (true) {\n                try {\n                    showArea.append(\"  对方说：\" + inFromServer.readUTF() + \"\\n\");\n                    Thread.sleep(1000);\n                } catch (IOException | InterruptedException e) {\n                    // TODO Auto-generated catch block\n                    // 此处异常处理。。。。\n                    e.printStackTrace();\n                }\n            }\n        }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see\n     * java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)\n     */\n    @Override\n        public void actionPerformed(ActionEvent e) {\n            // TODO Auto-generated method stub\n            // 响应事件\n            String s = msgText.getText();\n            // 如果待发送文字区域存在文字\n            if (s.length() > 0) {\n                try {\n                    // 将文字写入到流中\n                    outToServer.writeUTF(s);\n                    outToServer.flush();\n                    // 历史聊天记录增添内容\n                    showArea.append(\"  我说：\" + msgText.getText() + \"\\n\");\n                    // 待发送文字区域设为空\n                    msgText.setText(null);\n                } catch (IOException e1) {\n                    // TODO Auto-generated catch block\n                    // 出现此异常说明消息未发送成功\n                    showArea.append(\"  你的消息：\" + \"“\" + msgText.getText() + \"”\" + \"未能发送成功\\n\");\n                }\n            }\n        }\n\n    public static void main(String[] args) {\n        new ChatClient();\n    }\n}\n```\n","source":"_posts/socket.md","raw":"---\ntitle: socket实现服务端客户端通讯\ndate: 2017-12-03 13:00:29\ntags:\n---\n# server服务端\n\n## 主线程\n\n### 构建页面\n### 创建serverSocket\n### 添加send按钮的点击事件\n\n## 子线程\n\n### 死循环接收消息\n\n## 服务端代码如下:\n\n```\n/**\n * 主线程发送消息\n * 子线程接收消息\n */\npackage com.yatai.web;\n\nimport java.awt.BorderLayout;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTextArea;\nimport javax.swing.JTextField;\n\n/**\n * @author 王伟业 2014年5月28日\n */\npublic class ChatServer implements ActionListener, Runnable {\n    // 用来存放客户端连接数量\n    public static ArrayList<Socket> socketList = new ArrayList<Socket>();\n    // 显示历史聊天记录\n    private JTextArea showArea;\n    // 待发送的字符区域\n    private JTextField msgText;\n    // 窗口\n    private JFrame mainJframe;\n    // 发送按钮\n    private JButton sentBtn;\n    // 滚动面板\n    private JScrollPane JSPane;\n    // 普通面板\n    private JPanel pane;\n    // 最大的容器\n    private Container con;\n    // 线程处理信息\n    private Thread thread = null;\n    private ServerSocket serverSocket;\n    private Socket connectToClient;\n    private DataInputStream inFromClient;\n    private DataOutputStream outToClient;\n\n    /**\n     * 构造函数用来设置界面，处理事件\n     */\n    public ChatServer() {\n        // TODO Auto-generated constructor stub\n        // 设置页面\n        mainJframe = new JFrame(\"服务器端\");\n        // 初始化容器\n        con = mainJframe.getContentPane();\n        showArea = new JTextArea();\n        showArea.setEditable(false); // 历史聊天窗口中的文字域不能编辑，只供查看\n        showArea.setLineWrap(true); // 自动换行\n        JSPane = new JScrollPane(showArea);\n        // 待发送文字区域\n        msgText = new JTextField();\n        msgText.setColumns(35);\n        // 事件监听\n        msgText.addActionListener(this);\n        sentBtn = new JButton(\"Send\");\n        sentBtn.addActionListener(this);\n        // 界面下部\n        pane = new JPanel();\n        pane.setLayout(new FlowLayout());\n        pane.add(msgText);\n        pane.add(sentBtn);\n\n        con.add(JSPane, BorderLayout.CENTER);\n        con.add(pane, BorderLayout.SOUTH);\n        mainJframe.setSize(500, 400);\n        mainJframe.setLocation(600, 200);\n        mainJframe.setVisible(true);\n        mainJframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        try {\n            serverSocket = new ServerSocket(8888);\n            showArea.append(\"  正在等待对话请求\\n\");\n            // 监听端口\n            connectToClient = serverSocket.accept();\n            inFromClient = new DataInputStream(connectToClient.getInputStream());\n            outToClient = new DataOutputStream(connectToClient.getOutputStream());\n            // 启动线程\n            thread = new Thread(this);\n            thread.setPriority(Thread.MIN_PRIORITY);\n            thread.start();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            // 出现此异常说明服务器未创建成功\n            showArea.append(\"  对不起，不能创建服务器\\n\");\n            // 待发送文字区域不能编辑\n            msgText.setEditable(false);\n            // 发送按钮不可用\n            sentBtn.setEnabled(false);\n        }\n\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see java.lang.Runnable#run()\n     */\n    @Override\n        public void run() {\n            // TODO Auto-generated method stub\n            // 此线程用来接收客户端传来的信息\n            while (true) {\n                try {\n                    showArea.append(\"  对方说：\" + inFromClient.readUTF() + \"\\n\");\n                    Thread.sleep(1000);\n                } catch (IOException | InterruptedException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n\n        }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see\n     * java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)\n     */\n    @Override\n        public void actionPerformed(ActionEvent e) {\n            // TODO Auto-generated method stub\n            // 响应按钮事件\n            String s = msgText.getText();\n            // 如果待发送文字区域存在文字\n            if (s.length() > 0) {\n                try {\n                    // 将文字写入到流中\n                    outToClient.writeUTF(s);\n                    outToClient.flush();\n                    // 历史聊天记录增添内容\n                    showArea.append(\"  我说：\" + msgText.getText() + \"\\n\");\n                    // 待发送文字区域设为空\n                    msgText.setText(null);\n                } catch (IOException e1) {\n                    // TODO Auto-generated catch block\n                    // 出现此异常说明消息未发送成功\n                    showArea.append(\"  你的消息：\" + \"“\" + msgText.getText() + \"”\" + \"未能发送成功\\n\");\n                }\n            }\n        }\n\n    public static void main(String[] args) {\n        // 主线程用来发送消息\n        new ChatServer();\n    }\n\n}\n```\n\n# client客户端\n\n## 主线程\n\n### 构建页面\n### 连接serverSocket\n### 添加send按钮的监听事件\n\n## 子线程\n\n### 死循环接收消息\n\n### 客户端代码如下：\n```\n/**\n * \n */\npackage com.yatai.web;\n\nimport java.awt.BorderLayout;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTextArea;\nimport javax.swing.JTextField;\n\n/**\n * @author 王伟业 2014年5月28日\n */\npublic class ChatClient implements ActionListener, Runnable {\n    // 相同的界面形式\n    private JTextArea showArea;\n    private JTextField msgText;\n    private JFrame mainJframe;\n    private JButton sentBtn;\n    private JScrollPane JSPane;\n    private JPanel pane;\n    private Container con;\n    // 相似的处理方法\n    private Thread thread = null;\n    private Socket connectToServer;\n    private DataInputStream inFromServer;\n    private DataOutputStream outToServer;\n\n    /**\n     * \n     */\n    public ChatClient() {\n        // TODO Auto-generated constructor stub\n        // 构造函数下完成以下内容\n        mainJframe = new JFrame(\"客户端\");\n        con = mainJframe.getContentPane();\n        showArea = new JTextArea();\n        showArea.setEditable(false);\n        showArea.setLineWrap(true);\n        showArea.setWrapStyleWord(true);\n        JSPane = new JScrollPane(showArea);\n        msgText = new JTextField();\n        msgText.setColumns(35);\n        msgText.addActionListener(this);\n        sentBtn = new JButton(\"Send\");\n        sentBtn.addActionListener(this);\n        pane = new JPanel();\n        pane.setLayout(new FlowLayout());\n        pane.add(msgText);\n        pane.add(sentBtn);\n        con.add(JSPane, BorderLayout.CENTER);\n        con.add(pane, BorderLayout.SOUTH);\n        mainJframe.setSize(500, 400);\n        mainJframe.setLocation(80, 200);\n        mainJframe.setVisible(true);\n        mainJframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        try {\n            connectToServer = new Socket(\"localhost\", 8888);\n            inFromServer = new DataInputStream(connectToServer.getInputStream());\n            outToServer = new DataOutputStream(connectToServer.getOutputStream());\n            showArea.append(\"  连接成功，可以通信\\n\");\n\n            // 创建线程\n            thread = new Thread(this);\n            thread.setPriority(Thread.MIN_PRIORITY);\n            thread.start();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            // 出现异常说明连接失败\n            // 向历史聊天区域打印提示信息\n            showArea.append(\"  对不起，连接服务器失败\\n\");\n            // 异常连接时输入框不可用\n            msgText.setEditable(false);\n            msgText.setEnabled(false);\n        }\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see java.lang.Runnable#run()\n     */\n    @Override\n        public void run() {\n            // TODO Auto-generated method stub\n            // 该线程用来接收传来的消息\n            while (true) {\n                try {\n                    showArea.append(\"  对方说：\" + inFromServer.readUTF() + \"\\n\");\n                    Thread.sleep(1000);\n                } catch (IOException | InterruptedException e) {\n                    // TODO Auto-generated catch block\n                    // 此处异常处理。。。。\n                    e.printStackTrace();\n                }\n            }\n        }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see\n     * java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)\n     */\n    @Override\n        public void actionPerformed(ActionEvent e) {\n            // TODO Auto-generated method stub\n            // 响应事件\n            String s = msgText.getText();\n            // 如果待发送文字区域存在文字\n            if (s.length() > 0) {\n                try {\n                    // 将文字写入到流中\n                    outToServer.writeUTF(s);\n                    outToServer.flush();\n                    // 历史聊天记录增添内容\n                    showArea.append(\"  我说：\" + msgText.getText() + \"\\n\");\n                    // 待发送文字区域设为空\n                    msgText.setText(null);\n                } catch (IOException e1) {\n                    // TODO Auto-generated catch block\n                    // 出现此异常说明消息未发送成功\n                    showArea.append(\"  你的消息：\" + \"“\" + msgText.getText() + \"”\" + \"未能发送成功\\n\");\n                }\n            }\n        }\n\n    public static void main(String[] args) {\n        new ChatClient();\n    }\n}\n```\n","slug":"socket","published":1,"updated":"2019-12-24T02:00:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3k3g00230j9key8y43bz","content":"<h1 id=\"server服务端\"><a href=\"#server服务端\" class=\"headerlink\" title=\"server服务端\"></a>server服务端</h1><h2 id=\"主线程\"><a href=\"#主线程\" class=\"headerlink\" title=\"主线程\"></a>主线程</h2><h3 id=\"构建页面\"><a href=\"#构建页面\" class=\"headerlink\" title=\"构建页面\"></a>构建页面</h3><h3 id=\"创建serverSocket\"><a href=\"#创建serverSocket\" class=\"headerlink\" title=\"创建serverSocket\"></a>创建serverSocket</h3><h3 id=\"添加send按钮的点击事件\"><a href=\"#添加send按钮的点击事件\" class=\"headerlink\" title=\"添加send按钮的点击事件\"></a>添加send按钮的点击事件</h3><h2 id=\"子线程\"><a href=\"#子线程\" class=\"headerlink\" title=\"子线程\"></a>子线程</h2><h3 id=\"死循环接收消息\"><a href=\"#死循环接收消息\" class=\"headerlink\" title=\"死循环接收消息\"></a>死循环接收消息</h3><h2 id=\"服务端代码如下\"><a href=\"#服务端代码如下\" class=\"headerlink\" title=\"服务端代码如下:\"></a>服务端代码如下:</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 主线程发送消息</span><br><span class=\"line\"> * 子线程接收消息</span><br><span class=\"line\"> */</span><br><span class=\"line\">package com.yatai.web;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.awt.BorderLayout;</span><br><span class=\"line\">import java.awt.Container;</span><br><span class=\"line\">import java.awt.FlowLayout;</span><br><span class=\"line\">import java.awt.event.ActionEvent;</span><br><span class=\"line\">import java.awt.event.ActionListener;</span><br><span class=\"line\">import java.io.DataInputStream;</span><br><span class=\"line\">import java.io.DataOutputStream;</span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.net.ServerSocket;</span><br><span class=\"line\">import java.net.Socket;</span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.swing.JButton;</span><br><span class=\"line\">import javax.swing.JFrame;</span><br><span class=\"line\">import javax.swing.JPanel;</span><br><span class=\"line\">import javax.swing.JScrollPane;</span><br><span class=\"line\">import javax.swing.JTextArea;</span><br><span class=\"line\">import javax.swing.JTextField;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author 王伟业 2014年5月28日</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ChatServer implements ActionListener, Runnable &#123;</span><br><span class=\"line\">    // 用来存放客户端连接数量</span><br><span class=\"line\">    public static ArrayList&lt;Socket&gt; socketList = new ArrayList&lt;Socket&gt;();</span><br><span class=\"line\">    // 显示历史聊天记录</span><br><span class=\"line\">    private JTextArea showArea;</span><br><span class=\"line\">    // 待发送的字符区域</span><br><span class=\"line\">    private JTextField msgText;</span><br><span class=\"line\">    // 窗口</span><br><span class=\"line\">    private JFrame mainJframe;</span><br><span class=\"line\">    // 发送按钮</span><br><span class=\"line\">    private JButton sentBtn;</span><br><span class=\"line\">    // 滚动面板</span><br><span class=\"line\">    private JScrollPane JSPane;</span><br><span class=\"line\">    // 普通面板</span><br><span class=\"line\">    private JPanel pane;</span><br><span class=\"line\">    // 最大的容器</span><br><span class=\"line\">    private Container con;</span><br><span class=\"line\">    // 线程处理信息</span><br><span class=\"line\">    private Thread thread = null;</span><br><span class=\"line\">    private ServerSocket serverSocket;</span><br><span class=\"line\">    private Socket connectToClient;</span><br><span class=\"line\">    private DataInputStream inFromClient;</span><br><span class=\"line\">    private DataOutputStream outToClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 构造函数用来设置界面，处理事件</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public ChatServer() &#123;</span><br><span class=\"line\">        // TODO Auto-generated constructor stub</span><br><span class=\"line\">        // 设置页面</span><br><span class=\"line\">        mainJframe = new JFrame(&quot;服务器端&quot;);</span><br><span class=\"line\">        // 初始化容器</span><br><span class=\"line\">        con = mainJframe.getContentPane();</span><br><span class=\"line\">        showArea = new JTextArea();</span><br><span class=\"line\">        showArea.setEditable(false); // 历史聊天窗口中的文字域不能编辑，只供查看</span><br><span class=\"line\">        showArea.setLineWrap(true); // 自动换行</span><br><span class=\"line\">        JSPane = new JScrollPane(showArea);</span><br><span class=\"line\">        // 待发送文字区域</span><br><span class=\"line\">        msgText = new JTextField();</span><br><span class=\"line\">        msgText.setColumns(35);</span><br><span class=\"line\">        // 事件监听</span><br><span class=\"line\">        msgText.addActionListener(this);</span><br><span class=\"line\">        sentBtn = new JButton(&quot;Send&quot;);</span><br><span class=\"line\">        sentBtn.addActionListener(this);</span><br><span class=\"line\">        // 界面下部</span><br><span class=\"line\">        pane = new JPanel();</span><br><span class=\"line\">        pane.setLayout(new FlowLayout());</span><br><span class=\"line\">        pane.add(msgText);</span><br><span class=\"line\">        pane.add(sentBtn);</span><br><span class=\"line\"></span><br><span class=\"line\">        con.add(JSPane, BorderLayout.CENTER);</span><br><span class=\"line\">        con.add(pane, BorderLayout.SOUTH);</span><br><span class=\"line\">        mainJframe.setSize(500, 400);</span><br><span class=\"line\">        mainJframe.setLocation(600, 200);</span><br><span class=\"line\">        mainJframe.setVisible(true);</span><br><span class=\"line\">        mainJframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            serverSocket = new ServerSocket(8888);</span><br><span class=\"line\">            showArea.append(&quot;  正在等待对话请求\\n&quot;);</span><br><span class=\"line\">            // 监听端口</span><br><span class=\"line\">            connectToClient = serverSocket.accept();</span><br><span class=\"line\">            inFromClient = new DataInputStream(connectToClient.getInputStream());</span><br><span class=\"line\">            outToClient = new DataOutputStream(connectToClient.getOutputStream());</span><br><span class=\"line\">            // 启动线程</span><br><span class=\"line\">            thread = new Thread(this);</span><br><span class=\"line\">            thread.setPriority(Thread.MIN_PRIORITY);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            // TODO Auto-generated catch block</span><br><span class=\"line\">            // 出现此异常说明服务器未创建成功</span><br><span class=\"line\">            showArea.append(&quot;  对不起，不能创建服务器\\n&quot;);</span><br><span class=\"line\">            // 待发送文字区域不能编辑</span><br><span class=\"line\">            msgText.setEditable(false);</span><br><span class=\"line\">            // 发送按钮不可用</span><br><span class=\"line\">            sentBtn.setEnabled(false);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * (non-Javadoc)</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @see java.lang.Runnable#run()</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            // TODO Auto-generated method stub</span><br><span class=\"line\">            // 此线程用来接收客户端传来的信息</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    showArea.append(&quot;  对方说：&quot; + inFromClient.readUTF() + &quot;\\n&quot;);</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class=\"line\">                    // TODO Auto-generated catch block</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * (non-Javadoc)</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @see</span><br><span class=\"line\">     * java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">        public void actionPerformed(ActionEvent e) &#123;</span><br><span class=\"line\">            // TODO Auto-generated method stub</span><br><span class=\"line\">            // 响应按钮事件</span><br><span class=\"line\">            String s = msgText.getText();</span><br><span class=\"line\">            // 如果待发送文字区域存在文字</span><br><span class=\"line\">            if (s.length() &gt; 0) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    // 将文字写入到流中</span><br><span class=\"line\">                    outToClient.writeUTF(s);</span><br><span class=\"line\">                    outToClient.flush();</span><br><span class=\"line\">                    // 历史聊天记录增添内容</span><br><span class=\"line\">                    showArea.append(&quot;  我说：&quot; + msgText.getText() + &quot;\\n&quot;);</span><br><span class=\"line\">                    // 待发送文字区域设为空</span><br><span class=\"line\">                    msgText.setText(null);</span><br><span class=\"line\">                &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">                    // TODO Auto-generated catch block</span><br><span class=\"line\">                    // 出现此异常说明消息未发送成功</span><br><span class=\"line\">                    showArea.append(&quot;  你的消息：&quot; + &quot;“&quot; + msgText.getText() + &quot;”&quot; + &quot;未能发送成功\\n&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // 主线程用来发送消息</span><br><span class=\"line\">        new ChatServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"client客户端\"><a href=\"#client客户端\" class=\"headerlink\" title=\"client客户端\"></a>client客户端</h1><h2 id=\"主线程-1\"><a href=\"#主线程-1\" class=\"headerlink\" title=\"主线程\"></a>主线程</h2><h3 id=\"构建页面-1\"><a href=\"#构建页面-1\" class=\"headerlink\" title=\"构建页面\"></a>构建页面</h3><h3 id=\"连接serverSocket\"><a href=\"#连接serverSocket\" class=\"headerlink\" title=\"连接serverSocket\"></a>连接serverSocket</h3><h3 id=\"添加send按钮的监听事件\"><a href=\"#添加send按钮的监听事件\" class=\"headerlink\" title=\"添加send按钮的监听事件\"></a>添加send按钮的监听事件</h3><h2 id=\"子线程-1\"><a href=\"#子线程-1\" class=\"headerlink\" title=\"子线程\"></a>子线程</h2><h3 id=\"死循环接收消息-1\"><a href=\"#死循环接收消息-1\" class=\"headerlink\" title=\"死循环接收消息\"></a>死循环接收消息</h3><h3 id=\"客户端代码如下：\"><a href=\"#客户端代码如下：\" class=\"headerlink\" title=\"客户端代码如下：\"></a>客户端代码如下：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">package com.yatai.web;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.awt.BorderLayout;</span><br><span class=\"line\">import java.awt.Container;</span><br><span class=\"line\">import java.awt.FlowLayout;</span><br><span class=\"line\">import java.awt.event.ActionEvent;</span><br><span class=\"line\">import java.awt.event.ActionListener;</span><br><span class=\"line\">import java.io.DataInputStream;</span><br><span class=\"line\">import java.io.DataOutputStream;</span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.net.Socket;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.swing.JButton;</span><br><span class=\"line\">import javax.swing.JFrame;</span><br><span class=\"line\">import javax.swing.JPanel;</span><br><span class=\"line\">import javax.swing.JScrollPane;</span><br><span class=\"line\">import javax.swing.JTextArea;</span><br><span class=\"line\">import javax.swing.JTextField;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author 王伟业 2014年5月28日</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ChatClient implements ActionListener, Runnable &#123;</span><br><span class=\"line\">    // 相同的界面形式</span><br><span class=\"line\">    private JTextArea showArea;</span><br><span class=\"line\">    private JTextField msgText;</span><br><span class=\"line\">    private JFrame mainJframe;</span><br><span class=\"line\">    private JButton sentBtn;</span><br><span class=\"line\">    private JScrollPane JSPane;</span><br><span class=\"line\">    private JPanel pane;</span><br><span class=\"line\">    private Container con;</span><br><span class=\"line\">    // 相似的处理方法</span><br><span class=\"line\">    private Thread thread = null;</span><br><span class=\"line\">    private Socket connectToServer;</span><br><span class=\"line\">    private DataInputStream inFromServer;</span><br><span class=\"line\">    private DataOutputStream outToServer;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * </span><br><span class=\"line\">     */</span><br><span class=\"line\">    public ChatClient() &#123;</span><br><span class=\"line\">        // TODO Auto-generated constructor stub</span><br><span class=\"line\">        // 构造函数下完成以下内容</span><br><span class=\"line\">        mainJframe = new JFrame(&quot;客户端&quot;);</span><br><span class=\"line\">        con = mainJframe.getContentPane();</span><br><span class=\"line\">        showArea = new JTextArea();</span><br><span class=\"line\">        showArea.setEditable(false);</span><br><span class=\"line\">        showArea.setLineWrap(true);</span><br><span class=\"line\">        showArea.setWrapStyleWord(true);</span><br><span class=\"line\">        JSPane = new JScrollPane(showArea);</span><br><span class=\"line\">        msgText = new JTextField();</span><br><span class=\"line\">        msgText.setColumns(35);</span><br><span class=\"line\">        msgText.addActionListener(this);</span><br><span class=\"line\">        sentBtn = new JButton(&quot;Send&quot;);</span><br><span class=\"line\">        sentBtn.addActionListener(this);</span><br><span class=\"line\">        pane = new JPanel();</span><br><span class=\"line\">        pane.setLayout(new FlowLayout());</span><br><span class=\"line\">        pane.add(msgText);</span><br><span class=\"line\">        pane.add(sentBtn);</span><br><span class=\"line\">        con.add(JSPane, BorderLayout.CENTER);</span><br><span class=\"line\">        con.add(pane, BorderLayout.SOUTH);</span><br><span class=\"line\">        mainJframe.setSize(500, 400);</span><br><span class=\"line\">        mainJframe.setLocation(80, 200);</span><br><span class=\"line\">        mainJframe.setVisible(true);</span><br><span class=\"line\">        mainJframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            connectToServer = new Socket(&quot;localhost&quot;, 8888);</span><br><span class=\"line\">            inFromServer = new DataInputStream(connectToServer.getInputStream());</span><br><span class=\"line\">            outToServer = new DataOutputStream(connectToServer.getOutputStream());</span><br><span class=\"line\">            showArea.append(&quot;  连接成功，可以通信\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">            // 创建线程</span><br><span class=\"line\">            thread = new Thread(this);</span><br><span class=\"line\">            thread.setPriority(Thread.MIN_PRIORITY);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            // TODO Auto-generated catch block</span><br><span class=\"line\">            // 出现异常说明连接失败</span><br><span class=\"line\">            // 向历史聊天区域打印提示信息</span><br><span class=\"line\">            showArea.append(&quot;  对不起，连接服务器失败\\n&quot;);</span><br><span class=\"line\">            // 异常连接时输入框不可用</span><br><span class=\"line\">            msgText.setEditable(false);</span><br><span class=\"line\">            msgText.setEnabled(false);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * (non-Javadoc)</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @see java.lang.Runnable#run()</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            // TODO Auto-generated method stub</span><br><span class=\"line\">            // 该线程用来接收传来的消息</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    showArea.append(&quot;  对方说：&quot; + inFromServer.readUTF() + &quot;\\n&quot;);</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class=\"line\">                    // TODO Auto-generated catch block</span><br><span class=\"line\">                    // 此处异常处理。。。。</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * (non-Javadoc)</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @see</span><br><span class=\"line\">     * java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">        public void actionPerformed(ActionEvent e) &#123;</span><br><span class=\"line\">            // TODO Auto-generated method stub</span><br><span class=\"line\">            // 响应事件</span><br><span class=\"line\">            String s = msgText.getText();</span><br><span class=\"line\">            // 如果待发送文字区域存在文字</span><br><span class=\"line\">            if (s.length() &gt; 0) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    // 将文字写入到流中</span><br><span class=\"line\">                    outToServer.writeUTF(s);</span><br><span class=\"line\">                    outToServer.flush();</span><br><span class=\"line\">                    // 历史聊天记录增添内容</span><br><span class=\"line\">                    showArea.append(&quot;  我说：&quot; + msgText.getText() + &quot;\\n&quot;);</span><br><span class=\"line\">                    // 待发送文字区域设为空</span><br><span class=\"line\">                    msgText.setText(null);</span><br><span class=\"line\">                &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">                    // TODO Auto-generated catch block</span><br><span class=\"line\">                    // 出现此异常说明消息未发送成功</span><br><span class=\"line\">                    showArea.append(&quot;  你的消息：&quot; + &quot;“&quot; + msgText.getText() + &quot;”&quot; + &quot;未能发送成功\\n&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new ChatClient();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"server服务端\"><a href=\"#server服务端\" class=\"headerlink\" title=\"server服务端\"></a>server服务端</h1><h2 id=\"主线程\"><a href=\"#主线程\" class=\"headerlink\" title=\"主线程\"></a>主线程</h2><h3 id=\"构建页面\"><a href=\"#构建页面\" class=\"headerlink\" title=\"构建页面\"></a>构建页面</h3><h3 id=\"创建serverSocket\"><a href=\"#创建serverSocket\" class=\"headerlink\" title=\"创建serverSocket\"></a>创建serverSocket</h3><h3 id=\"添加send按钮的点击事件\"><a href=\"#添加send按钮的点击事件\" class=\"headerlink\" title=\"添加send按钮的点击事件\"></a>添加send按钮的点击事件</h3><h2 id=\"子线程\"><a href=\"#子线程\" class=\"headerlink\" title=\"子线程\"></a>子线程</h2><h3 id=\"死循环接收消息\"><a href=\"#死循环接收消息\" class=\"headerlink\" title=\"死循环接收消息\"></a>死循环接收消息</h3><h2 id=\"服务端代码如下\"><a href=\"#服务端代码如下\" class=\"headerlink\" title=\"服务端代码如下:\"></a>服务端代码如下:</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 主线程发送消息</span><br><span class=\"line\"> * 子线程接收消息</span><br><span class=\"line\"> */</span><br><span class=\"line\">package com.yatai.web;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.awt.BorderLayout;</span><br><span class=\"line\">import java.awt.Container;</span><br><span class=\"line\">import java.awt.FlowLayout;</span><br><span class=\"line\">import java.awt.event.ActionEvent;</span><br><span class=\"line\">import java.awt.event.ActionListener;</span><br><span class=\"line\">import java.io.DataInputStream;</span><br><span class=\"line\">import java.io.DataOutputStream;</span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.net.ServerSocket;</span><br><span class=\"line\">import java.net.Socket;</span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.swing.JButton;</span><br><span class=\"line\">import javax.swing.JFrame;</span><br><span class=\"line\">import javax.swing.JPanel;</span><br><span class=\"line\">import javax.swing.JScrollPane;</span><br><span class=\"line\">import javax.swing.JTextArea;</span><br><span class=\"line\">import javax.swing.JTextField;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author 王伟业 2014年5月28日</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ChatServer implements ActionListener, Runnable &#123;</span><br><span class=\"line\">    // 用来存放客户端连接数量</span><br><span class=\"line\">    public static ArrayList&lt;Socket&gt; socketList = new ArrayList&lt;Socket&gt;();</span><br><span class=\"line\">    // 显示历史聊天记录</span><br><span class=\"line\">    private JTextArea showArea;</span><br><span class=\"line\">    // 待发送的字符区域</span><br><span class=\"line\">    private JTextField msgText;</span><br><span class=\"line\">    // 窗口</span><br><span class=\"line\">    private JFrame mainJframe;</span><br><span class=\"line\">    // 发送按钮</span><br><span class=\"line\">    private JButton sentBtn;</span><br><span class=\"line\">    // 滚动面板</span><br><span class=\"line\">    private JScrollPane JSPane;</span><br><span class=\"line\">    // 普通面板</span><br><span class=\"line\">    private JPanel pane;</span><br><span class=\"line\">    // 最大的容器</span><br><span class=\"line\">    private Container con;</span><br><span class=\"line\">    // 线程处理信息</span><br><span class=\"line\">    private Thread thread = null;</span><br><span class=\"line\">    private ServerSocket serverSocket;</span><br><span class=\"line\">    private Socket connectToClient;</span><br><span class=\"line\">    private DataInputStream inFromClient;</span><br><span class=\"line\">    private DataOutputStream outToClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 构造函数用来设置界面，处理事件</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public ChatServer() &#123;</span><br><span class=\"line\">        // TODO Auto-generated constructor stub</span><br><span class=\"line\">        // 设置页面</span><br><span class=\"line\">        mainJframe = new JFrame(&quot;服务器端&quot;);</span><br><span class=\"line\">        // 初始化容器</span><br><span class=\"line\">        con = mainJframe.getContentPane();</span><br><span class=\"line\">        showArea = new JTextArea();</span><br><span class=\"line\">        showArea.setEditable(false); // 历史聊天窗口中的文字域不能编辑，只供查看</span><br><span class=\"line\">        showArea.setLineWrap(true); // 自动换行</span><br><span class=\"line\">        JSPane = new JScrollPane(showArea);</span><br><span class=\"line\">        // 待发送文字区域</span><br><span class=\"line\">        msgText = new JTextField();</span><br><span class=\"line\">        msgText.setColumns(35);</span><br><span class=\"line\">        // 事件监听</span><br><span class=\"line\">        msgText.addActionListener(this);</span><br><span class=\"line\">        sentBtn = new JButton(&quot;Send&quot;);</span><br><span class=\"line\">        sentBtn.addActionListener(this);</span><br><span class=\"line\">        // 界面下部</span><br><span class=\"line\">        pane = new JPanel();</span><br><span class=\"line\">        pane.setLayout(new FlowLayout());</span><br><span class=\"line\">        pane.add(msgText);</span><br><span class=\"line\">        pane.add(sentBtn);</span><br><span class=\"line\"></span><br><span class=\"line\">        con.add(JSPane, BorderLayout.CENTER);</span><br><span class=\"line\">        con.add(pane, BorderLayout.SOUTH);</span><br><span class=\"line\">        mainJframe.setSize(500, 400);</span><br><span class=\"line\">        mainJframe.setLocation(600, 200);</span><br><span class=\"line\">        mainJframe.setVisible(true);</span><br><span class=\"line\">        mainJframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            serverSocket = new ServerSocket(8888);</span><br><span class=\"line\">            showArea.append(&quot;  正在等待对话请求\\n&quot;);</span><br><span class=\"line\">            // 监听端口</span><br><span class=\"line\">            connectToClient = serverSocket.accept();</span><br><span class=\"line\">            inFromClient = new DataInputStream(connectToClient.getInputStream());</span><br><span class=\"line\">            outToClient = new DataOutputStream(connectToClient.getOutputStream());</span><br><span class=\"line\">            // 启动线程</span><br><span class=\"line\">            thread = new Thread(this);</span><br><span class=\"line\">            thread.setPriority(Thread.MIN_PRIORITY);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            // TODO Auto-generated catch block</span><br><span class=\"line\">            // 出现此异常说明服务器未创建成功</span><br><span class=\"line\">            showArea.append(&quot;  对不起，不能创建服务器\\n&quot;);</span><br><span class=\"line\">            // 待发送文字区域不能编辑</span><br><span class=\"line\">            msgText.setEditable(false);</span><br><span class=\"line\">            // 发送按钮不可用</span><br><span class=\"line\">            sentBtn.setEnabled(false);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * (non-Javadoc)</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @see java.lang.Runnable#run()</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            // TODO Auto-generated method stub</span><br><span class=\"line\">            // 此线程用来接收客户端传来的信息</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    showArea.append(&quot;  对方说：&quot; + inFromClient.readUTF() + &quot;\\n&quot;);</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class=\"line\">                    // TODO Auto-generated catch block</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * (non-Javadoc)</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @see</span><br><span class=\"line\">     * java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">        public void actionPerformed(ActionEvent e) &#123;</span><br><span class=\"line\">            // TODO Auto-generated method stub</span><br><span class=\"line\">            // 响应按钮事件</span><br><span class=\"line\">            String s = msgText.getText();</span><br><span class=\"line\">            // 如果待发送文字区域存在文字</span><br><span class=\"line\">            if (s.length() &gt; 0) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    // 将文字写入到流中</span><br><span class=\"line\">                    outToClient.writeUTF(s);</span><br><span class=\"line\">                    outToClient.flush();</span><br><span class=\"line\">                    // 历史聊天记录增添内容</span><br><span class=\"line\">                    showArea.append(&quot;  我说：&quot; + msgText.getText() + &quot;\\n&quot;);</span><br><span class=\"line\">                    // 待发送文字区域设为空</span><br><span class=\"line\">                    msgText.setText(null);</span><br><span class=\"line\">                &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">                    // TODO Auto-generated catch block</span><br><span class=\"line\">                    // 出现此异常说明消息未发送成功</span><br><span class=\"line\">                    showArea.append(&quot;  你的消息：&quot; + &quot;“&quot; + msgText.getText() + &quot;”&quot; + &quot;未能发送成功\\n&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // 主线程用来发送消息</span><br><span class=\"line\">        new ChatServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"client客户端\"><a href=\"#client客户端\" class=\"headerlink\" title=\"client客户端\"></a>client客户端</h1><h2 id=\"主线程-1\"><a href=\"#主线程-1\" class=\"headerlink\" title=\"主线程\"></a>主线程</h2><h3 id=\"构建页面-1\"><a href=\"#构建页面-1\" class=\"headerlink\" title=\"构建页面\"></a>构建页面</h3><h3 id=\"连接serverSocket\"><a href=\"#连接serverSocket\" class=\"headerlink\" title=\"连接serverSocket\"></a>连接serverSocket</h3><h3 id=\"添加send按钮的监听事件\"><a href=\"#添加send按钮的监听事件\" class=\"headerlink\" title=\"添加send按钮的监听事件\"></a>添加send按钮的监听事件</h3><h2 id=\"子线程-1\"><a href=\"#子线程-1\" class=\"headerlink\" title=\"子线程\"></a>子线程</h2><h3 id=\"死循环接收消息-1\"><a href=\"#死循环接收消息-1\" class=\"headerlink\" title=\"死循环接收消息\"></a>死循环接收消息</h3><h3 id=\"客户端代码如下：\"><a href=\"#客户端代码如下：\" class=\"headerlink\" title=\"客户端代码如下：\"></a>客户端代码如下：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">package com.yatai.web;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.awt.BorderLayout;</span><br><span class=\"line\">import java.awt.Container;</span><br><span class=\"line\">import java.awt.FlowLayout;</span><br><span class=\"line\">import java.awt.event.ActionEvent;</span><br><span class=\"line\">import java.awt.event.ActionListener;</span><br><span class=\"line\">import java.io.DataInputStream;</span><br><span class=\"line\">import java.io.DataOutputStream;</span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.net.Socket;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.swing.JButton;</span><br><span class=\"line\">import javax.swing.JFrame;</span><br><span class=\"line\">import javax.swing.JPanel;</span><br><span class=\"line\">import javax.swing.JScrollPane;</span><br><span class=\"line\">import javax.swing.JTextArea;</span><br><span class=\"line\">import javax.swing.JTextField;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author 王伟业 2014年5月28日</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ChatClient implements ActionListener, Runnable &#123;</span><br><span class=\"line\">    // 相同的界面形式</span><br><span class=\"line\">    private JTextArea showArea;</span><br><span class=\"line\">    private JTextField msgText;</span><br><span class=\"line\">    private JFrame mainJframe;</span><br><span class=\"line\">    private JButton sentBtn;</span><br><span class=\"line\">    private JScrollPane JSPane;</span><br><span class=\"line\">    private JPanel pane;</span><br><span class=\"line\">    private Container con;</span><br><span class=\"line\">    // 相似的处理方法</span><br><span class=\"line\">    private Thread thread = null;</span><br><span class=\"line\">    private Socket connectToServer;</span><br><span class=\"line\">    private DataInputStream inFromServer;</span><br><span class=\"line\">    private DataOutputStream outToServer;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * </span><br><span class=\"line\">     */</span><br><span class=\"line\">    public ChatClient() &#123;</span><br><span class=\"line\">        // TODO Auto-generated constructor stub</span><br><span class=\"line\">        // 构造函数下完成以下内容</span><br><span class=\"line\">        mainJframe = new JFrame(&quot;客户端&quot;);</span><br><span class=\"line\">        con = mainJframe.getContentPane();</span><br><span class=\"line\">        showArea = new JTextArea();</span><br><span class=\"line\">        showArea.setEditable(false);</span><br><span class=\"line\">        showArea.setLineWrap(true);</span><br><span class=\"line\">        showArea.setWrapStyleWord(true);</span><br><span class=\"line\">        JSPane = new JScrollPane(showArea);</span><br><span class=\"line\">        msgText = new JTextField();</span><br><span class=\"line\">        msgText.setColumns(35);</span><br><span class=\"line\">        msgText.addActionListener(this);</span><br><span class=\"line\">        sentBtn = new JButton(&quot;Send&quot;);</span><br><span class=\"line\">        sentBtn.addActionListener(this);</span><br><span class=\"line\">        pane = new JPanel();</span><br><span class=\"line\">        pane.setLayout(new FlowLayout());</span><br><span class=\"line\">        pane.add(msgText);</span><br><span class=\"line\">        pane.add(sentBtn);</span><br><span class=\"line\">        con.add(JSPane, BorderLayout.CENTER);</span><br><span class=\"line\">        con.add(pane, BorderLayout.SOUTH);</span><br><span class=\"line\">        mainJframe.setSize(500, 400);</span><br><span class=\"line\">        mainJframe.setLocation(80, 200);</span><br><span class=\"line\">        mainJframe.setVisible(true);</span><br><span class=\"line\">        mainJframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            connectToServer = new Socket(&quot;localhost&quot;, 8888);</span><br><span class=\"line\">            inFromServer = new DataInputStream(connectToServer.getInputStream());</span><br><span class=\"line\">            outToServer = new DataOutputStream(connectToServer.getOutputStream());</span><br><span class=\"line\">            showArea.append(&quot;  连接成功，可以通信\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">            // 创建线程</span><br><span class=\"line\">            thread = new Thread(this);</span><br><span class=\"line\">            thread.setPriority(Thread.MIN_PRIORITY);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            // TODO Auto-generated catch block</span><br><span class=\"line\">            // 出现异常说明连接失败</span><br><span class=\"line\">            // 向历史聊天区域打印提示信息</span><br><span class=\"line\">            showArea.append(&quot;  对不起，连接服务器失败\\n&quot;);</span><br><span class=\"line\">            // 异常连接时输入框不可用</span><br><span class=\"line\">            msgText.setEditable(false);</span><br><span class=\"line\">            msgText.setEnabled(false);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * (non-Javadoc)</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @see java.lang.Runnable#run()</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            // TODO Auto-generated method stub</span><br><span class=\"line\">            // 该线程用来接收传来的消息</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    showArea.append(&quot;  对方说：&quot; + inFromServer.readUTF() + &quot;\\n&quot;);</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class=\"line\">                    // TODO Auto-generated catch block</span><br><span class=\"line\">                    // 此处异常处理。。。。</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * (non-Javadoc)</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @see</span><br><span class=\"line\">     * java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">        public void actionPerformed(ActionEvent e) &#123;</span><br><span class=\"line\">            // TODO Auto-generated method stub</span><br><span class=\"line\">            // 响应事件</span><br><span class=\"line\">            String s = msgText.getText();</span><br><span class=\"line\">            // 如果待发送文字区域存在文字</span><br><span class=\"line\">            if (s.length() &gt; 0) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    // 将文字写入到流中</span><br><span class=\"line\">                    outToServer.writeUTF(s);</span><br><span class=\"line\">                    outToServer.flush();</span><br><span class=\"line\">                    // 历史聊天记录增添内容</span><br><span class=\"line\">                    showArea.append(&quot;  我说：&quot; + msgText.getText() + &quot;\\n&quot;);</span><br><span class=\"line\">                    // 待发送文字区域设为空</span><br><span class=\"line\">                    msgText.setText(null);</span><br><span class=\"line\">                &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">                    // TODO Auto-generated catch block</span><br><span class=\"line\">                    // 出现此异常说明消息未发送成功</span><br><span class=\"line\">                    showArea.append(&quot;  你的消息：&quot; + &quot;“&quot; + msgText.getText() + &quot;”&quot; + &quot;未能发送成功\\n&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new ChatClient();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Java多线程编程","date":"2018-01-23T06:35:57.000Z","_content":"![pic](http://www.wailian.work/images/2018/01/23/60f198516cee4ab511cb190a85599d3e1d88302a4d1ba-iBehXn_fw658.jpg)\n\n# 相关概念\n\n线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\n\n# 线程状态\n\n## 创建\n\n当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新建状态时，程序还没有开始运行线程中的代码\n\n## 就绪\n\n一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。此时线程中代码仍未运行\n\n## 运行\n\n当线程获得CPU后，它才进入运行状态，真正开始执行run()方法中的代码\n\n## 阻塞\n\n该线程放弃CPU的使用，暂停运行\n\n常见线程阻塞的原因:\n\n1. 线程执行了Thread.sleep(int millsecond)方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行\n\n2. 线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行\n\n3. 线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法\n\n4. 线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态\n\n## 终止\n\n线程执行完毕\n\n# 线程的创建方法\n\n## 继承Thread类\n\n```\npublic class Thread1 extends Thread {\n    public void run() {\n        // 线程执行代码\n    }\n\n    public class Main {\n\n    public static void main(String[] args) {\n        Thread1 mTh1=new Thread1();\n        Thread1 mTh2=new Thread1();\n        mTh1.start();\n        mTh2.start();\n    }\n}\n```\n\n程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用main的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行\n\n注意：\nstart()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。\n\n从程序运行的结果可以发现，多线程程序是乱序执行。\n\nThread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。\n\n实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。\n\n## 实现Runable接口(推荐)\n\n```\npublic class Thread2 implements Runnable{\n    private String name;\n\n    public Thread2(String name) {\n        this.name=name;\n    }\n\n    @Override\n    public void run() {\n    // 线程逻辑代码\n    }\n}\npublic class Main {\n\n    public static void main(String[] args) {\n        new Thread(new Thread2(\"C\")).start();\n        new Thread(new Thread2(\"D\")).start();\n    }\n}\n```\n\n## 两种方法的区别\n\n如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。\n\n总结：\n实现Runnable接口比继承Thread类所具有的优势：\n1. 适合多个相同的程序代码的线程去处理同一个资源 \n2. 可以避免java中的单继承的限制\n3. 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立\n4. 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类\n\n提醒一下大家：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。\n\n在Java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际就是在操作系统中启动了一个进程。\n\n# 线程状态\n\n![](http://www.wailian.work/images/2018/01/23/20170717150938439.jpg)\n\n# 线程调度\n\nJava线程有优先级，优先级高的线程会优先获得运行机会(但不一定优先级高的一定先执行)\nJava线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：\n\n```\nstatic int MAX_PRIORITY  = 10;  //线程可以具有的最高优先级\nstatic int MIN_PRIORITY  = 1;   //线程可以具有的最低优先级\nstatic int NORM_PRIORITY = 5;   //分配给线程的默认优先级\n```\nThread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。\n\n# 线程睡眠\n\nThread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。\n\n# 线程等待\n\nObject类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。\n\n# 线程让步\n\nThread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。\n\n# 线程加入\n\njoin()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。\n\n# 线程唤醒\n\nObject类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。\n\n注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。\n\n# 常用函数说明\n\n## sleep(long millis)\n\n在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）\n\n# join\n\njoin是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。\n\n## 使用场景\n\n在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。\n\n```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"主线程运行开始!\");\n        Thread1 mTh1=new Thread1(\"A\");\n        Thread1 mTh2=new Thread1(\"B\");\n        mTh1.start();\n        mTh2.start();\n        try {\n            mTh1.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        try {\n            mTh2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"主线程运行结束!\");\n    }\n}\n```\n\n# yield():暂停当前正在执行的线程对象，并执行其他线程。\n\nThread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。\n\nyield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。\n\n结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。可看上面的图。\n\n# sleep()和yield()的区别\n\nsleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。\n\nsleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程\n\n另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield() 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。\n\n# wait\n\n我们可以利用wait()来让一个线程在某些条件下暂停运行。例如，在生产者消费者模型中，生产者线程在缓冲区为满的时候，消费者在缓冲区为空的时候，都应该暂停运行。如果某些线程在等待某些条件触发，那当那些条件为真时，你可以用 notify 和 notifyAll 来通知那些等待中的线程重新开始运行。不同之处在于，notify 仅仅通知一个线程，并且我们不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。换言之，如果只有一个线程在等待一个信号灯，notify和notifyAll都会通知到这个线程。但如果多个线程在等待这个信号灯，那么notify只会通知到其中一个，而其它线程并不会收到任何通知，而notifyAll会唤醒所有等待中的线程。\n\n我们怎么在代码里使用wait()呢？因为wait()并不是Thread类下的函数，我们并不能使用Thread.wait()。事实上很多Java程序员都喜欢这么写，因为它们习惯了使用Thread.sleep()，所以他们会试图使用wait() 来达成相同的目的，但很快他们就会发现这并不能顺利解决问题。正确的方法是对在多线程间共享的那个Object来使用wait。在生产者消费者问题中，这个共享的Object就是那个缓冲区队列。\n\n既然我们应该在synchronized的函数或是对象里调用wait，那哪个对象应该被synchronized呢？答案是，那个你希望上锁的对象就应该被synchronized，即那个在多个线程间被共享的对象。在生产者消费者问题中，应该被synchronized的就是那个缓冲区队列。\n\n## 永远在循环（loop）里调用 wait 和 notify，不是在 If 语句\n\n现在你知道wait应该永远在被synchronized的背景下和那个被多线程共享的对象上调用，下一个一定要记住的问题就是，你应该永远在while循环，而不是if语句中调用wait。因为线程是在某些条件下等待的——在我们的例子里，即“如果缓冲区队列是满的话，那么生产者线程应该等待”，你可能直觉就会写一个if语句。但if语句存在一些微妙的小问题即使条件没被满足，你的线程你也有可能被错误地唤醒。所以如果你不在线程被唤醒后再次使用while循环检查唤醒条件是否被满足，你的程序就有可能会出错——例如在缓冲区为满的时候生产者继续生成数据，或者缓冲区为空的时候消费者开始消耗数据。所以记住，永远在while循环而不是if语句中使用wait！\n\n在while循环里使用wait的目的，是在线程被唤醒的前后都持续检查条件是否被满足。如果条件并未改变，wait被调用之前notify的唤醒通知就来了，那么这个线程并不能保证被唤醒，有可能会导致死锁问题。\n\n下面我们提供一个使用wait和notify的范例程序。在这个程序里，我们使用了上文所述的一些代码规范。我们有两个线程，分别名为PRODUCER（生产者）和CONSUMER（消费者），他们分别继承了了Producer和Consumer类，而Producer和Consumer都继承了Thread类。Producer和Consumer想要实现的代码逻辑都在run()函数内。Main线程开始了生产者和消费者线程，并声明了一个LinkedList作为缓冲区队列（在Java中，LinkedList实现了队列的接口）。生产者在无限循环中持续往LinkedList里插入随机整数直到LinkedList满。我们在while(queue.size == maxSize)循环语句中检查这个条件。请注意到我们在做这个检查条件之前已经在队列对象上使用了synchronized关键词，因而其它线程不能在我们检查条件时改变这个队列。如果队列满了，那么PRODUCER线程会在CONSUMER线程消耗掉队列里的任意一个整数，并用notify来通知PRODUCER线程之前持续等待。在我们的例子中，wait和notify都是使用在同一个共享对象上的。\n\n```\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Random;\n/**\n* Simple Java program to demonstrate How to use wait, notify and notifyAll()\n* method in Java by solving producer consumer problem.\n*/\npublic class ProducerConsumerInJava {\n    public static void main(String args[]) {\n        System.out.println(\"How to use wait and notify method in Java\");\n        System.out.println(\"Solving Producer Consumper Problem\");\n        Queue<Integer> buffer = new LinkedList<>();\n        int maxSize = 10;\n        Thread producer = new Producer(buffer, maxSize, \"PRODUCER\");\n        Thread consumer = new Consumer(buffer, maxSize, \"CONSUMER\");\n        producer.start(); consumer.start(); }\n    }\n    /**\n    * Producer Thread will keep producing values for Consumer\n    * to consumer. It will use wait() method when Queue is full\n    * and use notify() method to send notification to Consumer\n    * Thread.\n    */\n    class Producer extends Thread\n    {\n        private Queue<Integer> queue;\n        private int maxSize;\n        public Producer(Queue<Integer> queue, int maxSize, String name){\n            super(name); this.queue = queue; this.maxSize = maxSize;\n        }\n        @Override public void run()\n        {\n            while (true)\n                {\n                    synchronized (queue) {\n                        while (queue.size() == maxSize) {\n                            try {\n                                System.out .println(\"Queue is full, \" + \"Producer thread waiting for \" + \"consumer to take something from queue\");\n                                queue.wait();\n                            } catch (Exception ex) {\n                                ex.printStackTrace(); }\n                            }\n                            Random random = new Random();\n                            int i = random.nextInt();\n                            System.out.println(\"Producing value : \" + i); queue.add(i); queue.notifyAll();\n                        }\n                    }\n                }\n            }\n    /**\n    * Consumer Thread will consumer values form shared queue.\n    * It will also use wait() method to wait if queue is\n    * empty. It will also use notify method to send\n    * notification to producer thread after consuming values\n    * from queue.\n    */\n    class Consumer extends Thread {\n        private Queue<Integer> queue;\n        private int maxSize;\n        public Consumer(Queue<Integer> queue, int maxSize, String name){\n            super(name);\n            this.queue = queue;\n            this.maxSize = maxSize;\n        }\n        @Override public void run() {\n            while (true) {\n                synchronized (queue) {\n                    while (queue.isEmpty()) {\n                        System.out.println(\"Queue is empty,\" + \"Consumer thread is waiting\" + \" for producer thread to put something in queue\");\n                        try {\n                            queue.wait();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                        }\n                    }\n                    System.out.println(\"Consuming value : \" + queue.remove()); queue.notifyAll();\n                }\n            }\n        }\n    }\n```\n\n![](http://www.wailian.work/images/2018/01/23/20170805131528961.png)\n\n为了更好地理解这个程序，我建议你在debug模式里跑这个程序。一旦你在debug模式下启动程序，它会停止在PRODUCER或者CONSUMER线程上，取决于哪个线程占据了CPU。因为两个线程都有wait()的条件，它们一定会停止，然后你就可以跑这个程序然后看发生什么了（很有可能它就会输出我们以上展示的内容）。你也可以使用Eclipse里的Step into和Step over按钮来更好地理解多线程间发生的事情。\n\n# 阻塞队列实现生产者消费者问题\n\n```\npublic class ProducerConsumerWithQueue {\n    private int queueSize = 10;\n    private ArrayBlockingQueue<Integer> queue = new ArrayBlockingQueue<Integer>(queueSize);\n\n    public static void main(String[] args) {\n        ProducerConsumerWithQueue test = new ProducerConsumerWithQueue();\n        Producer producer = test.new Producer();\n        Consumer consumer = test.new Consumer();\n\n        producer.start();\n        consumer.start();\n    }\n\n    class Consumer extends Thread {\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    queue.take();\n                    System.out.println(\"从队列取走一个元素，队列剩余\" + queue.size() + \"个元素\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    class Producer extends Thread {\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    queue.put(1);\n                    System.out.println(\"向队列取中插入一个元素，队列剩余空间：\" + (queueSize - queue.size()));\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n## 附：阻塞队列的四种处理方法\n\n| 方法\\处理方式| 抛出异常    |  返回特殊值  |一直阻塞|超时退出\n| --------   | -----:   | :----: |\n|插入方法 | add(e)      |   offer(e)    |put(e)|offer(e,time,unit)\n| 移除方法| remove()|poll()|take()|poll(time,unit)\n| 检查方法| element()|  peek()    |不可用|不可用\n\n# 另一个例子\n\n```\n/**\n* 计算输出其他线程锁计算的数据\n*\n*/\npublic class ThreadA {\n    public static void main(String[] args) throws InterruptedException{\n        ThreadB b = new ThreadB();\n        //启动计算线程\n        b.start();\n        //线程A拥有b对象上的锁。线程为了调用wait()或notify()方法，该线程必须是那个对象锁的拥有者\n        synchronized (b) {\n            System.out.println(\"等待对象b完成计算。。。\");\n            //当前线程A等待\n            b.wait();\n            System.out.println(\"b对象计算的总和是：\" + b.total);\n        }\n    }\n}\n\n\n\n/**\n* 计算1+2+3 ... +100的和\n*\n*/\nclass ThreadB extends Thread {\n    int total;\n\n    public void run() {\n        synchronized (this) {\n            for (int i = 0; i < 101; i++) {\n                total += i;\n            }\n            //（完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程A被唤醒\n            notify();\n            System.out.println(\"计算完成\");\n        }\n    }\n}\n```\n\n执行结果：\n\n等待对象b完成计算。。。\n计算完成\nb对象计算的总和是：5050\n\n如果我们将b.wait()去掉呢？结果如下：\n\n等待对象b完成计算。。。\nb对象计算的总和是：0\n计算完成\n\n上述的结果表明，当去掉b.wait()时，新启动的线程ThreadB与主线程ThreadA是各自执行的，没有线程等待的现象。\n\n我们想要的效果是，当线程ThreadB完成计算之后，再去取计算后的结果。所以使用了b.wait()来让主线程等待。\n\n那为什么是使用b.wait()，而不是Thread.currentThread.wait()，或者其他的呢？\n\n如果我们将b.wait()替换成Thread.currentThread.wait()，将会得到如下的结果：\n\nException in thread “main” java.lang.IllegalMonitorStateException\nat java.lang.Object.wait(Native Method)\nat java.lang.Object.wait(Object.java:485)\nat pa.com.thread.ThreadA.main(ThreadA.java:18)\n等待对象b完成计算。。。\n计算完成\n\n替换的代码Thread.currentThread.wait()好像理所当然应该如我们预期的正确啊，让当前线程处于等待状态，让其他线程先执行。\n\n我们忽略了一个很重要的问题：线程与锁是分不开的，线程的同步、等待、唤醒都与对象锁是密不可分的。\n\n线程ThreadA持有对象b的锁，我们要使用这把锁去让线程释放锁，从而让其他的线程能抢到这把锁。\n\n从我们的程序来分析就是：线程ThreadA首先持有锁对象b，然后调用b.wait()将对象锁释放，线程ThreadB争抢到对象锁b，从而执行run()方法中的计算，计算完了之后使用notify()唤醒主线程ThreadA，ThreadA得以继续执行，从而得到了我们预期的效果。\n\n（之所以ThreadB的对象锁也是b，是因为synchronized(this)中的this指向的就是ThreadB的实例b）\n\nThread.currentThread.wait()调用的是当前线程对象（即主线程ThreadA）的wait()方法，当前线程对象ThreadA是没有被加锁的，它只是获取了对象锁b。我基本没有看到过这样的调用，一般使用的是锁对象的wait()，本例中为b.wait()\n\n顺带讲一下wait()与sleep()的区别。\n\n如果我们将b.wait()换成Thread.sleep(1000)，则会出现如下的结果：\n\n等待对象b完成计算。。。\nb对象计算的总和是：0\n计算完成\n\n从执行结果可以看出，Thread.sleep(1000)只是让主线程ThreadA睡眠了1秒钟，而并没有释放对象锁，所以在主线程ThreadA睡眠的过程中，ThreadB拿不到对象锁，从而不能执行。\n\n所以我们也就得出了如下的结论：\n\nwait()方法是让线程释放对象锁，让其他线程拿到锁之后去优先执行，当其他全程唤醒wait()中的线程 或者 拿到对象锁的线程都执行完释放了对象锁之后，wait()中的线程才会再次拿到对象锁从而执行。\n\nsleep()方法是让线程睡眠，此时并没有释放对象锁，其他想要拿到睡眠线程的对象锁的线程也就拿不到相应的对象锁，从而不能抢在它前面执行。\n\n补：\n\nwait、notify和notifyAll方法是Object类的final native方法。所以这些方法不能被子类重写，Object类是所有类的超类，因此在程序中有以下三种形式调用wait等方法。\n\n```\nwait();//方式1：\nthis.wait();//方式2：\nsuper.wait();//方式3\n```\n\nvoid wait()\n\n导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。\n\n# synchronized\n\n卖火车票问题\n\n```\npublic class Seller implements Runnable {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        synchronized (this) {\n            if (Synchronized.ticket > 0) {\n                System.out.println(\"正在卖票,剩余\" + Synchronized.ticket);\n                Synchronized.ticket--;\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n```\npublic class Synchronized {\n    static Integer ticket = 100;\n\n    public static void main(String[] args) {\n        Seller s = new Seller();\n        Thread t1 = new Thread(s);\n        Thread t2 = new Thread(s);\n        Thread t3 = new Thread(s);\n        Thread t4 = new Thread(s);\n        Thread t5 = new Thread(s);\n        Thread t6 = new Thread(s);\n\n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n        t6.start();\n    }\n}\n```\n\n[源码地址](https://github.com/wangweiye01/mutiThreading)\n","source":"_posts/java-thread.md","raw":"---\ntitle: Java多线程编程\ndate: 2018-01-23 14:35:57\ntags:\n---\n![pic](http://www.wailian.work/images/2018/01/23/60f198516cee4ab511cb190a85599d3e1d88302a4d1ba-iBehXn_fw658.jpg)\n\n# 相关概念\n\n线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\n\n# 线程状态\n\n## 创建\n\n当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新建状态时，程序还没有开始运行线程中的代码\n\n## 就绪\n\n一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。此时线程中代码仍未运行\n\n## 运行\n\n当线程获得CPU后，它才进入运行状态，真正开始执行run()方法中的代码\n\n## 阻塞\n\n该线程放弃CPU的使用，暂停运行\n\n常见线程阻塞的原因:\n\n1. 线程执行了Thread.sleep(int millsecond)方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行\n\n2. 线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行\n\n3. 线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法\n\n4. 线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态\n\n## 终止\n\n线程执行完毕\n\n# 线程的创建方法\n\n## 继承Thread类\n\n```\npublic class Thread1 extends Thread {\n    public void run() {\n        // 线程执行代码\n    }\n\n    public class Main {\n\n    public static void main(String[] args) {\n        Thread1 mTh1=new Thread1();\n        Thread1 mTh2=new Thread1();\n        mTh1.start();\n        mTh2.start();\n    }\n}\n```\n\n程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用main的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行\n\n注意：\nstart()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。\n\n从程序运行的结果可以发现，多线程程序是乱序执行。\n\nThread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。\n\n实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。\n\n## 实现Runable接口(推荐)\n\n```\npublic class Thread2 implements Runnable{\n    private String name;\n\n    public Thread2(String name) {\n        this.name=name;\n    }\n\n    @Override\n    public void run() {\n    // 线程逻辑代码\n    }\n}\npublic class Main {\n\n    public static void main(String[] args) {\n        new Thread(new Thread2(\"C\")).start();\n        new Thread(new Thread2(\"D\")).start();\n    }\n}\n```\n\n## 两种方法的区别\n\n如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。\n\n总结：\n实现Runnable接口比继承Thread类所具有的优势：\n1. 适合多个相同的程序代码的线程去处理同一个资源 \n2. 可以避免java中的单继承的限制\n3. 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立\n4. 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类\n\n提醒一下大家：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。\n\n在Java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际就是在操作系统中启动了一个进程。\n\n# 线程状态\n\n![](http://www.wailian.work/images/2018/01/23/20170717150938439.jpg)\n\n# 线程调度\n\nJava线程有优先级，优先级高的线程会优先获得运行机会(但不一定优先级高的一定先执行)\nJava线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：\n\n```\nstatic int MAX_PRIORITY  = 10;  //线程可以具有的最高优先级\nstatic int MIN_PRIORITY  = 1;   //线程可以具有的最低优先级\nstatic int NORM_PRIORITY = 5;   //分配给线程的默认优先级\n```\nThread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。\n\n# 线程睡眠\n\nThread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。\n\n# 线程等待\n\nObject类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。\n\n# 线程让步\n\nThread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。\n\n# 线程加入\n\njoin()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。\n\n# 线程唤醒\n\nObject类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。\n\n注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。\n\n# 常用函数说明\n\n## sleep(long millis)\n\n在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）\n\n# join\n\njoin是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。\n\n## 使用场景\n\n在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。\n\n```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"主线程运行开始!\");\n        Thread1 mTh1=new Thread1(\"A\");\n        Thread1 mTh2=new Thread1(\"B\");\n        mTh1.start();\n        mTh2.start();\n        try {\n            mTh1.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        try {\n            mTh2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"主线程运行结束!\");\n    }\n}\n```\n\n# yield():暂停当前正在执行的线程对象，并执行其他线程。\n\nThread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。\n\nyield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。\n\n结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。可看上面的图。\n\n# sleep()和yield()的区别\n\nsleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。\n\nsleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程\n\n另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield() 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。\n\n# wait\n\n我们可以利用wait()来让一个线程在某些条件下暂停运行。例如，在生产者消费者模型中，生产者线程在缓冲区为满的时候，消费者在缓冲区为空的时候，都应该暂停运行。如果某些线程在等待某些条件触发，那当那些条件为真时，你可以用 notify 和 notifyAll 来通知那些等待中的线程重新开始运行。不同之处在于，notify 仅仅通知一个线程，并且我们不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。换言之，如果只有一个线程在等待一个信号灯，notify和notifyAll都会通知到这个线程。但如果多个线程在等待这个信号灯，那么notify只会通知到其中一个，而其它线程并不会收到任何通知，而notifyAll会唤醒所有等待中的线程。\n\n我们怎么在代码里使用wait()呢？因为wait()并不是Thread类下的函数，我们并不能使用Thread.wait()。事实上很多Java程序员都喜欢这么写，因为它们习惯了使用Thread.sleep()，所以他们会试图使用wait() 来达成相同的目的，但很快他们就会发现这并不能顺利解决问题。正确的方法是对在多线程间共享的那个Object来使用wait。在生产者消费者问题中，这个共享的Object就是那个缓冲区队列。\n\n既然我们应该在synchronized的函数或是对象里调用wait，那哪个对象应该被synchronized呢？答案是，那个你希望上锁的对象就应该被synchronized，即那个在多个线程间被共享的对象。在生产者消费者问题中，应该被synchronized的就是那个缓冲区队列。\n\n## 永远在循环（loop）里调用 wait 和 notify，不是在 If 语句\n\n现在你知道wait应该永远在被synchronized的背景下和那个被多线程共享的对象上调用，下一个一定要记住的问题就是，你应该永远在while循环，而不是if语句中调用wait。因为线程是在某些条件下等待的——在我们的例子里，即“如果缓冲区队列是满的话，那么生产者线程应该等待”，你可能直觉就会写一个if语句。但if语句存在一些微妙的小问题即使条件没被满足，你的线程你也有可能被错误地唤醒。所以如果你不在线程被唤醒后再次使用while循环检查唤醒条件是否被满足，你的程序就有可能会出错——例如在缓冲区为满的时候生产者继续生成数据，或者缓冲区为空的时候消费者开始消耗数据。所以记住，永远在while循环而不是if语句中使用wait！\n\n在while循环里使用wait的目的，是在线程被唤醒的前后都持续检查条件是否被满足。如果条件并未改变，wait被调用之前notify的唤醒通知就来了，那么这个线程并不能保证被唤醒，有可能会导致死锁问题。\n\n下面我们提供一个使用wait和notify的范例程序。在这个程序里，我们使用了上文所述的一些代码规范。我们有两个线程，分别名为PRODUCER（生产者）和CONSUMER（消费者），他们分别继承了了Producer和Consumer类，而Producer和Consumer都继承了Thread类。Producer和Consumer想要实现的代码逻辑都在run()函数内。Main线程开始了生产者和消费者线程，并声明了一个LinkedList作为缓冲区队列（在Java中，LinkedList实现了队列的接口）。生产者在无限循环中持续往LinkedList里插入随机整数直到LinkedList满。我们在while(queue.size == maxSize)循环语句中检查这个条件。请注意到我们在做这个检查条件之前已经在队列对象上使用了synchronized关键词，因而其它线程不能在我们检查条件时改变这个队列。如果队列满了，那么PRODUCER线程会在CONSUMER线程消耗掉队列里的任意一个整数，并用notify来通知PRODUCER线程之前持续等待。在我们的例子中，wait和notify都是使用在同一个共享对象上的。\n\n```\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Random;\n/**\n* Simple Java program to demonstrate How to use wait, notify and notifyAll()\n* method in Java by solving producer consumer problem.\n*/\npublic class ProducerConsumerInJava {\n    public static void main(String args[]) {\n        System.out.println(\"How to use wait and notify method in Java\");\n        System.out.println(\"Solving Producer Consumper Problem\");\n        Queue<Integer> buffer = new LinkedList<>();\n        int maxSize = 10;\n        Thread producer = new Producer(buffer, maxSize, \"PRODUCER\");\n        Thread consumer = new Consumer(buffer, maxSize, \"CONSUMER\");\n        producer.start(); consumer.start(); }\n    }\n    /**\n    * Producer Thread will keep producing values for Consumer\n    * to consumer. It will use wait() method when Queue is full\n    * and use notify() method to send notification to Consumer\n    * Thread.\n    */\n    class Producer extends Thread\n    {\n        private Queue<Integer> queue;\n        private int maxSize;\n        public Producer(Queue<Integer> queue, int maxSize, String name){\n            super(name); this.queue = queue; this.maxSize = maxSize;\n        }\n        @Override public void run()\n        {\n            while (true)\n                {\n                    synchronized (queue) {\n                        while (queue.size() == maxSize) {\n                            try {\n                                System.out .println(\"Queue is full, \" + \"Producer thread waiting for \" + \"consumer to take something from queue\");\n                                queue.wait();\n                            } catch (Exception ex) {\n                                ex.printStackTrace(); }\n                            }\n                            Random random = new Random();\n                            int i = random.nextInt();\n                            System.out.println(\"Producing value : \" + i); queue.add(i); queue.notifyAll();\n                        }\n                    }\n                }\n            }\n    /**\n    * Consumer Thread will consumer values form shared queue.\n    * It will also use wait() method to wait if queue is\n    * empty. It will also use notify method to send\n    * notification to producer thread after consuming values\n    * from queue.\n    */\n    class Consumer extends Thread {\n        private Queue<Integer> queue;\n        private int maxSize;\n        public Consumer(Queue<Integer> queue, int maxSize, String name){\n            super(name);\n            this.queue = queue;\n            this.maxSize = maxSize;\n        }\n        @Override public void run() {\n            while (true) {\n                synchronized (queue) {\n                    while (queue.isEmpty()) {\n                        System.out.println(\"Queue is empty,\" + \"Consumer thread is waiting\" + \" for producer thread to put something in queue\");\n                        try {\n                            queue.wait();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                        }\n                    }\n                    System.out.println(\"Consuming value : \" + queue.remove()); queue.notifyAll();\n                }\n            }\n        }\n    }\n```\n\n![](http://www.wailian.work/images/2018/01/23/20170805131528961.png)\n\n为了更好地理解这个程序，我建议你在debug模式里跑这个程序。一旦你在debug模式下启动程序，它会停止在PRODUCER或者CONSUMER线程上，取决于哪个线程占据了CPU。因为两个线程都有wait()的条件，它们一定会停止，然后你就可以跑这个程序然后看发生什么了（很有可能它就会输出我们以上展示的内容）。你也可以使用Eclipse里的Step into和Step over按钮来更好地理解多线程间发生的事情。\n\n# 阻塞队列实现生产者消费者问题\n\n```\npublic class ProducerConsumerWithQueue {\n    private int queueSize = 10;\n    private ArrayBlockingQueue<Integer> queue = new ArrayBlockingQueue<Integer>(queueSize);\n\n    public static void main(String[] args) {\n        ProducerConsumerWithQueue test = new ProducerConsumerWithQueue();\n        Producer producer = test.new Producer();\n        Consumer consumer = test.new Consumer();\n\n        producer.start();\n        consumer.start();\n    }\n\n    class Consumer extends Thread {\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    queue.take();\n                    System.out.println(\"从队列取走一个元素，队列剩余\" + queue.size() + \"个元素\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    class Producer extends Thread {\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    queue.put(1);\n                    System.out.println(\"向队列取中插入一个元素，队列剩余空间：\" + (queueSize - queue.size()));\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n## 附：阻塞队列的四种处理方法\n\n| 方法\\处理方式| 抛出异常    |  返回特殊值  |一直阻塞|超时退出\n| --------   | -----:   | :----: |\n|插入方法 | add(e)      |   offer(e)    |put(e)|offer(e,time,unit)\n| 移除方法| remove()|poll()|take()|poll(time,unit)\n| 检查方法| element()|  peek()    |不可用|不可用\n\n# 另一个例子\n\n```\n/**\n* 计算输出其他线程锁计算的数据\n*\n*/\npublic class ThreadA {\n    public static void main(String[] args) throws InterruptedException{\n        ThreadB b = new ThreadB();\n        //启动计算线程\n        b.start();\n        //线程A拥有b对象上的锁。线程为了调用wait()或notify()方法，该线程必须是那个对象锁的拥有者\n        synchronized (b) {\n            System.out.println(\"等待对象b完成计算。。。\");\n            //当前线程A等待\n            b.wait();\n            System.out.println(\"b对象计算的总和是：\" + b.total);\n        }\n    }\n}\n\n\n\n/**\n* 计算1+2+3 ... +100的和\n*\n*/\nclass ThreadB extends Thread {\n    int total;\n\n    public void run() {\n        synchronized (this) {\n            for (int i = 0; i < 101; i++) {\n                total += i;\n            }\n            //（完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程A被唤醒\n            notify();\n            System.out.println(\"计算完成\");\n        }\n    }\n}\n```\n\n执行结果：\n\n等待对象b完成计算。。。\n计算完成\nb对象计算的总和是：5050\n\n如果我们将b.wait()去掉呢？结果如下：\n\n等待对象b完成计算。。。\nb对象计算的总和是：0\n计算完成\n\n上述的结果表明，当去掉b.wait()时，新启动的线程ThreadB与主线程ThreadA是各自执行的，没有线程等待的现象。\n\n我们想要的效果是，当线程ThreadB完成计算之后，再去取计算后的结果。所以使用了b.wait()来让主线程等待。\n\n那为什么是使用b.wait()，而不是Thread.currentThread.wait()，或者其他的呢？\n\n如果我们将b.wait()替换成Thread.currentThread.wait()，将会得到如下的结果：\n\nException in thread “main” java.lang.IllegalMonitorStateException\nat java.lang.Object.wait(Native Method)\nat java.lang.Object.wait(Object.java:485)\nat pa.com.thread.ThreadA.main(ThreadA.java:18)\n等待对象b完成计算。。。\n计算完成\n\n替换的代码Thread.currentThread.wait()好像理所当然应该如我们预期的正确啊，让当前线程处于等待状态，让其他线程先执行。\n\n我们忽略了一个很重要的问题：线程与锁是分不开的，线程的同步、等待、唤醒都与对象锁是密不可分的。\n\n线程ThreadA持有对象b的锁，我们要使用这把锁去让线程释放锁，从而让其他的线程能抢到这把锁。\n\n从我们的程序来分析就是：线程ThreadA首先持有锁对象b，然后调用b.wait()将对象锁释放，线程ThreadB争抢到对象锁b，从而执行run()方法中的计算，计算完了之后使用notify()唤醒主线程ThreadA，ThreadA得以继续执行，从而得到了我们预期的效果。\n\n（之所以ThreadB的对象锁也是b，是因为synchronized(this)中的this指向的就是ThreadB的实例b）\n\nThread.currentThread.wait()调用的是当前线程对象（即主线程ThreadA）的wait()方法，当前线程对象ThreadA是没有被加锁的，它只是获取了对象锁b。我基本没有看到过这样的调用，一般使用的是锁对象的wait()，本例中为b.wait()\n\n顺带讲一下wait()与sleep()的区别。\n\n如果我们将b.wait()换成Thread.sleep(1000)，则会出现如下的结果：\n\n等待对象b完成计算。。。\nb对象计算的总和是：0\n计算完成\n\n从执行结果可以看出，Thread.sleep(1000)只是让主线程ThreadA睡眠了1秒钟，而并没有释放对象锁，所以在主线程ThreadA睡眠的过程中，ThreadB拿不到对象锁，从而不能执行。\n\n所以我们也就得出了如下的结论：\n\nwait()方法是让线程释放对象锁，让其他线程拿到锁之后去优先执行，当其他全程唤醒wait()中的线程 或者 拿到对象锁的线程都执行完释放了对象锁之后，wait()中的线程才会再次拿到对象锁从而执行。\n\nsleep()方法是让线程睡眠，此时并没有释放对象锁，其他想要拿到睡眠线程的对象锁的线程也就拿不到相应的对象锁，从而不能抢在它前面执行。\n\n补：\n\nwait、notify和notifyAll方法是Object类的final native方法。所以这些方法不能被子类重写，Object类是所有类的超类，因此在程序中有以下三种形式调用wait等方法。\n\n```\nwait();//方式1：\nthis.wait();//方式2：\nsuper.wait();//方式3\n```\n\nvoid wait()\n\n导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。\n\n# synchronized\n\n卖火车票问题\n\n```\npublic class Seller implements Runnable {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        synchronized (this) {\n            if (Synchronized.ticket > 0) {\n                System.out.println(\"正在卖票,剩余\" + Synchronized.ticket);\n                Synchronized.ticket--;\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n```\npublic class Synchronized {\n    static Integer ticket = 100;\n\n    public static void main(String[] args) {\n        Seller s = new Seller();\n        Thread t1 = new Thread(s);\n        Thread t2 = new Thread(s);\n        Thread t3 = new Thread(s);\n        Thread t4 = new Thread(s);\n        Thread t5 = new Thread(s);\n        Thread t6 = new Thread(s);\n\n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n        t6.start();\n    }\n}\n```\n\n[源码地址](https://github.com/wangweiye01/mutiThreading)\n","slug":"java-thread","published":1,"updated":"2019-12-24T02:00:57.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n3k5w00250j9k18tfkz2o","content":"<p><img src=\"http://www.wailian.work/images/2018/01/23/60f198516cee4ab511cb190a85599d3e1d88302a4d1ba-iBehXn_fw658.jpg\" alt=\"pic\"></p>\n<h1 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h1><p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>\n<h1 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h1><h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><p>当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新建状态时，程序还没有开始运行线程中的代码</p>\n<h2 id=\"就绪\"><a href=\"#就绪\" class=\"headerlink\" title=\"就绪\"></a>就绪</h2><p>一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。此时线程中代码仍未运行</p>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>当线程获得CPU后，它才进入运行状态，真正开始执行run()方法中的代码</p>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><p>该线程放弃CPU的使用，暂停运行</p>\n<p>常见线程阻塞的原因:</p>\n<ol>\n<li><p>线程执行了Thread.sleep(int millsecond)方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行</p>\n</li>\n<li><p>线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行</p>\n</li>\n<li><p>线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法</p>\n</li>\n<li><p>线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态</p>\n</li>\n</ol>\n<h2 id=\"终止\"><a href=\"#终止\" class=\"headerlink\" title=\"终止\"></a>终止</h2><p>线程执行完毕</p>\n<h1 id=\"线程的创建方法\"><a href=\"#线程的创建方法\" class=\"headerlink\" title=\"线程的创建方法\"></a>线程的创建方法</h1><h2 id=\"继承Thread类\"><a href=\"#继承Thread类\" class=\"headerlink\" title=\"继承Thread类\"></a>继承Thread类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Thread1 extends Thread &#123;</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        // 线程执行代码</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Thread1 mTh1=new Thread1();</span><br><span class=\"line\">        Thread1 mTh2=new Thread1();</span><br><span class=\"line\">        mTh1.start();</span><br><span class=\"line\">        mTh2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用main的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行</p>\n<p>注意：<br>start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。</p>\n<p>从程序运行的结果可以发现，多线程程序是乱序执行。</p>\n<p>Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。</p>\n<p>实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。</p>\n<h2 id=\"实现Runable接口-推荐\"><a href=\"#实现Runable接口-推荐\" class=\"headerlink\" title=\"实现Runable接口(推荐)\"></a>实现Runable接口(推荐)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Thread2 implements Runnable&#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Thread2(String name) &#123;</span><br><span class=\"line\">        this.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">    // 线程逻辑代码</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new Thread(new Thread2(&quot;C&quot;)).start();</span><br><span class=\"line\">        new Thread(new Thread2(&quot;D&quot;)).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"两种方法的区别\"><a href=\"#两种方法的区别\" class=\"headerlink\" title=\"两种方法的区别\"></a>两种方法的区别</h2><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p>\n<p>总结：<br>实现Runnable接口比继承Thread类所具有的优势：</p>\n<ol>\n<li>适合多个相同的程序代码的线程去处理同一个资源 </li>\n<li>可以避免java中的单继承的限制</li>\n<li>增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</li>\n<li>线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</li>\n</ol>\n<p>提醒一下大家：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。</p>\n<p>在Java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际就是在操作系统中启动了一个进程。</p>\n<h1 id=\"线程状态-1\"><a href=\"#线程状态-1\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h1><p><img src=\"http://www.wailian.work/images/2018/01/23/20170717150938439.jpg\" alt=\"\"></p>\n<h1 id=\"线程调度\"><a href=\"#线程调度\" class=\"headerlink\" title=\"线程调度\"></a>线程调度</h1><p>Java线程有优先级，优先级高的线程会优先获得运行机会(但不一定优先级高的一定先执行)<br>Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int MAX_PRIORITY  = 10;  //线程可以具有的最高优先级</span><br><span class=\"line\">static int MIN_PRIORITY  = 1;   //线程可以具有的最低优先级</span><br><span class=\"line\">static int NORM_PRIORITY = 5;   //分配给线程的默认优先级</span><br></pre></td></tr></table></figure>\n<p>Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。</p>\n<h1 id=\"线程睡眠\"><a href=\"#线程睡眠\" class=\"headerlink\" title=\"线程睡眠\"></a>线程睡眠</h1><p>Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p>\n<h1 id=\"线程等待\"><a href=\"#线程等待\" class=\"headerlink\" title=\"线程等待\"></a>线程等待</h1><p>Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。</p>\n<h1 id=\"线程让步\"><a href=\"#线程让步\" class=\"headerlink\" title=\"线程让步\"></a>线程让步</h1><p>Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p>\n<h1 id=\"线程加入\"><a href=\"#线程加入\" class=\"headerlink\" title=\"线程加入\"></a>线程加入</h1><p>join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p>\n<h1 id=\"线程唤醒\"><a href=\"#线程唤醒\" class=\"headerlink\" title=\"线程唤醒\"></a>线程唤醒</h1><p>Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</p>\n<p>注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。</p>\n<h1 id=\"常用函数说明\"><a href=\"#常用函数说明\" class=\"headerlink\" title=\"常用函数说明\"></a>常用函数说明</h1><h2 id=\"sleep-long-millis\"><a href=\"#sleep-long-millis\" class=\"headerlink\" title=\"sleep(long millis)\"></a>sleep(long millis)</h2><p>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</p>\n<h1 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h1><p>join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        System.out.println(&quot;主线程运行开始!&quot;);</span><br><span class=\"line\">        Thread1 mTh1=new Thread1(&quot;A&quot;);</span><br><span class=\"line\">        Thread1 mTh2=new Thread1(&quot;B&quot;);</span><br><span class=\"line\">        mTh1.start();</span><br><span class=\"line\">        mTh2.start();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mTh1.join();</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mTh2.join();</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;主线程运行结束!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"yield-暂停当前正在执行的线程对象，并执行其他线程。\"><a href=\"#yield-暂停当前正在执行的线程对象，并执行其他线程。\" class=\"headerlink\" title=\"yield():暂停当前正在执行的线程对象，并执行其他线程。\"></a>yield():暂停当前正在执行的线程对象，并执行其他线程。</h1><p>Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。</p>\n<p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>\n<p>结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。可看上面的图。</p>\n<h1 id=\"sleep-和yield-的区别\"><a href=\"#sleep-和yield-的区别\" class=\"headerlink\" title=\"sleep()和yield()的区别\"></a>sleep()和yield()的区别</h1><p>sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</p>\n<p>sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程</p>\n<p>另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield() 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。</p>\n<h1 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h1><p>我们可以利用wait()来让一个线程在某些条件下暂停运行。例如，在生产者消费者模型中，生产者线程在缓冲区为满的时候，消费者在缓冲区为空的时候，都应该暂停运行。如果某些线程在等待某些条件触发，那当那些条件为真时，你可以用 notify 和 notifyAll 来通知那些等待中的线程重新开始运行。不同之处在于，notify 仅仅通知一个线程，并且我们不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。换言之，如果只有一个线程在等待一个信号灯，notify和notifyAll都会通知到这个线程。但如果多个线程在等待这个信号灯，那么notify只会通知到其中一个，而其它线程并不会收到任何通知，而notifyAll会唤醒所有等待中的线程。</p>\n<p>我们怎么在代码里使用wait()呢？因为wait()并不是Thread类下的函数，我们并不能使用Thread.wait()。事实上很多Java程序员都喜欢这么写，因为它们习惯了使用Thread.sleep()，所以他们会试图使用wait() 来达成相同的目的，但很快他们就会发现这并不能顺利解决问题。正确的方法是对在多线程间共享的那个Object来使用wait。在生产者消费者问题中，这个共享的Object就是那个缓冲区队列。</p>\n<p>既然我们应该在synchronized的函数或是对象里调用wait，那哪个对象应该被synchronized呢？答案是，那个你希望上锁的对象就应该被synchronized，即那个在多个线程间被共享的对象。在生产者消费者问题中，应该被synchronized的就是那个缓冲区队列。</p>\n<h2 id=\"永远在循环（loop）里调用-wait-和-notify，不是在-If-语句\"><a href=\"#永远在循环（loop）里调用-wait-和-notify，不是在-If-语句\" class=\"headerlink\" title=\"永远在循环（loop）里调用 wait 和 notify，不是在 If 语句\"></a>永远在循环（loop）里调用 wait 和 notify，不是在 If 语句</h2><p>现在你知道wait应该永远在被synchronized的背景下和那个被多线程共享的对象上调用，下一个一定要记住的问题就是，你应该永远在while循环，而不是if语句中调用wait。因为线程是在某些条件下等待的——在我们的例子里，即“如果缓冲区队列是满的话，那么生产者线程应该等待”，你可能直觉就会写一个if语句。但if语句存在一些微妙的小问题即使条件没被满足，你的线程你也有可能被错误地唤醒。所以如果你不在线程被唤醒后再次使用while循环检查唤醒条件是否被满足，你的程序就有可能会出错——例如在缓冲区为满的时候生产者继续生成数据，或者缓冲区为空的时候消费者开始消耗数据。所以记住，永远在while循环而不是if语句中使用wait！</p>\n<p>在while循环里使用wait的目的，是在线程被唤醒的前后都持续检查条件是否被满足。如果条件并未改变，wait被调用之前notify的唤醒通知就来了，那么这个线程并不能保证被唤醒，有可能会导致死锁问题。</p>\n<p>下面我们提供一个使用wait和notify的范例程序。在这个程序里，我们使用了上文所述的一些代码规范。我们有两个线程，分别名为PRODUCER（生产者）和CONSUMER（消费者），他们分别继承了了Producer和Consumer类，而Producer和Consumer都继承了Thread类。Producer和Consumer想要实现的代码逻辑都在run()函数内。Main线程开始了生产者和消费者线程，并声明了一个LinkedList作为缓冲区队列（在Java中，LinkedList实现了队列的接口）。生产者在无限循环中持续往LinkedList里插入随机整数直到LinkedList满。我们在while(queue.size == maxSize)循环语句中检查这个条件。请注意到我们在做这个检查条件之前已经在队列对象上使用了synchronized关键词，因而其它线程不能在我们检查条件时改变这个队列。如果队列满了，那么PRODUCER线程会在CONSUMER线程消耗掉队列里的任意一个整数，并用notify来通知PRODUCER线程之前持续等待。在我们的例子中，wait和notify都是使用在同一个共享对象上的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.LinkedList;</span><br><span class=\"line\">import java.util.Queue;</span><br><span class=\"line\">import java.util.Random;</span><br><span class=\"line\">/**</span><br><span class=\"line\">* Simple Java program to demonstrate How to use wait, notify and notifyAll()</span><br><span class=\"line\">* method in Java by solving producer consumer problem.</span><br><span class=\"line\">*/</span><br><span class=\"line\">public class ProducerConsumerInJava &#123;</span><br><span class=\"line\">    public static void main(String args[]) &#123;</span><br><span class=\"line\">        System.out.println(&quot;How to use wait and notify method in Java&quot;);</span><br><span class=\"line\">        System.out.println(&quot;Solving Producer Consumper Problem&quot;);</span><br><span class=\"line\">        Queue&lt;Integer&gt; buffer = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        int maxSize = 10;</span><br><span class=\"line\">        Thread producer = new Producer(buffer, maxSize, &quot;PRODUCER&quot;);</span><br><span class=\"line\">        Thread consumer = new Consumer(buffer, maxSize, &quot;CONSUMER&quot;);</span><br><span class=\"line\">        producer.start(); consumer.start(); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * Producer Thread will keep producing values for Consumer</span><br><span class=\"line\">    * to consumer. It will use wait() method when Queue is full</span><br><span class=\"line\">    * and use notify() method to send notification to Consumer</span><br><span class=\"line\">    * Thread.</span><br><span class=\"line\">    */</span><br><span class=\"line\">    class Producer extends Thread</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private Queue&lt;Integer&gt; queue;</span><br><span class=\"line\">        private int maxSize;</span><br><span class=\"line\">        public Producer(Queue&lt;Integer&gt; queue, int maxSize, String name)&#123;</span><br><span class=\"line\">            super(name); this.queue = queue; this.maxSize = maxSize;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override public void run()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            while (true)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    synchronized (queue) &#123;</span><br><span class=\"line\">                        while (queue.size() == maxSize) &#123;</span><br><span class=\"line\">                            try &#123;</span><br><span class=\"line\">                                System.out .println(&quot;Queue is full, &quot; + &quot;Producer thread waiting for &quot; + &quot;consumer to take something from queue&quot;);</span><br><span class=\"line\">                                queue.wait();</span><br><span class=\"line\">                            &#125; catch (Exception ex) &#123;</span><br><span class=\"line\">                                ex.printStackTrace(); &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            Random random = new Random();</span><br><span class=\"line\">                            int i = random.nextInt();</span><br><span class=\"line\">                            System.out.println(&quot;Producing value : &quot; + i); queue.add(i); queue.notifyAll();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * Consumer Thread will consumer values form shared queue.</span><br><span class=\"line\">    * It will also use wait() method to wait if queue is</span><br><span class=\"line\">    * empty. It will also use notify method to send</span><br><span class=\"line\">    * notification to producer thread after consuming values</span><br><span class=\"line\">    * from queue.</span><br><span class=\"line\">    */</span><br><span class=\"line\">    class Consumer extends Thread &#123;</span><br><span class=\"line\">        private Queue&lt;Integer&gt; queue;</span><br><span class=\"line\">        private int maxSize;</span><br><span class=\"line\">        public Consumer(Queue&lt;Integer&gt; queue, int maxSize, String name)&#123;</span><br><span class=\"line\">            super(name);</span><br><span class=\"line\">            this.queue = queue;</span><br><span class=\"line\">            this.maxSize = maxSize;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override public void run() &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                synchronized (queue) &#123;</span><br><span class=\"line\">                    while (queue.isEmpty()) &#123;</span><br><span class=\"line\">                        System.out.println(&quot;Queue is empty,&quot; + &quot;Consumer thread is waiting&quot; + &quot; for producer thread to put something in queue&quot;);</span><br><span class=\"line\">                        try &#123;</span><br><span class=\"line\">                            queue.wait();</span><br><span class=\"line\">                        &#125; catch (Exception ex) &#123;</span><br><span class=\"line\">                            ex.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    System.out.println(&quot;Consuming value : &quot; + queue.remove()); queue.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/01/23/20170805131528961.png\" alt=\"\"></p>\n<p>为了更好地理解这个程序，我建议你在debug模式里跑这个程序。一旦你在debug模式下启动程序，它会停止在PRODUCER或者CONSUMER线程上，取决于哪个线程占据了CPU。因为两个线程都有wait()的条件，它们一定会停止，然后你就可以跑这个程序然后看发生什么了（很有可能它就会输出我们以上展示的内容）。你也可以使用Eclipse里的Step into和Step over按钮来更好地理解多线程间发生的事情。</p>\n<h1 id=\"阻塞队列实现生产者消费者问题\"><a href=\"#阻塞队列实现生产者消费者问题\" class=\"headerlink\" title=\"阻塞队列实现生产者消费者问题\"></a>阻塞队列实现生产者消费者问题</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ProducerConsumerWithQueue &#123;</span><br><span class=\"line\">    private int queueSize = 10;</span><br><span class=\"line\">    private ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(queueSize);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ProducerConsumerWithQueue test = new ProducerConsumerWithQueue();</span><br><span class=\"line\">        Producer producer = test.new Producer();</span><br><span class=\"line\">        Consumer consumer = test.new Consumer();</span><br><span class=\"line\"></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Consumer extends Thread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    queue.take();</span><br><span class=\"line\">                    System.out.println(&quot;从队列取走一个元素，队列剩余&quot; + queue.size() + &quot;个元素&quot;);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Producer extends Thread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    queue.put(1);</span><br><span class=\"line\">                    System.out.println(&quot;向队列取中插入一个元素，队列剩余空间：&quot; + (queueSize - queue.size()));</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"附：阻塞队列的四种处理方法\"><a href=\"#附：阻塞队列的四种处理方法\" class=\"headerlink\" title=\"附：阻塞队列的四种处理方法\"></a>附：阻塞队列的四种处理方法</h2><table>\n<thead>\n<tr>\n<th>方法\\处理方式</th>\n<th style=\"text-align:right\">抛出异常</th>\n<th style=\"text-align:center\">返回特殊值</th>\n<th>一直阻塞</th>\n<th>超时退出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插入方法</td>\n<td style=\"text-align:right\">add(e)</td>\n<td style=\"text-align:center\">offer(e)</td>\n<td>put(e)</td>\n<td>offer(e,time,unit)</td>\n</tr>\n<tr>\n<td>移除方法</td>\n<td style=\"text-align:right\">remove()</td>\n<td style=\"text-align:center\">poll()</td>\n<td>take()</td>\n<td>poll(time,unit)</td>\n</tr>\n<tr>\n<td>检查方法</td>\n<td style=\"text-align:right\">element()</td>\n<td style=\"text-align:center\">peek()</td>\n<td>不可用</td>\n<td>不可用</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"另一个例子\"><a href=\"#另一个例子\" class=\"headerlink\" title=\"另一个例子\"></a>另一个例子</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* 计算输出其他线程锁计算的数据</span><br><span class=\"line\">*</span><br><span class=\"line\">*/</span><br><span class=\"line\">public class ThreadA &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class=\"line\">        ThreadB b = new ThreadB();</span><br><span class=\"line\">        //启动计算线程</span><br><span class=\"line\">        b.start();</span><br><span class=\"line\">        //线程A拥有b对象上的锁。线程为了调用wait()或notify()方法，该线程必须是那个对象锁的拥有者</span><br><span class=\"line\">        synchronized (b) &#123;</span><br><span class=\"line\">            System.out.println(&quot;等待对象b完成计算。。。&quot;);</span><br><span class=\"line\">            //当前线程A等待</span><br><span class=\"line\">            b.wait();</span><br><span class=\"line\">            System.out.println(&quot;b对象计算的总和是：&quot; + b.total);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 计算1+2+3 ... +100的和</span><br><span class=\"line\">*</span><br><span class=\"line\">*/</span><br><span class=\"line\">class ThreadB extends Thread &#123;</span><br><span class=\"line\">    int total;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        synchronized (this) &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; 101; i++) &#123;</span><br><span class=\"line\">                total += i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //（完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程A被唤醒</span><br><span class=\"line\">            notify();</span><br><span class=\"line\">            System.out.println(&quot;计算完成&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<p>等待对象b完成计算。。。<br>计算完成<br>b对象计算的总和是：5050</p>\n<p>如果我们将b.wait()去掉呢？结果如下：</p>\n<p>等待对象b完成计算。。。<br>b对象计算的总和是：0<br>计算完成</p>\n<p>上述的结果表明，当去掉b.wait()时，新启动的线程ThreadB与主线程ThreadA是各自执行的，没有线程等待的现象。</p>\n<p>我们想要的效果是，当线程ThreadB完成计算之后，再去取计算后的结果。所以使用了b.wait()来让主线程等待。</p>\n<p>那为什么是使用b.wait()，而不是Thread.currentThread.wait()，或者其他的呢？</p>\n<p>如果我们将b.wait()替换成Thread.currentThread.wait()，将会得到如下的结果：</p>\n<p>Exception in thread “main” java.lang.IllegalMonitorStateException<br>at java.lang.Object.wait(Native Method)<br>at java.lang.Object.wait(Object.java:485)<br>at pa.com.thread.ThreadA.main(ThreadA.java:18)<br>等待对象b完成计算。。。<br>计算完成</p>\n<p>替换的代码Thread.currentThread.wait()好像理所当然应该如我们预期的正确啊，让当前线程处于等待状态，让其他线程先执行。</p>\n<p>我们忽略了一个很重要的问题：线程与锁是分不开的，线程的同步、等待、唤醒都与对象锁是密不可分的。</p>\n<p>线程ThreadA持有对象b的锁，我们要使用这把锁去让线程释放锁，从而让其他的线程能抢到这把锁。</p>\n<p>从我们的程序来分析就是：线程ThreadA首先持有锁对象b，然后调用b.wait()将对象锁释放，线程ThreadB争抢到对象锁b，从而执行run()方法中的计算，计算完了之后使用notify()唤醒主线程ThreadA，ThreadA得以继续执行，从而得到了我们预期的效果。</p>\n<p>（之所以ThreadB的对象锁也是b，是因为synchronized(this)中的this指向的就是ThreadB的实例b）</p>\n<p>Thread.currentThread.wait()调用的是当前线程对象（即主线程ThreadA）的wait()方法，当前线程对象ThreadA是没有被加锁的，它只是获取了对象锁b。我基本没有看到过这样的调用，一般使用的是锁对象的wait()，本例中为b.wait()</p>\n<p>顺带讲一下wait()与sleep()的区别。</p>\n<p>如果我们将b.wait()换成Thread.sleep(1000)，则会出现如下的结果：</p>\n<p>等待对象b完成计算。。。<br>b对象计算的总和是：0<br>计算完成</p>\n<p>从执行结果可以看出，Thread.sleep(1000)只是让主线程ThreadA睡眠了1秒钟，而并没有释放对象锁，所以在主线程ThreadA睡眠的过程中，ThreadB拿不到对象锁，从而不能执行。</p>\n<p>所以我们也就得出了如下的结论：</p>\n<p>wait()方法是让线程释放对象锁，让其他线程拿到锁之后去优先执行，当其他全程唤醒wait()中的线程 或者 拿到对象锁的线程都执行完释放了对象锁之后，wait()中的线程才会再次拿到对象锁从而执行。</p>\n<p>sleep()方法是让线程睡眠，此时并没有释放对象锁，其他想要拿到睡眠线程的对象锁的线程也就拿不到相应的对象锁，从而不能抢在它前面执行。</p>\n<p>补：</p>\n<p>wait、notify和notifyAll方法是Object类的final native方法。所以这些方法不能被子类重写，Object类是所有类的超类，因此在程序中有以下三种形式调用wait等方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wait();//方式1：</span><br><span class=\"line\">this.wait();//方式2：</span><br><span class=\"line\">super.wait();//方式3</span><br></pre></td></tr></table></figure>\n<p>void wait()</p>\n<p>导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。</p>\n<h1 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h1><p>卖火车票问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Seller implements Runnable &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        synchronized (this) &#123;</span><br><span class=\"line\">            if (Synchronized.ticket &gt; 0) &#123;</span><br><span class=\"line\">                System.out.println(&quot;正在卖票,剩余&quot; + Synchronized.ticket);</span><br><span class=\"line\">                Synchronized.ticket--;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(100);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Synchronized &#123;</span><br><span class=\"line\">    static Integer ticket = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Seller s = new Seller();</span><br><span class=\"line\">        Thread t1 = new Thread(s);</span><br><span class=\"line\">        Thread t2 = new Thread(s);</span><br><span class=\"line\">        Thread t3 = new Thread(s);</span><br><span class=\"line\">        Thread t4 = new Thread(s);</span><br><span class=\"line\">        Thread t5 = new Thread(s);</span><br><span class=\"line\">        Thread t6 = new Thread(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        t3.start();</span><br><span class=\"line\">        t4.start();</span><br><span class=\"line\">        t5.start();</span><br><span class=\"line\">        t6.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/wangweiye01/mutiThreading\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.wailian.work/images/2018/01/23/60f198516cee4ab511cb190a85599d3e1d88302a4d1ba-iBehXn_fw658.jpg\" alt=\"pic\"></p>\n<h1 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h1><p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>\n<h1 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h1><h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><p>当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新建状态时，程序还没有开始运行线程中的代码</p>\n<h2 id=\"就绪\"><a href=\"#就绪\" class=\"headerlink\" title=\"就绪\"></a>就绪</h2><p>一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。此时线程中代码仍未运行</p>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>当线程获得CPU后，它才进入运行状态，真正开始执行run()方法中的代码</p>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><p>该线程放弃CPU的使用，暂停运行</p>\n<p>常见线程阻塞的原因:</p>\n<ol>\n<li><p>线程执行了Thread.sleep(int millsecond)方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行</p>\n</li>\n<li><p>线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行</p>\n</li>\n<li><p>线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法</p>\n</li>\n<li><p>线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态</p>\n</li>\n</ol>\n<h2 id=\"终止\"><a href=\"#终止\" class=\"headerlink\" title=\"终止\"></a>终止</h2><p>线程执行完毕</p>\n<h1 id=\"线程的创建方法\"><a href=\"#线程的创建方法\" class=\"headerlink\" title=\"线程的创建方法\"></a>线程的创建方法</h1><h2 id=\"继承Thread类\"><a href=\"#继承Thread类\" class=\"headerlink\" title=\"继承Thread类\"></a>继承Thread类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Thread1 extends Thread &#123;</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        // 线程执行代码</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Thread1 mTh1=new Thread1();</span><br><span class=\"line\">        Thread1 mTh2=new Thread1();</span><br><span class=\"line\">        mTh1.start();</span><br><span class=\"line\">        mTh2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用main的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行</p>\n<p>注意：<br>start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。</p>\n<p>从程序运行的结果可以发现，多线程程序是乱序执行。</p>\n<p>Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。</p>\n<p>实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。</p>\n<h2 id=\"实现Runable接口-推荐\"><a href=\"#实现Runable接口-推荐\" class=\"headerlink\" title=\"实现Runable接口(推荐)\"></a>实现Runable接口(推荐)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Thread2 implements Runnable&#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Thread2(String name) &#123;</span><br><span class=\"line\">        this.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">    // 线程逻辑代码</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new Thread(new Thread2(&quot;C&quot;)).start();</span><br><span class=\"line\">        new Thread(new Thread2(&quot;D&quot;)).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"两种方法的区别\"><a href=\"#两种方法的区别\" class=\"headerlink\" title=\"两种方法的区别\"></a>两种方法的区别</h2><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p>\n<p>总结：<br>实现Runnable接口比继承Thread类所具有的优势：</p>\n<ol>\n<li>适合多个相同的程序代码的线程去处理同一个资源 </li>\n<li>可以避免java中的单继承的限制</li>\n<li>增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</li>\n<li>线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</li>\n</ol>\n<p>提醒一下大家：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。</p>\n<p>在Java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际就是在操作系统中启动了一个进程。</p>\n<h1 id=\"线程状态-1\"><a href=\"#线程状态-1\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h1><p><img src=\"http://www.wailian.work/images/2018/01/23/20170717150938439.jpg\" alt=\"\"></p>\n<h1 id=\"线程调度\"><a href=\"#线程调度\" class=\"headerlink\" title=\"线程调度\"></a>线程调度</h1><p>Java线程有优先级，优先级高的线程会优先获得运行机会(但不一定优先级高的一定先执行)<br>Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int MAX_PRIORITY  = 10;  //线程可以具有的最高优先级</span><br><span class=\"line\">static int MIN_PRIORITY  = 1;   //线程可以具有的最低优先级</span><br><span class=\"line\">static int NORM_PRIORITY = 5;   //分配给线程的默认优先级</span><br></pre></td></tr></table></figure>\n<p>Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。</p>\n<h1 id=\"线程睡眠\"><a href=\"#线程睡眠\" class=\"headerlink\" title=\"线程睡眠\"></a>线程睡眠</h1><p>Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p>\n<h1 id=\"线程等待\"><a href=\"#线程等待\" class=\"headerlink\" title=\"线程等待\"></a>线程等待</h1><p>Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。</p>\n<h1 id=\"线程让步\"><a href=\"#线程让步\" class=\"headerlink\" title=\"线程让步\"></a>线程让步</h1><p>Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p>\n<h1 id=\"线程加入\"><a href=\"#线程加入\" class=\"headerlink\" title=\"线程加入\"></a>线程加入</h1><p>join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p>\n<h1 id=\"线程唤醒\"><a href=\"#线程唤醒\" class=\"headerlink\" title=\"线程唤醒\"></a>线程唤醒</h1><p>Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</p>\n<p>注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。</p>\n<h1 id=\"常用函数说明\"><a href=\"#常用函数说明\" class=\"headerlink\" title=\"常用函数说明\"></a>常用函数说明</h1><h2 id=\"sleep-long-millis\"><a href=\"#sleep-long-millis\" class=\"headerlink\" title=\"sleep(long millis)\"></a>sleep(long millis)</h2><p>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</p>\n<h1 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h1><p>join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        System.out.println(&quot;主线程运行开始!&quot;);</span><br><span class=\"line\">        Thread1 mTh1=new Thread1(&quot;A&quot;);</span><br><span class=\"line\">        Thread1 mTh2=new Thread1(&quot;B&quot;);</span><br><span class=\"line\">        mTh1.start();</span><br><span class=\"line\">        mTh2.start();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mTh1.join();</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mTh2.join();</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;主线程运行结束!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"yield-暂停当前正在执行的线程对象，并执行其他线程。\"><a href=\"#yield-暂停当前正在执行的线程对象，并执行其他线程。\" class=\"headerlink\" title=\"yield():暂停当前正在执行的线程对象，并执行其他线程。\"></a>yield():暂停当前正在执行的线程对象，并执行其他线程。</h1><p>Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。</p>\n<p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>\n<p>结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。可看上面的图。</p>\n<h1 id=\"sleep-和yield-的区别\"><a href=\"#sleep-和yield-的区别\" class=\"headerlink\" title=\"sleep()和yield()的区别\"></a>sleep()和yield()的区别</h1><p>sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</p>\n<p>sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程</p>\n<p>另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield() 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。</p>\n<h1 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h1><p>我们可以利用wait()来让一个线程在某些条件下暂停运行。例如，在生产者消费者模型中，生产者线程在缓冲区为满的时候，消费者在缓冲区为空的时候，都应该暂停运行。如果某些线程在等待某些条件触发，那当那些条件为真时，你可以用 notify 和 notifyAll 来通知那些等待中的线程重新开始运行。不同之处在于，notify 仅仅通知一个线程，并且我们不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。换言之，如果只有一个线程在等待一个信号灯，notify和notifyAll都会通知到这个线程。但如果多个线程在等待这个信号灯，那么notify只会通知到其中一个，而其它线程并不会收到任何通知，而notifyAll会唤醒所有等待中的线程。</p>\n<p>我们怎么在代码里使用wait()呢？因为wait()并不是Thread类下的函数，我们并不能使用Thread.wait()。事实上很多Java程序员都喜欢这么写，因为它们习惯了使用Thread.sleep()，所以他们会试图使用wait() 来达成相同的目的，但很快他们就会发现这并不能顺利解决问题。正确的方法是对在多线程间共享的那个Object来使用wait。在生产者消费者问题中，这个共享的Object就是那个缓冲区队列。</p>\n<p>既然我们应该在synchronized的函数或是对象里调用wait，那哪个对象应该被synchronized呢？答案是，那个你希望上锁的对象就应该被synchronized，即那个在多个线程间被共享的对象。在生产者消费者问题中，应该被synchronized的就是那个缓冲区队列。</p>\n<h2 id=\"永远在循环（loop）里调用-wait-和-notify，不是在-If-语句\"><a href=\"#永远在循环（loop）里调用-wait-和-notify，不是在-If-语句\" class=\"headerlink\" title=\"永远在循环（loop）里调用 wait 和 notify，不是在 If 语句\"></a>永远在循环（loop）里调用 wait 和 notify，不是在 If 语句</h2><p>现在你知道wait应该永远在被synchronized的背景下和那个被多线程共享的对象上调用，下一个一定要记住的问题就是，你应该永远在while循环，而不是if语句中调用wait。因为线程是在某些条件下等待的——在我们的例子里，即“如果缓冲区队列是满的话，那么生产者线程应该等待”，你可能直觉就会写一个if语句。但if语句存在一些微妙的小问题即使条件没被满足，你的线程你也有可能被错误地唤醒。所以如果你不在线程被唤醒后再次使用while循环检查唤醒条件是否被满足，你的程序就有可能会出错——例如在缓冲区为满的时候生产者继续生成数据，或者缓冲区为空的时候消费者开始消耗数据。所以记住，永远在while循环而不是if语句中使用wait！</p>\n<p>在while循环里使用wait的目的，是在线程被唤醒的前后都持续检查条件是否被满足。如果条件并未改变，wait被调用之前notify的唤醒通知就来了，那么这个线程并不能保证被唤醒，有可能会导致死锁问题。</p>\n<p>下面我们提供一个使用wait和notify的范例程序。在这个程序里，我们使用了上文所述的一些代码规范。我们有两个线程，分别名为PRODUCER（生产者）和CONSUMER（消费者），他们分别继承了了Producer和Consumer类，而Producer和Consumer都继承了Thread类。Producer和Consumer想要实现的代码逻辑都在run()函数内。Main线程开始了生产者和消费者线程，并声明了一个LinkedList作为缓冲区队列（在Java中，LinkedList实现了队列的接口）。生产者在无限循环中持续往LinkedList里插入随机整数直到LinkedList满。我们在while(queue.size == maxSize)循环语句中检查这个条件。请注意到我们在做这个检查条件之前已经在队列对象上使用了synchronized关键词，因而其它线程不能在我们检查条件时改变这个队列。如果队列满了，那么PRODUCER线程会在CONSUMER线程消耗掉队列里的任意一个整数，并用notify来通知PRODUCER线程之前持续等待。在我们的例子中，wait和notify都是使用在同一个共享对象上的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.LinkedList;</span><br><span class=\"line\">import java.util.Queue;</span><br><span class=\"line\">import java.util.Random;</span><br><span class=\"line\">/**</span><br><span class=\"line\">* Simple Java program to demonstrate How to use wait, notify and notifyAll()</span><br><span class=\"line\">* method in Java by solving producer consumer problem.</span><br><span class=\"line\">*/</span><br><span class=\"line\">public class ProducerConsumerInJava &#123;</span><br><span class=\"line\">    public static void main(String args[]) &#123;</span><br><span class=\"line\">        System.out.println(&quot;How to use wait and notify method in Java&quot;);</span><br><span class=\"line\">        System.out.println(&quot;Solving Producer Consumper Problem&quot;);</span><br><span class=\"line\">        Queue&lt;Integer&gt; buffer = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        int maxSize = 10;</span><br><span class=\"line\">        Thread producer = new Producer(buffer, maxSize, &quot;PRODUCER&quot;);</span><br><span class=\"line\">        Thread consumer = new Consumer(buffer, maxSize, &quot;CONSUMER&quot;);</span><br><span class=\"line\">        producer.start(); consumer.start(); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * Producer Thread will keep producing values for Consumer</span><br><span class=\"line\">    * to consumer. It will use wait() method when Queue is full</span><br><span class=\"line\">    * and use notify() method to send notification to Consumer</span><br><span class=\"line\">    * Thread.</span><br><span class=\"line\">    */</span><br><span class=\"line\">    class Producer extends Thread</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private Queue&lt;Integer&gt; queue;</span><br><span class=\"line\">        private int maxSize;</span><br><span class=\"line\">        public Producer(Queue&lt;Integer&gt; queue, int maxSize, String name)&#123;</span><br><span class=\"line\">            super(name); this.queue = queue; this.maxSize = maxSize;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override public void run()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            while (true)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    synchronized (queue) &#123;</span><br><span class=\"line\">                        while (queue.size() == maxSize) &#123;</span><br><span class=\"line\">                            try &#123;</span><br><span class=\"line\">                                System.out .println(&quot;Queue is full, &quot; + &quot;Producer thread waiting for &quot; + &quot;consumer to take something from queue&quot;);</span><br><span class=\"line\">                                queue.wait();</span><br><span class=\"line\">                            &#125; catch (Exception ex) &#123;</span><br><span class=\"line\">                                ex.printStackTrace(); &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            Random random = new Random();</span><br><span class=\"line\">                            int i = random.nextInt();</span><br><span class=\"line\">                            System.out.println(&quot;Producing value : &quot; + i); queue.add(i); queue.notifyAll();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * Consumer Thread will consumer values form shared queue.</span><br><span class=\"line\">    * It will also use wait() method to wait if queue is</span><br><span class=\"line\">    * empty. It will also use notify method to send</span><br><span class=\"line\">    * notification to producer thread after consuming values</span><br><span class=\"line\">    * from queue.</span><br><span class=\"line\">    */</span><br><span class=\"line\">    class Consumer extends Thread &#123;</span><br><span class=\"line\">        private Queue&lt;Integer&gt; queue;</span><br><span class=\"line\">        private int maxSize;</span><br><span class=\"line\">        public Consumer(Queue&lt;Integer&gt; queue, int maxSize, String name)&#123;</span><br><span class=\"line\">            super(name);</span><br><span class=\"line\">            this.queue = queue;</span><br><span class=\"line\">            this.maxSize = maxSize;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override public void run() &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                synchronized (queue) &#123;</span><br><span class=\"line\">                    while (queue.isEmpty()) &#123;</span><br><span class=\"line\">                        System.out.println(&quot;Queue is empty,&quot; + &quot;Consumer thread is waiting&quot; + &quot; for producer thread to put something in queue&quot;);</span><br><span class=\"line\">                        try &#123;</span><br><span class=\"line\">                            queue.wait();</span><br><span class=\"line\">                        &#125; catch (Exception ex) &#123;</span><br><span class=\"line\">                            ex.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    System.out.println(&quot;Consuming value : &quot; + queue.remove()); queue.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.wailian.work/images/2018/01/23/20170805131528961.png\" alt=\"\"></p>\n<p>为了更好地理解这个程序，我建议你在debug模式里跑这个程序。一旦你在debug模式下启动程序，它会停止在PRODUCER或者CONSUMER线程上，取决于哪个线程占据了CPU。因为两个线程都有wait()的条件，它们一定会停止，然后你就可以跑这个程序然后看发生什么了（很有可能它就会输出我们以上展示的内容）。你也可以使用Eclipse里的Step into和Step over按钮来更好地理解多线程间发生的事情。</p>\n<h1 id=\"阻塞队列实现生产者消费者问题\"><a href=\"#阻塞队列实现生产者消费者问题\" class=\"headerlink\" title=\"阻塞队列实现生产者消费者问题\"></a>阻塞队列实现生产者消费者问题</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ProducerConsumerWithQueue &#123;</span><br><span class=\"line\">    private int queueSize = 10;</span><br><span class=\"line\">    private ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(queueSize);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ProducerConsumerWithQueue test = new ProducerConsumerWithQueue();</span><br><span class=\"line\">        Producer producer = test.new Producer();</span><br><span class=\"line\">        Consumer consumer = test.new Consumer();</span><br><span class=\"line\"></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Consumer extends Thread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    queue.take();</span><br><span class=\"line\">                    System.out.println(&quot;从队列取走一个元素，队列剩余&quot; + queue.size() + &quot;个元素&quot;);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Producer extends Thread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    queue.put(1);</span><br><span class=\"line\">                    System.out.println(&quot;向队列取中插入一个元素，队列剩余空间：&quot; + (queueSize - queue.size()));</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"附：阻塞队列的四种处理方法\"><a href=\"#附：阻塞队列的四种处理方法\" class=\"headerlink\" title=\"附：阻塞队列的四种处理方法\"></a>附：阻塞队列的四种处理方法</h2><table>\n<thead>\n<tr>\n<th>方法\\处理方式</th>\n<th style=\"text-align:right\">抛出异常</th>\n<th style=\"text-align:center\">返回特殊值</th>\n<th>一直阻塞</th>\n<th>超时退出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插入方法</td>\n<td style=\"text-align:right\">add(e)</td>\n<td style=\"text-align:center\">offer(e)</td>\n<td>put(e)</td>\n<td>offer(e,time,unit)</td>\n</tr>\n<tr>\n<td>移除方法</td>\n<td style=\"text-align:right\">remove()</td>\n<td style=\"text-align:center\">poll()</td>\n<td>take()</td>\n<td>poll(time,unit)</td>\n</tr>\n<tr>\n<td>检查方法</td>\n<td style=\"text-align:right\">element()</td>\n<td style=\"text-align:center\">peek()</td>\n<td>不可用</td>\n<td>不可用</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"另一个例子\"><a href=\"#另一个例子\" class=\"headerlink\" title=\"另一个例子\"></a>另一个例子</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* 计算输出其他线程锁计算的数据</span><br><span class=\"line\">*</span><br><span class=\"line\">*/</span><br><span class=\"line\">public class ThreadA &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class=\"line\">        ThreadB b = new ThreadB();</span><br><span class=\"line\">        //启动计算线程</span><br><span class=\"line\">        b.start();</span><br><span class=\"line\">        //线程A拥有b对象上的锁。线程为了调用wait()或notify()方法，该线程必须是那个对象锁的拥有者</span><br><span class=\"line\">        synchronized (b) &#123;</span><br><span class=\"line\">            System.out.println(&quot;等待对象b完成计算。。。&quot;);</span><br><span class=\"line\">            //当前线程A等待</span><br><span class=\"line\">            b.wait();</span><br><span class=\"line\">            System.out.println(&quot;b对象计算的总和是：&quot; + b.total);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 计算1+2+3 ... +100的和</span><br><span class=\"line\">*</span><br><span class=\"line\">*/</span><br><span class=\"line\">class ThreadB extends Thread &#123;</span><br><span class=\"line\">    int total;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        synchronized (this) &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; 101; i++) &#123;</span><br><span class=\"line\">                total += i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //（完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程A被唤醒</span><br><span class=\"line\">            notify();</span><br><span class=\"line\">            System.out.println(&quot;计算完成&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<p>等待对象b完成计算。。。<br>计算完成<br>b对象计算的总和是：5050</p>\n<p>如果我们将b.wait()去掉呢？结果如下：</p>\n<p>等待对象b完成计算。。。<br>b对象计算的总和是：0<br>计算完成</p>\n<p>上述的结果表明，当去掉b.wait()时，新启动的线程ThreadB与主线程ThreadA是各自执行的，没有线程等待的现象。</p>\n<p>我们想要的效果是，当线程ThreadB完成计算之后，再去取计算后的结果。所以使用了b.wait()来让主线程等待。</p>\n<p>那为什么是使用b.wait()，而不是Thread.currentThread.wait()，或者其他的呢？</p>\n<p>如果我们将b.wait()替换成Thread.currentThread.wait()，将会得到如下的结果：</p>\n<p>Exception in thread “main” java.lang.IllegalMonitorStateException<br>at java.lang.Object.wait(Native Method)<br>at java.lang.Object.wait(Object.java:485)<br>at pa.com.thread.ThreadA.main(ThreadA.java:18)<br>等待对象b完成计算。。。<br>计算完成</p>\n<p>替换的代码Thread.currentThread.wait()好像理所当然应该如我们预期的正确啊，让当前线程处于等待状态，让其他线程先执行。</p>\n<p>我们忽略了一个很重要的问题：线程与锁是分不开的，线程的同步、等待、唤醒都与对象锁是密不可分的。</p>\n<p>线程ThreadA持有对象b的锁，我们要使用这把锁去让线程释放锁，从而让其他的线程能抢到这把锁。</p>\n<p>从我们的程序来分析就是：线程ThreadA首先持有锁对象b，然后调用b.wait()将对象锁释放，线程ThreadB争抢到对象锁b，从而执行run()方法中的计算，计算完了之后使用notify()唤醒主线程ThreadA，ThreadA得以继续执行，从而得到了我们预期的效果。</p>\n<p>（之所以ThreadB的对象锁也是b，是因为synchronized(this)中的this指向的就是ThreadB的实例b）</p>\n<p>Thread.currentThread.wait()调用的是当前线程对象（即主线程ThreadA）的wait()方法，当前线程对象ThreadA是没有被加锁的，它只是获取了对象锁b。我基本没有看到过这样的调用，一般使用的是锁对象的wait()，本例中为b.wait()</p>\n<p>顺带讲一下wait()与sleep()的区别。</p>\n<p>如果我们将b.wait()换成Thread.sleep(1000)，则会出现如下的结果：</p>\n<p>等待对象b完成计算。。。<br>b对象计算的总和是：0<br>计算完成</p>\n<p>从执行结果可以看出，Thread.sleep(1000)只是让主线程ThreadA睡眠了1秒钟，而并没有释放对象锁，所以在主线程ThreadA睡眠的过程中，ThreadB拿不到对象锁，从而不能执行。</p>\n<p>所以我们也就得出了如下的结论：</p>\n<p>wait()方法是让线程释放对象锁，让其他线程拿到锁之后去优先执行，当其他全程唤醒wait()中的线程 或者 拿到对象锁的线程都执行完释放了对象锁之后，wait()中的线程才会再次拿到对象锁从而执行。</p>\n<p>sleep()方法是让线程睡眠，此时并没有释放对象锁，其他想要拿到睡眠线程的对象锁的线程也就拿不到相应的对象锁，从而不能抢在它前面执行。</p>\n<p>补：</p>\n<p>wait、notify和notifyAll方法是Object类的final native方法。所以这些方法不能被子类重写，Object类是所有类的超类，因此在程序中有以下三种形式调用wait等方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wait();//方式1：</span><br><span class=\"line\">this.wait();//方式2：</span><br><span class=\"line\">super.wait();//方式3</span><br></pre></td></tr></table></figure>\n<p>void wait()</p>\n<p>导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。</p>\n<h1 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h1><p>卖火车票问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Seller implements Runnable &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        synchronized (this) &#123;</span><br><span class=\"line\">            if (Synchronized.ticket &gt; 0) &#123;</span><br><span class=\"line\">                System.out.println(&quot;正在卖票,剩余&quot; + Synchronized.ticket);</span><br><span class=\"line\">                Synchronized.ticket--;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(100);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Synchronized &#123;</span><br><span class=\"line\">    static Integer ticket = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Seller s = new Seller();</span><br><span class=\"line\">        Thread t1 = new Thread(s);</span><br><span class=\"line\">        Thread t2 = new Thread(s);</span><br><span class=\"line\">        Thread t3 = new Thread(s);</span><br><span class=\"line\">        Thread t4 = new Thread(s);</span><br><span class=\"line\">        Thread t5 = new Thread(s);</span><br><span class=\"line\">        Thread t6 = new Thread(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        t3.start();</span><br><span class=\"line\">        t4.start();</span><br><span class=\"line\">        t5.start();</span><br><span class=\"line\">        t6.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/wangweiye01/mutiThreading\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckc5n3jwd000r0j9ksaqynoez","category_id":"ckc5n3jwg000t0j9k89extb4f","_id":"ckc5n3jx000110j9ki10s69uv"},{"post_id":"ckc5n3jx100120j9kkglfh2f6","category_id":"ckc5n3jwg000t0j9k89extb4f","_id":"ckc5n3jx600160j9k6pn4j0ik"},{"post_id":"ckc5n3jx9001a0j9khwlhnghl","category_id":"ckc5n3jx700180j9k7g1xw1ht","_id":"ckc5n3jxe001f0j9k2qnzmetu"},{"post_id":"ckc5n3jx500150j9kjt6zlfdg","category_id":"ckc5n3jx700180j9k7g1xw1ht","_id":"ckc5n3jxg001i0j9k2kj9lg7b"},{"post_id":"ckc5n3jxd001d0j9k48viaaln","category_id":"ckc5n3jx700180j9k7g1xw1ht","_id":"ckc5n3jxi001k0j9kfuc23wpt"},{"post_id":"ckc5n3jx600170j9kruzoezp8","category_id":"ckc5n3jx700180j9k7g1xw1ht","_id":"ckc5n3jxj001m0j9kott213sw"},{"post_id":"ckc5n3jxe001e0j9kljzzs8gk","category_id":"ckc5n3jx700180j9k7g1xw1ht","_id":"ckc5n3jxk001o0j9kzx9ru27u"},{"post_id":"ckc5n3jxf001h0j9k55ebuvqd","category_id":"ckc5n3jx700180j9k7g1xw1ht","_id":"ckc5n3jxl001q0j9kf0pogfoq"},{"post_id":"ckc5n3jx800190j9k2gx8afze","category_id":"ckc5n3jx700180j9k7g1xw1ht","_id":"ckc5n3jxm001s0j9kxhx0ig3c"},{"post_id":"ckc5n3jxh001j0j9kx3hqse6m","category_id":"ckc5n3jx700180j9k7g1xw1ht","_id":"ckc5n3jxn001u0j9kwhit5waw"},{"post_id":"ckc5n3jxi001l0j9kht4vk5xw","category_id":"ckc5n3jx700180j9k7g1xw1ht","_id":"ckc5n3jxp001w0j9ki9dtd3lb"},{"post_id":"ckc5n3jxj001n0j9ksxhhwnxt","category_id":"ckc5n3jx700180j9k7g1xw1ht","_id":"ckc5n3jxr001y0j9kioblzx6h"},{"post_id":"ckc5n3k3f00220j9knsz833iq","category_id":"ckc5n3jwg000t0j9k89extb4f","_id":"ckc5n3k3m00240j9k7cm4h2pv"}],"PostTag":[{"post_id":"ckc5n3jwe000s0j9k30riapwx","tag_id":"ckc5n3jwv000v0j9kqn2w2cl8","_id":"ckc5n3jwz000z0j9kqfnmrpg5"}],"Tag":[{"name":"前端","_id":"ckc5n3jwv000v0j9kqn2w2cl8"}]}}