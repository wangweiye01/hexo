<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="后端 服务器 Java">
<meta property="og:type" content="website">
<meta property="og:title" content="老枪的世界">
<meta property="og:url" content="https://wangweiye01.github.io/blog/index.html">
<meta property="og:site_name" content="老枪的世界">
<meta property="og:description" content="后端 服务器 Java">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="老枪的世界">
<meta name="twitter:description" content="后端 服务器 Java">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wangweiye01.github.io/blog/"/>





  <title>老枪的世界</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?de937bbd89c60c5077073fb5db3a9f47";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老枪的世界</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">你不懂</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/blog/2018/03/26/maven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老枪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老枪的世界">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/03/26/maven/" itemprop="url">maven构建Spring Boot多模块项目以及打包方法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T15:06:22+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://www.wailian.work/images/2018/03/28/f5462f69549047be1b086629e548eefc8d74eca329bea-IiKAbw_fw658.jpg" alt=""></p>
<blockquote>
<p>比起传统复杂的单体工程，使用Maven的多模块配置，可以帮助项目划分模块，鼓励重用，防止POM变得过于庞大，方便某个模块的构建，而不用每次都构建整个项目，并且使得针对某个模块的特殊控制更为方便</p>
</blockquote>
<h1 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h1><h2 id="创建空的maven主项目"><a href="#创建空的maven主项目" class="headerlink" title="创建空的maven主项目"></a>创建空的maven主项目</h2><p><img src="http://www.wailian.work/images/2018/03/26/1.png" alt="create"></p>
<p><img src="http://www.wailian.work/images/2018/03/26/2.png" alt="mvn"></p>
<h2 id="删除src目录"><a href="#删除src目录" class="headerlink" title="删除src目录"></a>删除src目录</h2><p><img src="http://www.wailian.work/images/2018/03/26/3.png" alt="src"></p>
<h2 id="修改pom文件"><a href="#修改pom文件" class="headerlink" title="修改pom文件"></a>修改pom文件</h2><p>添加<code>&lt;packaging&gt;pom&lt;/packaging&gt;</code></p>
<p><img src="http://www.wailian.work/images/2018/03/26/4.png" alt=""></p>
<h1 id="创建Spring-Boot项目模块"><a href="#创建Spring-Boot项目模块" class="headerlink" title="创建Spring Boot项目模块"></a>创建Spring Boot项目模块</h1><p>在主项目上点击右键，选择New-Module</p>
<p><img src="http://www.wailian.work/images/2018/03/26/5.png" alt=""></p>
<p>选择Spring Initializr</p>
<p><img src="http://www.wailian.work/images/2018/03/26/6.png" alt=""></p>
<p>填写基本信息之后完成模块项目创建</p>
<p><img src="http://www.wailian.work/images/2018/03/26/7.png" alt=""></p>
<p>采用相同方式再创建一个模块</p>
<p><img src="http://www.wailian.work/images/2018/03/26/8.png" alt=""></p>
<h1 id="修改主项目pom文件"><a href="#修改主项目pom文件" class="headerlink" title="修改主项目pom文件"></a>修改主项目pom文件</h1><p>将两个子模块pom中的spring boot父依赖剪切到主项目中的pom文件中</p>
<p><img src="http://www.wailian.work/images/2018/03/26/9.png" alt=""></p>
<p>在两个子模块pom中添加对父项目的依赖</p>
<p><img src="http://www.wailian.work/images/2018/03/26/10.png" alt=""></p>
<p>在主项目pom中添加所有的子模块</p>
<p><img src="http://www.wailian.work/images/2018/03/26/11.png" alt=""></p>
<h1 id="测试依赖"><a href="#测试依赖" class="headerlink" title="测试依赖"></a>测试依赖</h1><p>utils中添加方法，并在api模块中引入依赖，即可使用</p>
<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>注意：多模块项目仅仅需要在启动类所在的模块添加打包插件即可！！不要在父类添加打包插件</p>
<p>删除启动类以外模块中pom文件的build插件,然后在主目录下执行<code>mvn clean package</code>即可</p>
<p><a href="https://github.com/wangweiye01/maven" target="_blank" rel="noopener">代码地址</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/blog/2018/03/05/scan-notify/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老枪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老枪的世界">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/03/05/scan-notify/" itemprop="url">扫描二维码（登录，支付）后立即通知</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T10:48:42+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://www.wailian.work/images/2018/03/05/1211.jpg" alt=""></p>
<blockquote>
<p>最近在做微信的扫码支付，遇到一个问题：如何在用户扫码支付完成之后，客户端立即得到通知，进行下一步的跳转？</p>
</blockquote>
<p>首先想到的策略可能是客户端轮询查询订单状态，根据返回结果进行跳转</p>
<p>这个方式有明显的缺点，轮询时间设置短，频繁发送请求，对服务器以及数据库都会产生压力；轮询时间过长，用户等待时间长，体验很差；</p>
<p>针对这个问题想到了微信网页版的扫码登录（扫码完成后，立即登录），现在研究一下它的原理并实现相同的功能</p>
<h1 id="微信扫码登录原理"><a href="#微信扫码登录原理" class="headerlink" title="微信扫码登录原理"></a>微信扫码登录原理</h1><p><img src="http://www.wailian.work/images/2018/03/05/pending.png" alt="pengding"></p>
<p>根据图片中，前端二维码页面发送一个网络请求，但是这个请求并没有立即返回</p>
<p><img src="http://www.wailian.work/images/2018/03/05/408.png" alt="408"></p>
<p>一段时间没有扫描后，后端返回408，前端重新发起一个相同的网络请求，并继续pending</p>
<p>据此猜测大概实现原理如下：</p>
<ol>
<li>进入网站-生成一个唯一标识(比如UUID)</li>
<li>跳转到二维码页面（二维码中的链接包含次UUID）</li>
<li>二维码页面向服务端发起请求，查询二维码是被扫登录</li>
<li>服务器收到请求，查询。如果未扫登录，进入等待(wait)，不立即返回</li>
<li>一旦被扫，立即返回(notify)</li>
<li>页面收到结果，做后续处理</li>
</ol>
<p>步骤大概就是如此，但是有个问题，步骤3如果请求超时，如何处理？处理方式是，一段固定时间后，返回408（timeout）</p>
<h1 id="UUID缓存"><a href="#UUID缓存" class="headerlink" title="UUID缓存"></a>UUID缓存</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, ScanPool&gt; cacheMap = new ConcurrentHashMap&lt;String, ScanPool&gt;();</span><br></pre></td></tr></table></figure>
<p>一定要使用ConcurrentHashMap否则多线程操作集合会报错ConcurrentModificationException</p>
<p>单线程中出现该异常的原因是，对一个集合遍历的同时，又对该集合进行了增删的操作</p>
<p>多线程中更易出现该异常，当你在一个线程中对一数据集合进行遍历，正赶上另外一个线程对该数据集合进行增删操作时便会出现该异常</p>
<p>缓存还要设置自动清理功能，防止增长过大</p>
<h1 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/qrcode/&#123;uuid&#125;&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">String createQRCode(@PathVariable String uuid, HttpServletResponse response) &#123;</span><br><span class="line">    System.out.println(&quot;生成二维码&quot;);</span><br><span class="line"></span><br><span class="line">    String text = &quot;http://2b082e46.ngrok.io/login/&quot; + uuid;</span><br><span class="line">    int width = 300;</span><br><span class="line">    int height = 300;</span><br><span class="line">    String format = &quot;png&quot;;</span><br><span class="line">    //将UUID放入缓存</span><br><span class="line">    ScanPool pool = new ScanPool();</span><br><span class="line">    PoolCache.cacheMap.put(uuid, pool);</span><br><span class="line">    try &#123;</span><br><span class="line">        Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;EncodeHintType, Object&gt;();</span><br><span class="line">        hints.put(EncodeHintType.CHARACTER_SET, &quot;utf-8&quot;);</span><br><span class="line">        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); //容错率</span><br><span class="line">        BitMatrix bitMatrix = new MultiFormatWriter().encode(text, BarcodeFormat.QR_CODE, width, height, hints);</span><br><span class="line">        MatrixToImageWriter.writeToStream(bitMatrix, format, response.getOutputStream());</span><br><span class="line">    &#125; catch (WriterException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成二维码，并将UUID放入缓存中</p>
<p>此处需要注意，二维码url必须是外网可以访问地址，此处可以使用<a href="https://ngrok.com/" target="_blank" rel="noopener">内网穿透工具</a></p>
<h1 id="验证是否登录"><a href="#验证是否登录" class="headerlink" title="验证是否登录"></a>验证是否登录</h1><p>前端发起请求，验证该二维码是否已经被扫登录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/pool&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">String pool(String uuid) &#123;</span><br><span class="line">    System.out.println(&quot;检测[&quot; + uuid + &quot;]是否登录&quot;);</span><br><span class="line"></span><br><span class="line">    ScanPool pool = PoolCache.cacheMap.get(uuid);</span><br><span class="line"></span><br><span class="line">    if (pool == null) &#123;</span><br><span class="line">        return &quot;timeout&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用计时器，固定时间后不再等待扫描结果--防止页面访问超时</span><br><span class="line">    new Thread(new ScanCounter(pool)).start();</span><br><span class="line"></span><br><span class="line">    boolean scanFlag = pool.getScanStatus();</span><br><span class="line"></span><br><span class="line">    if (scanFlag) &#123;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &quot;fail&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean getScanStatus() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (!isScan()) &#123; //如果还未扫描，则等待</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        if (isScan()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        // TODO Auto-generated catch block</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void notifyPool() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新开线程防止页面访问超时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class ScanCounter implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public Long timeout = 27000L;</span><br><span class="line"></span><br><span class="line">    //传入的对象</span><br><span class="line">    private ScanPool scanPool;</span><br><span class="line"></span><br><span class="line">    public ScanCounter(ScanPool scanPool) &#123;</span><br><span class="line">        this.scanPool = scanPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(timeout);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyPool(scanPool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void notifyPool(ScanPool scanPool) &#123;</span><br><span class="line">        scanPool.notifyPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.wailian.work/images/2018/03/05/code4c40c.png" alt="verify"></p>
<h1 id="扫码"><a href="#扫码" class="headerlink" title="扫码"></a>扫码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/login/&#123;uuid&#125;&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">String login(@PathVariable String uuid) &#123;</span><br><span class="line"></span><br><span class="line">    ScanPool pool = PoolCache.cacheMap.get(uuid);</span><br><span class="line"></span><br><span class="line">    if (pool == null) &#123;</span><br><span class="line">        return &quot;timeout,scan fail&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 设置被扫状态，唤起线程</span><br><span class="line">    pool.scanSuccess();</span><br><span class="line"></span><br><span class="line">    return &quot;扫码完成，登录成功&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扫码成功，设置扫码状态，唤起线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void scanSuccess() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        setScan(true);</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.wailian.work/images/2018/03/05/ok.png" alt=""></p>
<p>手机扫码后</p>
<p><img src="http://www.wailian.work/images/2018/03/05/mobile.jpg" alt=""></p>
<p>对比<a href="https://github.com/wangweiye01/scan_login" target="_blank" rel="noopener">完整代码</a>很容易看实现原理</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/blog/2018/03/01/websocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老枪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老枪的世界">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/03/01/websocket/" itemprop="url">Spring Boot实现WebSocket消息推送</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-01T17:05:06+08:00">
                2018-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://www.wailian.work/images/2018/03/02/3b41bb4144a7478ef7d1937c3a0ec56975e163f61a9ba-n8Syo1_fw658.jpg" alt="pic"></p>
<h1 id="什么是WebSocket"><a href="#什么是WebSocket" class="headerlink" title="什么是WebSocket"></a>什么是WebSocket</h1><p>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void configureMessageBroker(MessageBrokerRegistry config) &#123;</span><br><span class="line">		config.enableSimpleBroker(&quot;/topic&quot;);</span><br><span class="line">		config.setApplicationDestinationPrefixes(&quot;/app&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void registerStompEndpoints(StompEndpointRegistry registry) &#123;</span><br><span class="line">		registry.addEndpoint(&quot;/my-websocket&quot;).withSockJS();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里配置了以”/app”开头的websocket请求url和名为”my-websocket”的endpoint</p>
<ol>
<li>@EnableWebSocketMessageBroker注解表示开启使用STOMP协议来传输基于代理的消息</li>
<li>registerStompEndpoints方法表示注册STOMP协议的节点，并指定映射的URL</li>
<li><code>registry.addEndpoint(&quot;/my-websocket&quot;).withSockJS()</code>这一行代码用来注册STOMP协议节点，同时指定使用SockJS协议。</li>
<li>configureMessageBroker方法用来配置消息代理，由于我们是实现推送功能，这里的消息代理是/topic</li>
</ol>
<h1 id="推送消息类"><a href="#推送消息类" class="headerlink" title="推送消息类"></a>推送消息类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SocketMessage &#123;</span><br><span class="line"></span><br><span class="line">	public String message;</span><br><span class="line"></span><br><span class="line">	public String date;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@EnableScheduling</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class App &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(App.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">	@GetMapping(&quot;/&quot;)</span><br><span class="line">	public String index() &#123;</span><br><span class="line">		return &quot;index&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@MessageMapping(&quot;/send&quot;)</span><br><span class="line">	@SendTo(&quot;/topic/send&quot;)</span><br><span class="line">	public SocketMessage send(SocketMessage message) throws Exception &#123;</span><br><span class="line">		DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">		message.date = df.format(new Date());</span><br><span class="line">		return message;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Scheduled(fixedRate = 1000)</span><br><span class="line">	@SendTo(&quot;/topic/callback&quot;)</span><br><span class="line">	public Object callback() throws Exception &#123;</span><br><span class="line">		// 发现消息</span><br><span class="line">		DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">		messagingTemplate.convertAndSend(&quot;/topic/callback&quot;, df.format(new Date()));</span><br><span class="line">		return &quot;callback&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@MessageMapping</code>注解和<code>@RequestMapping</code>类似，用来发送消息到特定路径</p>
<p><code>@SendTo</code>注解表示当服务器有消息需要推送的时候，会对订阅了<code>@SendTo</code>中路径的客户端发送消息</p>
<h1 id="前端脚本"><a href="#前端脚本" class="headerlink" title="前端脚本"></a>前端脚本</h1><p>我们这个案例需要三个js脚本文件，分别是STOMP协议的客户端脚本stomp.js、SockJS的客户端脚本sock.js以及jQuery</p>
<h1 id="演示页面"><a href="#演示页面" class="headerlink" title="演示页面"></a>演示页面</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;websocket&lt;/title&gt;</span><br><span class="line">&lt;script src=&quot;//cdn.bootcss.com/angular.js/1.5.6/angular.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/sockjs-client/1.1.4/sockjs.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/stomp.js/2.3.3/stomp.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">	var stompClient = null;</span><br><span class="line"></span><br><span class="line">	var app = angular.module(&apos;app&apos;, []);</span><br><span class="line">	app.controller(&apos;MainController&apos;, function($rootScope, $scope, $http) &#123;</span><br><span class="line"></span><br><span class="line">		$scope.data = &#123;</span><br><span class="line">			//连接状态</span><br><span class="line">			connected : false,</span><br><span class="line">			//消息</span><br><span class="line">			message : &apos;&apos;,</span><br><span class="line">			rows : []</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		//连接</span><br><span class="line">		$scope.connect = function() &#123;</span><br><span class="line">			var socket = new SockJS(&apos;/my-websocket&apos;);</span><br><span class="line">			stompClient = Stomp.over(socket);</span><br><span class="line">			stompClient.connect(&#123;&#125;, function(frame) &#123;</span><br><span class="line">				// 注册发送消息</span><br><span class="line">				stompClient.subscribe(&apos;/topic/send&apos;, function(msg) &#123;</span><br><span class="line">					$scope.data.rows.push(JSON.parse(msg.body));</span><br><span class="line">					$scope.data.connected = true;</span><br><span class="line">					$scope.$apply();</span><br><span class="line">				&#125;);</span><br><span class="line">				// 注册推送时间回调</span><br><span class="line">				stompClient.subscribe(&apos;/topic/callback&apos;, function(r) &#123;</span><br><span class="line">					$scope.data.time = &apos;当前服务器时间：&apos; + r.body;</span><br><span class="line">					$scope.data.connected = true;</span><br><span class="line">					$scope.$apply();</span><br><span class="line">				&#125;);</span><br><span class="line"></span><br><span class="line">				$scope.data.connected = true;</span><br><span class="line">				$scope.$apply();</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		$scope.disconnect = function() &#123;</span><br><span class="line">			if (stompClient != null) &#123;</span><br><span class="line">				stompClient.disconnect();</span><br><span class="line">			&#125;</span><br><span class="line">			$scope.data.connected = false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		$scope.send = function() &#123;</span><br><span class="line">			stompClient.send(&quot;/app/send&quot;, &#123;&#125;, JSON.stringify(&#123;</span><br><span class="line">				&apos;message&apos; : $scope.data.message</span><br><span class="line">			&#125;));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body ng-app=&quot;app&quot; ng-controller=&quot;MainController&quot;&gt;</span><br><span class="line">	&lt;label&gt;WebSocket连接状态:&lt;/label&gt;</span><br><span class="line">	&lt;button type=&quot;button&quot; ng-disabled=&quot;data.connected&quot; ng-click=&quot;connect()&quot;&gt;连接&lt;/button&gt;</span><br><span class="line">	&lt;button type=&quot;button&quot; ng-click=&quot;disconnect()&quot;</span><br><span class="line">		ng-disabled=&quot;!data.connected&quot;&gt;断开&lt;/button&gt;</span><br><span class="line">	&lt;br /&gt;</span><br><span class="line">	&lt;br /&gt;</span><br><span class="line">	&lt;div ng-show=&quot;data.connected&quot;&gt;</span><br><span class="line">		&lt;label&gt;&#123;&#123;data.time&#125;&#125;&lt;/label&gt; &lt;br /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot;</span><br><span class="line">			ng-model=&quot;data.message&quot; placeholder=&quot;请输入内容...&quot; /&gt;</span><br><span class="line">		&lt;button ng-click=&quot;send()&quot; type=&quot;button&quot;&gt;发送&lt;/button&gt;</span><br><span class="line">		&lt;br /&gt; &lt;br /&gt; 消息列表： &lt;br /&gt;</span><br><span class="line">		&lt;table&gt;</span><br><span class="line">			&lt;thead&gt;</span><br><span class="line">				&lt;tr&gt;</span><br><span class="line">					&lt;th&gt;内容&lt;/th&gt;</span><br><span class="line">					&lt;th&gt;时间&lt;/th&gt;</span><br><span class="line">				&lt;/tr&gt;</span><br><span class="line">			&lt;/thead&gt;</span><br><span class="line">			&lt;tbody&gt;</span><br><span class="line">				&lt;tr ng-repeat=&quot;row in data.rows&quot;&gt;</span><br><span class="line">					&lt;td&gt;&#123;&#123;row.message&#125;&#125;&lt;/td&gt;</span><br><span class="line">					&lt;td&gt;&#123;&#123;row.date&#125;&#125;&lt;/td&gt;</span><br><span class="line">				&lt;/tr&gt;</span><br><span class="line">			&lt;/tbody&gt;</span><br><span class="line">		&lt;/table&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.wailian.work/images/2018/03/02/WX20180302-094543.png" alt="演示图"></p>
<p><a href="https://github.com/wangweiye01/websocket" target="_blank" rel="noopener">代码地址</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/blog/2018/02/02/git-remote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老枪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老枪的世界">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/02/02/git-remote/" itemprop="url">Git笔记</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-02T13:58:28+08:00">
                2018-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://www.wailian.work/images/2018/02/06/e58c7755f88b1e0ad82a30100cd3f781e3fe8f5970ada-GGAkXt_fw658.jpg" alt="pic"></p>
<h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><h2 id="在GitHub或者码云上新建仓库"><a href="#在GitHub或者码云上新建仓库" class="headerlink" title="在GitHub或者码云上新建仓库"></a>在GitHub或者码云上新建仓库</h2><p>登录GitHub或者码云，新建仓库，不默认产生README文档</p>
<h2 id="本地新建仓库"><a href="#本地新建仓库" class="headerlink" title="本地新建仓库"></a>本地新建仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="本地仓库与远程相连"><a href="#本地仓库与远程相连" class="headerlink" title="本地仓库与远程相连"></a>本地仓库与远程相连</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@git.oschina.net:wangweiye/SpringBoot-Learning.git</span><br></pre></td></tr></table></figure>
<h2 id="提交本地到远程"><a href="#提交本地到远程" class="headerlink" title="提交本地到远程"></a>提交本地到远程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m &quot;&quot;</span><br><span class="line"></span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><h2 id="列显已有的标签"><a href="#列显已有的标签" class="headerlink" title="列显已有的标签"></a>列显已有的标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<h2 id="新建轻量级标签"><a href="#新建轻量级标签" class="headerlink" title="新建轻量级标签"></a>新建轻量级标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0</span><br></pre></td></tr></table></figure>
<h2 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin [tagname]</span><br></pre></td></tr></table></figure>
<h2 id="删除远程tag"><a href="#删除远程tag" class="headerlink" title="删除远程tag"></a>删除远程tag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete tag [tagname]</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/blog/2018/02/02/delay-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老枪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老枪的世界">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/02/02/delay-queue/" itemprop="url">延时队列的使用</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-02T10:40:03+08:00">
                2018-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://www.wailian.work/images/2018/02/02/61b7aea823aaba020bbe85f9b2cc4deeae67d58f12106-3PVHe7_fw658.jpg" alt=""></p>
<h1 id="什么是DelayQueue"><a href="#什么是DelayQueue" class="headerlink" title="什么是DelayQueue"></a>什么是DelayQueue</h1><p>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="订单超时关闭"><a href="#订单超时关闭" class="headerlink" title="订单超时关闭"></a>订单超时关闭</h2><p>订单业务中总是出现订单未支付过期关闭的情形。最简单的解决方式是定时任务轮询订单，这种方式浪费资源并不优雅。延时队列能够轻松应对这种情形。</p>
<h3 id="创建订单类"><a href="#创建订单类" class="headerlink" title="创建订单类"></a>创建订单类</h3><p>放入DelayQueue的对象需要实现Delayed接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Order implements Delayed &#123;</span><br><span class="line">	public static AtomicInteger genId = new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">	private final long delay; // 延迟时间</span><br><span class="line">	private final long expire; // 到期时间</span><br><span class="line">	private final long now; // 创建时间</span><br><span class="line"></span><br><span class="line">	private Integer id; // 订单ID</span><br><span class="line">	private Integer state; // 订单状态</span><br><span class="line"></span><br><span class="line">	public Integer getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setId(Integer id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Integer getState() &#123;</span><br><span class="line">		return state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setState(Integer state) &#123;</span><br><span class="line">		this.state = state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Order(long delay, String msg) &#123;</span><br><span class="line">		this.delay = delay;</span><br><span class="line">		expire = System.currentTimeMillis() + delay; // 到期时间 = 当前时间+延迟时间</span><br><span class="line">		now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		this.state = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 需要实现的接口，获得延迟时间 用过期时间-当前时间</span><br><span class="line">	 *</span><br><span class="line">	 * @param unit</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">		return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 用于延迟队列内部比较排序 当前时间的延迟时间 - 比较对象的延迟时间</span><br><span class="line">	 *</span><br><span class="line">	 * @param o</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public int compareTo(Delayed o) &#123;</span><br><span class="line">		return (int) (this.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成订单"><a href="#生成订单" class="headerlink" title="生成订单"></a>生成订单</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private static void producer(final DelayQueue&lt;Order&gt; delayQueue) &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Order element = new Order(new Random().nextInt(1000) * 10, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">                element.setId(Order.genId.getAndIncrement());</span><br><span class="line"></span><br><span class="line">                delayQueue.offer(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每秒打印延迟队列中的对象个数</span><br><span class="line">     */</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;delayQueue size:&quot; + delayQueue.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理超时订单"><a href="#处理超时订单" class="headerlink" title="处理超时订单"></a>处理超时订单</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static void consumer(final DelayQueue&lt;Order&gt; delayQueue) &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Order element = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    element = delayQueue.take();</span><br><span class="line"></span><br><span class="line">                    if (element.getState().intValue() == 0) &#123;</span><br><span class="line">                        // 如果现在订单状态还未支付，关闭订单</span><br><span class="line">                        element.setState(1);</span><br><span class="line"></span><br><span class="line">                        System.out.println(&quot;订单&quot; + element.getId() + &quot;超时关闭&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DelayQueue还是一个阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，此时调用 poll() 将直接返回 null，调用 take() 将会发生阻塞，直到有元素发生到期，take() 才会返回。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    DelayQueue&lt;Order&gt; delayQueue = new DelayQueue&lt;Order&gt;();</span><br><span class="line"></span><br><span class="line">    // 生产者</span><br><span class="line">    producer(delayQueue);</span><br><span class="line"></span><br><span class="line">    // 消费者</span><br><span class="line">    consumer(delayQueue);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.HOURS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.wailian.work/images/2018/02/02/WX20180202-110453.png" alt=""></p>
<h2 id="多考生考试"><a href="#多考生考试" class="headerlink" title="多考生考试"></a>多考生考试</h2><ol>
<li>考试总时间为10秒，至少2秒后才可进行交卷。</li>
<li>考生可在2-10秒这段时间内的任意时间交卷。</li>
<li>考试时间一到，所有未交卷的学生必须交卷。</li>
</ol>
<p>使用enum定义时间常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum Times &#123;</span><br><span class="line">    SUMMIT_TIME(10), //考试总时间</span><br><span class="line">    SUMBMIT_LIMIT(2), // 交卷限制时间</span><br><span class="line">    MAX_RAND_TIME(15); // 模拟考生所需最大时间</span><br><span class="line"></span><br><span class="line">    private final int value;</span><br><span class="line"></span><br><span class="line">    private Times(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="学生类"><a href="#学生类" class="headerlink" title="学生类"></a>学生类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Student implements Delayed &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private long delay; // 考试花费时间，单位为毫秒</span><br><span class="line">    private long expire; // 交卷时间，单位为毫秒</span><br><span class="line"></span><br><span class="line">    // 此构造可随机生成考试花费时间</span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.delay = TimeUnit.MILLISECONDS.convert(getRandomSeconds(), TimeUnit.SECONDS);</span><br><span class="line">        this.expire = System.currentTimeMillis() + this.delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //此构造可指定考试花费时间</span><br><span class="line">    public Student(String name, long delay, TimeUnit unit) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.delay = TimeUnit.MILLISECONDS.convert(delay, unit);</span><br><span class="line">        this.expire = System.currentTimeMillis() + this.delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    public int getRandomSeconds() &#123;</span><br><span class="line">        // 获取随机花费时间，范围：2-10秒</span><br><span class="line">        return new Random().nextInt(Times.MAX_RAND_TIME.getValue() - Times.SUMBMIT_LIMIT.getValue())</span><br><span class="line">                    + Times.SUMBMIT_LIMIT.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Delayed o) &#123;</span><br><span class="line">        // 此方法的实现用于定义优先级</span><br><span class="line">        long td = this.getDelay(TimeUnit.MILLISECONDS);</span><br><span class="line">        long od = o.getDelay(TimeUnit.MILLISECONDS);</span><br><span class="line">        return td &gt; od ? 1 : td == od ? 0 : -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">        // 这里返回的是剩余延时，当延时为0时，此元素延时期满，可从take()取出</span><br><span class="line">        return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主方法实现"><a href="#主方法实现" class="headerlink" title="主方法实现"></a>主方法实现</h3><ol>
<li>初始化对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DelayQueue&lt;Student&gt; queue = new DelayQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>
<ol>
<li>添加测试数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue.add(new Student(&quot;范冰冰&quot;));</span><br><span class="line">queue.add(new Student(&quot;成  龙&quot;));</span><br><span class="line">queue.add(new Student(&quot;李一桐&quot;));</span><br><span class="line">queue.add(new Student(&quot;宋小宝&quot;));</span><br><span class="line">queue.add(new Student(&quot;吴  京&quot;));</span><br><span class="line">queue.add(new Student(&quot;绿巨人&quot;));</span><br><span class="line">queue.add(new Student(&quot;洪金宝&quot;));</span><br><span class="line">queue.add(new Student(&quot;李云龙&quot;));</span><br><span class="line">queue.add(new Student(&quot;钢铁侠&quot;));</span><br><span class="line">queue.add(new Student(&quot;刘德华&quot;));</span><br><span class="line">queue.add(new Student(&quot;戴安娜&quot;));</span><br></pre></td></tr></table></figure>
<ol>
<li>添加一条用于考试结束时强制交卷的属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.add(new Student(&quot;submit&quot;, Times.SUBMIT_TIME.getValue(),TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure>
<ol>
<li>开始考试</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    Student s = queue.take(); // 必要时进行阻塞等待</span><br><span class="line">    if (s.getName().equals(&quot;submit&quot;)) &#123;</span><br><span class="line">        System.out.println(&quot;时间已到，全部交卷！&quot;);</span><br><span class="line">        // 利用Java8 Stream特性使尚未交卷学生交卷</span><br><span class="line">        queue.parallelStream()</span><br><span class="line">             .filter(v -&gt; v.getExpire() &gt;= s.getExpire())</span><br><span class="line">             .map(Student::submit)</span><br><span class="line">             .forEach(System.out::println);</span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="http://www.wailian.work/images/2018/02/02/WX20180202-115504.png" alt=""></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">package cn.gss.juc;</span><br><span class="line"></span><br><span class="line">import java.text.DateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.DelayQueue;</span><br><span class="line">import java.util.concurrent.Delayed;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">enum Times &#123;</span><br><span class="line">    SUBMIT_TIME(10), SUMBMIT_LIMIT(2), MAX_RAND_TIME(15);</span><br><span class="line">    private final int value;</span><br><span class="line"></span><br><span class="line">    private Times(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * DelayQueue实现多考生考试</span><br><span class="line"> * @author Gss</span><br><span class="line"> */</span><br><span class="line">public class TestDelayedQueue &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        DelayQueue&lt;Student&gt; queue = new DelayQueue&lt;&gt;();</span><br><span class="line">        queue.add(new Student(&quot;范冰冰&quot;));</span><br><span class="line">        queue.add(new Student(&quot;成  龙&quot;));</span><br><span class="line">        queue.add(new Student(&quot;李一桐&quot;));</span><br><span class="line">        queue.add(new Student(&quot;宋小宝&quot;));</span><br><span class="line">        queue.add(new Student(&quot;吴  京&quot;));</span><br><span class="line">        queue.add(new Student(&quot;绿巨人&quot;));</span><br><span class="line">        queue.add(new Student(&quot;洪金宝&quot;));</span><br><span class="line">        queue.add(new Student(&quot;李云龙&quot;));</span><br><span class="line">        queue.add(new Student(&quot;钢铁侠&quot;));</span><br><span class="line">        queue.add(new Student(&quot;刘德华&quot;));</span><br><span class="line">        queue.add(new Student(&quot;戴安娜&quot;));</span><br><span class="line">        queue.add(new Student(&quot;submit&quot;, Times.SUBMIT_TIME.getValue(), TimeUnit.SECONDS));</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Student s = queue.take(); // 必要时进行阻塞等待</span><br><span class="line">            if (s.getName().equals(&quot;submit&quot;)) &#123;</span><br><span class="line">                System.out.println(&quot;时间已到，全部交卷！&quot;);</span><br><span class="line">                // 利用Java8 Stream使尚未交卷学生交卷</span><br><span class="line">                queue.parallelStream()</span><br><span class="line">                     .filter(v -&gt; v.getExpire() &gt;= s.getExpire())</span><br><span class="line">                     .map(Student::submit)</span><br><span class="line">                     .forEach(System.out::println);</span><br><span class="line">                System.exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student implements Delayed &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private long delay; // 考试花费时间，单位为毫秒</span><br><span class="line">    private long expire; // 交卷时间，单位为毫秒</span><br><span class="line"></span><br><span class="line">    // 此构造可随机生成考试花费时间</span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.delay = TimeUnit.MILLISECONDS.convert(getRandomSeconds(), TimeUnit.SECONDS); // 随机生成考试花费时间</span><br><span class="line">        this.expire = System.currentTimeMillis() + this.delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 此构造可指定考试花费时间</span><br><span class="line">    public Student(String name, long delay, TimeUnit unit) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.delay = TimeUnit.MILLISECONDS.convert(delay, unit);</span><br><span class="line">        this.expire = System.currentTimeMillis() + this.delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getRandomSeconds() &#123; // 获取随机花费时间</span><br><span class="line">        return new Random().nextInt(Times.MAX_RAND_TIME.getValue() - Times.SUMBMIT_LIMIT.getValue())</span><br><span class="line">                + Times.SUMBMIT_LIMIT.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student submit() &#123; // 设置花费时间和交卷时间，考试时间结束强制交卷时调用此方法</span><br><span class="line">        setDelay(Times.SUBMIT_TIME.getValue(), TimeUnit.SECONDS);</span><br><span class="line">        setExpire(System.currentTimeMillis());</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getExpire() &#123;</span><br><span class="line">        return expire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDelay(long delay, TimeUnit unit) &#123;</span><br><span class="line">        this.delay = TimeUnit.MILLISECONDS.convert(delay, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setExpire(long expire) &#123;</span><br><span class="line">        this.expire = expire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Delayed o) &#123; // 此方法的实现用于定义优先级</span><br><span class="line">        long td = this.getDelay(TimeUnit.MILLISECONDS);</span><br><span class="line">        long od = o.getDelay(TimeUnit.MILLISECONDS);</span><br><span class="line">        return td &gt; od ? 1 : td == od ? 0 : -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getDelay(TimeUnit unit) &#123; // 这里返回的是剩余延时，当延时为0时，此元素延时期满，可从take()取出</span><br><span class="line">        return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;学生姓名：&quot; + this.name + &quot;,考试用时：&quot; + TimeUnit.SECONDS.convert(delay, TimeUnit.MILLISECONDS) + &quot;,交卷时间：&quot;</span><br><span class="line">                + DateFormat.getDateTimeInstance().format(new Date(this.expire));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h1><p><a href="https://github.com/wangweiye01/DelayQueueTest/tree/master" target="_blank" rel="noopener">GitHub</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/blog/2018/01/30/snow-flake/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老枪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老枪的世界">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/01/30/snow-flake/" itemprop="url">twitter的雪花算法实现</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-30T08:38:03+08:00">
                2018-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://www.wailian.work/images/2018/01/30/f0cada473c10b0fcfae9784875af64050052c1d2195d47-eEEC79_fw658.jpg" alt=""></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>SnowFlake算法是Twitter设计的一个可以在分布式系统中生成唯一的ID的算法，它可以满足Twitter每秒上万条消息ID分配的请求，这些消息ID是唯一的且有大致的递增顺序。</p>
<p>SnowFlake算法生成的ID大致上是按照时间递增的，用在分布式系统中时，需要注意数据中心标识和机器标识必须唯一，这样就能保证每个节点生成的ID都是唯一的。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>SnowFlake算法产生的ID是一个64位的整型，结构如下（每一部分用“-”符号分隔）：</p>
<p><img src="http://www.wailian.work/images/2018/01/30/WX20180130-084624.png" alt=""></p>
<h2 id="1位标识部分"><a href="#1位标识部分" class="headerlink" title="1位标识部分"></a>1位标识部分</h2><p>在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以为0；</p>
<h2 id="41位时间戳部分"><a href="#41位时间戳部分" class="headerlink" title="41位时间戳部分"></a>41位时间戳部分</h2><p>这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L <em> 60 </em> 60 <em> 24 </em> 365) = 69年；</p>
<h2 id="10位节点部分"><a href="#10位节点部分" class="headerlink" title="10位节点部分"></a>10位节点部分</h2><p>Twitter实现中使用前5位作为数据中心标识，后5位作为机器标识，可以部署1024个节点；</p>
<h2 id="12位序列号部分"><a href="#12位序列号部分" class="headerlink" title="12位序列号部分"></a>12位序列号部分</h2><p>支持同一毫秒内同一个节点可以生成4096个ID；</p>
<p>SnowFlake算法生成的ID大致上是按照时间递增的，用在分布式系统中时，需要注意数据中心标识和机器标识必须唯一，这样就能保证每个节点生成的ID都是唯一的。或许我们不一定都需要像上面那样使用5位作为数据中心标识，5位作为机器标识，可以根据我们业务的需要，灵活分配节点部分，如：若不需要数据中心，完全可以使用全部10位作为机器标识；若数据中心不多，也可以只使用3位作为数据中心，7位作为机器标识。</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">package com.wang.snow;</span><br><span class="line"></span><br><span class="line">public class SnowFlake &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 起始的时间戳</span><br><span class="line">     */</span><br><span class="line">    private final static long START_STMP = 1480166465631L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每一部分占用的位数</span><br><span class="line">     */</span><br><span class="line">    private final static long SEQUENCE_BIT = 12; //序列号占用的位数</span><br><span class="line">    private final static long MACHINE_BIT = 5;  //机器标识占用的位数</span><br><span class="line">    private final static long DATACENTER_BIT = 5;//数据中心占用的位数</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每一部分的最大值</span><br><span class="line">     */</span><br><span class="line">    private final static long MAX_DATACENTER_NUM = -1L ^ (-1L &lt;&lt; DATACENTER_BIT);</span><br><span class="line">    private final static long MAX_MACHINE_NUM = -1L ^ (-1L &lt;&lt; MACHINE_BIT);</span><br><span class="line">    private final static long MAX_SEQUENCE = -1L ^ (-1L &lt;&lt; SEQUENCE_BIT);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每一部分向左的位移</span><br><span class="line">     */</span><br><span class="line">    private final static long MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class="line">    private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">    private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT;</span><br><span class="line"></span><br><span class="line">    private long datacenterId;  //数据中心</span><br><span class="line">    private long machineId;    //机器标识</span><br><span class="line">    private long sequence = 0L; //序列号</span><br><span class="line">    private long lastStmp = -1L;//上一次时间戳</span><br><span class="line"></span><br><span class="line">    public SnowFlake(long datacenterId, long machineId) &#123;</span><br><span class="line">        if (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;datacenterId can&apos;t be greater than MAX_DATACENTER_NUM or less than 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;machineId can&apos;t be greater than MAX_MACHINE_NUM or less than 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.datacenterId = datacenterId;</span><br><span class="line">        this.machineId = machineId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 产生下一个ID</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public synchronized long nextId() &#123;</span><br><span class="line">        long currStmp = getNewstmp();</span><br><span class="line">        if (currStmp &lt; lastStmp) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Clock moved backwards.  Refusing to generate id&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (currStmp == lastStmp) &#123;</span><br><span class="line">            //相同毫秒内，序列号自增</span><br><span class="line">            sequence = (sequence + 1) &amp; MAX_SEQUENCE;</span><br><span class="line">            //同一毫秒的序列数已经达到最大</span><br><span class="line">            if (sequence == 0L) &#123;</span><br><span class="line">                currStmp = getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //不同毫秒内，序列号置为0</span><br><span class="line">            sequence = 0L;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastStmp = currStmp;</span><br><span class="line"></span><br><span class="line">        return (currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT //时间戳部分</span><br><span class="line">                | datacenterId &lt;&lt; DATACENTER_LEFT      //数据中心部分</span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT            //机器标识部分</span><br><span class="line">                | sequence;                            //序列号部分</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getNextMill() &#123;</span><br><span class="line">        long mill = getNewstmp();</span><br><span class="line">        while (mill &lt;= lastStmp) &#123;</span><br><span class="line">            mill = getNewstmp();</span><br><span class="line">        &#125;</span><br><span class="line">        return mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getNewstmp() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void snow() &#123;</span><br><span class="line">    SnowFlake snowFlake = new SnowFlake(2, 3);</span><br><span class="line">    for (int i = 0; i &lt; (1 &lt;&lt; 12); i++) &#123;</span><br><span class="line">        System.out.println(snowFlake.nextId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">155632577921953792</span><br><span class="line">155632577921953793</span><br><span class="line">155632577921953794</span><br><span class="line">155632577921953795</span><br><span class="line">155632577921953796</span><br><span class="line">155632577921953797</span><br><span class="line">155632577921953798</span><br><span class="line">155632577921953799</span><br><span class="line">155632577921953800</span><br><span class="line">155632577921953801</span><br><span class="line">155632577921953802</span><br><span class="line">155632577921953803</span><br><span class="line">155632577921953804</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/blog/2018/01/26/master-slave/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老枪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老枪的世界">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/01/26/master-slave/" itemprop="url">MySql主从配置</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-26T09:07:07+08:00">
                2018-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://www.wailian.work/images/2018/01/26/5d274a04c82163baf3c74ae5c97d16e80a641ed24163c7-YnTeKa_fw658.jpg" alt="pic"></p>
<p>mysql版本使用的是5.7.20<br>主库的IP为:47.104.71.88，从库的IP为:45.77.13.74</p>
<h1 id="读写分离-主从库"><a href="#读写分离-主从库" class="headerlink" title="读写分离(主从库)"></a>读写分离(主从库)</h1><p>原理：让主库(master)处理事务性增改删，而从库(slave)处理查询操作</p>
<h1 id="主库创建用户"><a href="#主库创建用户" class="headerlink" title="主库创建用户"></a>主库创建用户</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE,RELOAD,SUPER ON *.* TO synchrouser@45.77.13.74 IDENTIFIED BY &apos;w123456W!&apos;;</span><br></pre></td></tr></table></figure>
<p>在主库创建一个synchrouser用户密码为w123456W!，并允许从库以synchrouser用户来登录</p>
<h1 id="配置主库"><a href="#配置主库" class="headerlink" title="配置主库"></a>配置主库</h1><p>在[mysqld]下增加配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server-id=88</span><br><span class="line">log_bin=mysql-bin</span><br><span class="line">binlog_format=mixed</span><br></pre></td></tr></table></figure>
<p>server-id在数据库配置中必须唯一，一般为IP最后一个节点（例如：47.104.71.88，则设置为88）设置完成后，重启mysql</p>
<h1 id="配置从库"><a href="#配置从库" class="headerlink" title="配置从库"></a>配置从库</h1><p>在[mysqld]增加配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server-id=74</span><br></pre></td></tr></table></figure>
<p>设置完成后，重启mysql</p>
<p>在主库执行:<code>show master status;</code></p>
<p><img src="http://www.wailian.work/images/2018/01/26/WX20180126-091715.png" alt=""></p>
<p>根据以上主库的信息设置从库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;47.104.71.88&apos;,master_user=&apos;synchrouser&apos;,master_password=&apos;w123456W!&apos;,master_log_file=&apos;mysql-bin.000005&apos;,master_log_pos=840;</span><br></pre></td></tr></table></figure>
<p>master_log_file字段对应了主库的File，master_log_pos字段对应了主库的Position</p>
<h1 id="启动主从同步"><a href="#启动主从同步" class="headerlink" title="启动主从同步"></a>启动主从同步</h1><p>从库执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>
<h1 id="检查是否配置成功"><a href="#检查是否配置成功" class="headerlink" title="检查是否配置成功"></a>检查是否配置成功</h1><p><img src="http://www.wailian.work/images/2018/01/26/4.png" alt=""></p>
<p>如果Slave_IO_Running和Slave_SQL_Running都为Yes，代表配置成功</p>
<h1 id="测试主从同步"><a href="#测试主从同步" class="headerlink" title="测试主从同步"></a>测试主从同步</h1><p>主库创建一个库，一个表，观察从库是否同样创建</p>
<h2 id="设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除"><a href="#设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除" class="headerlink" title="设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除"></a>设置主从库之后MySq会持续产生日志，需要定期清除或则设置自动清除</h2><h1 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h1><p>到这里，全部库的主从配置就完成了，实际应用中可能会用到单个表的同步，或者部分表的同步，只需要在从库的/etc/my.cnf里加上</p>
<p>只复制某个表replicate-do-table=dbname.tablename<br>只复制某些表（可用匹配符）replicate-wild-do-table=dbname.tablename%<br>只复制某个库replicate-do-db=dbname<br>只复制某些库replicte-wild-do-db=dbname%<br>不复制某个表replicate-ignore-table=dbname.tablename</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/blog/2018/01/23/java-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老枪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老枪的世界">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/01/23/java-thread/" itemprop="url">Java多线程编程</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-23T14:35:57+08:00">
                2018-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://www.wailian.work/images/2018/01/23/60f198516cee4ab511cb190a85599d3e1d88302a4d1ba-iBehXn_fw658.jpg" alt="pic"></p>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新建状态时，程序还没有开始运行线程中的代码</p>
<h2 id="就绪"><a href="#就绪" class="headerlink" title="就绪"></a>就绪</h2><p>一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。此时线程中代码仍未运行</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>当线程获得CPU后，它才进入运行状态，真正开始执行run()方法中的代码</p>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>该线程放弃CPU的使用，暂停运行</p>
<p>常见线程阻塞的原因:</p>
<ol>
<li><p>线程执行了Thread.sleep(int millsecond)方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行</p>
</li>
<li><p>线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行</p>
</li>
<li><p>线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法</p>
</li>
<li><p>线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态</p>
</li>
</ol>
<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><p>线程执行完毕</p>
<h1 id="线程的创建方法"><a href="#线程的创建方法" class="headerlink" title="线程的创建方法"></a>线程的创建方法</h1><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Thread1 extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 线程执行代码</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread1 mTh1=new Thread1();</span><br><span class="line">        Thread1 mTh2=new Thread1();</span><br><span class="line">        mTh1.start();</span><br><span class="line">        mTh2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用main的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行</p>
<p>注意：<br>start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。</p>
<p>从程序运行的结果可以发现，多线程程序是乱序执行。</p>
<p>Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。</p>
<p>实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。</p>
<h2 id="实现Runable接口-推荐"><a href="#实现Runable接口-推荐" class="headerlink" title="实现Runable接口(推荐)"></a>实现Runable接口(推荐)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Thread2 implements Runnable&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Thread2(String name) &#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    // 线程逻辑代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new Thread2(&quot;C&quot;)).start();</span><br><span class="line">        new Thread(new Thread2(&quot;D&quot;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两种方法的区别"><a href="#两种方法的区别" class="headerlink" title="两种方法的区别"></a>两种方法的区别</h2><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p>
<p>总结：<br>实现Runnable接口比继承Thread类所具有的优势：</p>
<ol>
<li>适合多个相同的程序代码的线程去处理同一个资源 </li>
<li>可以避免java中的单继承的限制</li>
<li>增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</li>
<li>线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</li>
</ol>
<p>提醒一下大家：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。</p>
<p>在Java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际就是在操作系统中启动了一个进程。</p>
<h1 id="线程状态-1"><a href="#线程状态-1" class="headerlink" title="线程状态"></a>线程状态</h1><p><img src="http://www.wailian.work/images/2018/01/23/20170717150938439.jpg" alt=""></p>
<h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><p>Java线程有优先级，优先级高的线程会优先获得运行机会(但不一定优先级高的一定先执行)<br>Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int MAX_PRIORITY  = 10;  //线程可以具有的最高优先级</span><br><span class="line">static int MIN_PRIORITY  = 1;   //线程可以具有的最低优先级</span><br><span class="line">static int NORM_PRIORITY = 5;   //分配给线程的默认优先级</span><br></pre></td></tr></table></figure>
<p>Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。</p>
<h1 id="线程睡眠"><a href="#线程睡眠" class="headerlink" title="线程睡眠"></a>线程睡眠</h1><p>Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p>
<h1 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h1><p>Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。</p>
<h1 id="线程让步"><a href="#线程让步" class="headerlink" title="线程让步"></a>线程让步</h1><p>Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p>
<h1 id="线程加入"><a href="#线程加入" class="headerlink" title="线程加入"></a>线程加入</h1><p>join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p>
<h1 id="线程唤醒"><a href="#线程唤醒" class="headerlink" title="线程唤醒"></a>线程唤醒</h1><p>Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</p>
<p>注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。</p>
<h1 id="常用函数说明"><a href="#常用函数说明" class="headerlink" title="常用函数说明"></a>常用函数说明</h1><h2 id="sleep-long-millis"><a href="#sleep-long-millis" class="headerlink" title="sleep(long millis)"></a>sleep(long millis)</h2><p>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</p>
<h1 id="join"><a href="#join" class="headerlink" title="join"></a>join</h1><p>join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;主线程运行开始!&quot;);</span><br><span class="line">        Thread1 mTh1=new Thread1(&quot;A&quot;);</span><br><span class="line">        Thread1 mTh2=new Thread1(&quot;B&quot;);</span><br><span class="line">        mTh1.start();</span><br><span class="line">        mTh2.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            mTh1.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            mTh2.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;主线程运行结束!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="yield-暂停当前正在执行的线程对象，并执行其他线程。"><a href="#yield-暂停当前正在执行的线程对象，并执行其他线程。" class="headerlink" title="yield():暂停当前正在执行的线程对象，并执行其他线程。"></a>yield():暂停当前正在执行的线程对象，并执行其他线程。</h1><p>Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。</p>
<p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>
<p>结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。可看上面的图。</p>
<h1 id="sleep-和yield-的区别"><a href="#sleep-和yield-的区别" class="headerlink" title="sleep()和yield()的区别"></a>sleep()和yield()的区别</h1><p>sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</p>
<p>sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程</p>
<p>另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield() 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。</p>
<h1 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h1><p>我们可以利用wait()来让一个线程在某些条件下暂停运行。例如，在生产者消费者模型中，生产者线程在缓冲区为满的时候，消费者在缓冲区为空的时候，都应该暂停运行。如果某些线程在等待某些条件触发，那当那些条件为真时，你可以用 notify 和 notifyAll 来通知那些等待中的线程重新开始运行。不同之处在于，notify 仅仅通知一个线程，并且我们不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。换言之，如果只有一个线程在等待一个信号灯，notify和notifyAll都会通知到这个线程。但如果多个线程在等待这个信号灯，那么notify只会通知到其中一个，而其它线程并不会收到任何通知，而notifyAll会唤醒所有等待中的线程。</p>
<p>我们怎么在代码里使用wait()呢？因为wait()并不是Thread类下的函数，我们并不能使用Thread.wait()。事实上很多Java程序员都喜欢这么写，因为它们习惯了使用Thread.sleep()，所以他们会试图使用wait() 来达成相同的目的，但很快他们就会发现这并不能顺利解决问题。正确的方法是对在多线程间共享的那个Object来使用wait。在生产者消费者问题中，这个共享的Object就是那个缓冲区队列。</p>
<p>既然我们应该在synchronized的函数或是对象里调用wait，那哪个对象应该被synchronized呢？答案是，那个你希望上锁的对象就应该被synchronized，即那个在多个线程间被共享的对象。在生产者消费者问题中，应该被synchronized的就是那个缓冲区队列。</p>
<h2 id="永远在循环（loop）里调用-wait-和-notify，不是在-If-语句"><a href="#永远在循环（loop）里调用-wait-和-notify，不是在-If-语句" class="headerlink" title="永远在循环（loop）里调用 wait 和 notify，不是在 If 语句"></a>永远在循环（loop）里调用 wait 和 notify，不是在 If 语句</h2><p>现在你知道wait应该永远在被synchronized的背景下和那个被多线程共享的对象上调用，下一个一定要记住的问题就是，你应该永远在while循环，而不是if语句中调用wait。因为线程是在某些条件下等待的——在我们的例子里，即“如果缓冲区队列是满的话，那么生产者线程应该等待”，你可能直觉就会写一个if语句。但if语句存在一些微妙的小问题即使条件没被满足，你的线程你也有可能被错误地唤醒。所以如果你不在线程被唤醒后再次使用while循环检查唤醒条件是否被满足，你的程序就有可能会出错——例如在缓冲区为满的时候生产者继续生成数据，或者缓冲区为空的时候消费者开始消耗数据。所以记住，永远在while循环而不是if语句中使用wait！</p>
<p>在while循环里使用wait的目的，是在线程被唤醒的前后都持续检查条件是否被满足。如果条件并未改变，wait被调用之前notify的唤醒通知就来了，那么这个线程并不能保证被唤醒，有可能会导致死锁问题。</p>
<p>下面我们提供一个使用wait和notify的范例程序。在这个程序里，我们使用了上文所述的一些代码规范。我们有两个线程，分别名为PRODUCER（生产者）和CONSUMER（消费者），他们分别继承了了Producer和Consumer类，而Producer和Consumer都继承了Thread类。Producer和Consumer想要实现的代码逻辑都在run()函数内。Main线程开始了生产者和消费者线程，并声明了一个LinkedList作为缓冲区队列（在Java中，LinkedList实现了队列的接口）。生产者在无限循环中持续往LinkedList里插入随机整数直到LinkedList满。我们在while(queue.size == maxSize)循环语句中检查这个条件。请注意到我们在做这个检查条件之前已经在队列对象上使用了synchronized关键词，因而其它线程不能在我们检查条件时改变这个队列。如果队列满了，那么PRODUCER线程会在CONSUMER线程消耗掉队列里的任意一个整数，并用notify来通知PRODUCER线程之前持续等待。在我们的例子中，wait和notify都是使用在同一个共享对象上的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">import java.util.Random;</span><br><span class="line">/**</span><br><span class="line">* Simple Java program to demonstrate How to use wait, notify and notifyAll()</span><br><span class="line">* method in Java by solving producer consumer problem.</span><br><span class="line">*/</span><br><span class="line">public class ProducerConsumerInJava &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        System.out.println(&quot;How to use wait and notify method in Java&quot;);</span><br><span class="line">        System.out.println(&quot;Solving Producer Consumper Problem&quot;);</span><br><span class="line">        Queue&lt;Integer&gt; buffer = new LinkedList&lt;&gt;();</span><br><span class="line">        int maxSize = 10;</span><br><span class="line">        Thread producer = new Producer(buffer, maxSize, &quot;PRODUCER&quot;);</span><br><span class="line">        Thread consumer = new Consumer(buffer, maxSize, &quot;CONSUMER&quot;);</span><br><span class="line">        producer.start(); consumer.start(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * Producer Thread will keep producing values for Consumer</span><br><span class="line">    * to consumer. It will use wait() method when Queue is full</span><br><span class="line">    * and use notify() method to send notification to Consumer</span><br><span class="line">    * Thread.</span><br><span class="line">    */</span><br><span class="line">    class Producer extends Thread</span><br><span class="line">    &#123;</span><br><span class="line">        private Queue&lt;Integer&gt; queue;</span><br><span class="line">        private int maxSize;</span><br><span class="line">        public Producer(Queue&lt;Integer&gt; queue, int maxSize, String name)&#123;</span><br><span class="line">            super(name); this.queue = queue; this.maxSize = maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override public void run()</span><br><span class="line">        &#123;</span><br><span class="line">            while (true)</span><br><span class="line">                &#123;</span><br><span class="line">                    synchronized (queue) &#123;</span><br><span class="line">                        while (queue.size() == maxSize) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                System.out .println(&quot;Queue is full, &quot; + &quot;Producer thread waiting for &quot; + &quot;consumer to take something from queue&quot;);</span><br><span class="line">                                queue.wait();</span><br><span class="line">                            &#125; catch (Exception ex) &#123;</span><br><span class="line">                                ex.printStackTrace(); &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Random random = new Random();</span><br><span class="line">                            int i = random.nextInt();</span><br><span class="line">                            System.out.println(&quot;Producing value : &quot; + i); queue.add(i); queue.notifyAll();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    /**</span><br><span class="line">    * Consumer Thread will consumer values form shared queue.</span><br><span class="line">    * It will also use wait() method to wait if queue is</span><br><span class="line">    * empty. It will also use notify method to send</span><br><span class="line">    * notification to producer thread after consuming values</span><br><span class="line">    * from queue.</span><br><span class="line">    */</span><br><span class="line">    class Consumer extends Thread &#123;</span><br><span class="line">        private Queue&lt;Integer&gt; queue;</span><br><span class="line">        private int maxSize;</span><br><span class="line">        public Consumer(Queue&lt;Integer&gt; queue, int maxSize, String name)&#123;</span><br><span class="line">            super(name);</span><br><span class="line">            this.queue = queue;</span><br><span class="line">            this.maxSize = maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                synchronized (queue) &#123;</span><br><span class="line">                    while (queue.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(&quot;Queue is empty,&quot; + &quot;Consumer thread is waiting&quot; + &quot; for producer thread to put something in queue&quot;);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; catch (Exception ex) &#123;</span><br><span class="line">                            ex.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;Consuming value : &quot; + queue.remove()); queue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.wailian.work/images/2018/01/23/20170805131528961.png" alt=""></p>
<p>为了更好地理解这个程序，我建议你在debug模式里跑这个程序。一旦你在debug模式下启动程序，它会停止在PRODUCER或者CONSUMER线程上，取决于哪个线程占据了CPU。因为两个线程都有wait()的条件，它们一定会停止，然后你就可以跑这个程序然后看发生什么了（很有可能它就会输出我们以上展示的内容）。你也可以使用Eclipse里的Step into和Step over按钮来更好地理解多线程间发生的事情。</p>
<h1 id="阻塞队列实现生产者消费者问题"><a href="#阻塞队列实现生产者消费者问题" class="headerlink" title="阻塞队列实现生产者消费者问题"></a>阻塞队列实现生产者消费者问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class ProducerConsumerWithQueue &#123;</span><br><span class="line">    private int queueSize = 10;</span><br><span class="line">    private ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ProducerConsumerWithQueue test = new ProducerConsumerWithQueue();</span><br><span class="line">        Producer producer = test.new Producer();</span><br><span class="line">        Consumer consumer = test.new Consumer();</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Consumer extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                    System.out.println(&quot;从队列取走一个元素，队列剩余&quot; + queue.size() + &quot;个元素&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Producer extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue.put(1);</span><br><span class="line">                    System.out.println(&quot;向队列取中插入一个元素，队列剩余空间：&quot; + (queueSize - queue.size()));</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="附：阻塞队列的四种处理方法"><a href="#附：阻塞队列的四种处理方法" class="headerlink" title="附：阻塞队列的四种处理方法"></a>附：阻塞队列的四种处理方法</h2><table>
<thead>
<tr>
<th>方法\处理方式</th>
<th style="text-align:right">抛出异常</th>
<th style="text-align:center">返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td style="text-align:right">add(e)</td>
<td style="text-align:center">offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td style="text-align:right">remove()</td>
<td style="text-align:center">poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td style="text-align:right">element()</td>
<td style="text-align:center">peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<h1 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 计算输出其他线程锁计算的数据</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">public class ThreadA &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">        ThreadB b = new ThreadB();</span><br><span class="line">        //启动计算线程</span><br><span class="line">        b.start();</span><br><span class="line">        //线程A拥有b对象上的锁。线程为了调用wait()或notify()方法，该线程必须是那个对象锁的拥有者</span><br><span class="line">        synchronized (b) &#123;</span><br><span class="line">            System.out.println(&quot;等待对象b完成计算。。。&quot;);</span><br><span class="line">            //当前线程A等待</span><br><span class="line">            b.wait();</span><br><span class="line">            System.out.println(&quot;b对象计算的总和是：&quot; + b.total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 计算1+2+3 ... +100的和</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">class ThreadB extends Thread &#123;</span><br><span class="line">    int total;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            for (int i = 0; i &lt; 101; i++) &#123;</span><br><span class="line">                total += i;</span><br><span class="line">            &#125;</span><br><span class="line">            //（完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程A被唤醒</span><br><span class="line">            notify();</span><br><span class="line">            System.out.println(&quot;计算完成&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p>等待对象b完成计算。。。<br>计算完成<br>b对象计算的总和是：5050</p>
<p>如果我们将b.wait()去掉呢？结果如下：</p>
<p>等待对象b完成计算。。。<br>b对象计算的总和是：0<br>计算完成</p>
<p>上述的结果表明，当去掉b.wait()时，新启动的线程ThreadB与主线程ThreadA是各自执行的，没有线程等待的现象。</p>
<p>我们想要的效果是，当线程ThreadB完成计算之后，再去取计算后的结果。所以使用了b.wait()来让主线程等待。</p>
<p>那为什么是使用b.wait()，而不是Thread.currentThread.wait()，或者其他的呢？</p>
<p>如果我们将b.wait()替换成Thread.currentThread.wait()，将会得到如下的结果：</p>
<p>Exception in thread “main” java.lang.IllegalMonitorStateException<br>at java.lang.Object.wait(Native Method)<br>at java.lang.Object.wait(Object.java:485)<br>at pa.com.thread.ThreadA.main(ThreadA.java:18)<br>等待对象b完成计算。。。<br>计算完成</p>
<p>替换的代码Thread.currentThread.wait()好像理所当然应该如我们预期的正确啊，让当前线程处于等待状态，让其他线程先执行。</p>
<p>我们忽略了一个很重要的问题：线程与锁是分不开的，线程的同步、等待、唤醒都与对象锁是密不可分的。</p>
<p>线程ThreadA持有对象b的锁，我们要使用这把锁去让线程释放锁，从而让其他的线程能抢到这把锁。</p>
<p>从我们的程序来分析就是：线程ThreadA首先持有锁对象b，然后调用b.wait()将对象锁释放，线程ThreadB争抢到对象锁b，从而执行run()方法中的计算，计算完了之后使用notify()唤醒主线程ThreadA，ThreadA得以继续执行，从而得到了我们预期的效果。</p>
<p>（之所以ThreadB的对象锁也是b，是因为synchronized(this)中的this指向的就是ThreadB的实例b）</p>
<p>Thread.currentThread.wait()调用的是当前线程对象（即主线程ThreadA）的wait()方法，当前线程对象ThreadA是没有被加锁的，它只是获取了对象锁b。我基本没有看到过这样的调用，一般使用的是锁对象的wait()，本例中为b.wait()</p>
<p>顺带讲一下wait()与sleep()的区别。</p>
<p>如果我们将b.wait()换成Thread.sleep(1000)，则会出现如下的结果：</p>
<p>等待对象b完成计算。。。<br>b对象计算的总和是：0<br>计算完成</p>
<p>从执行结果可以看出，Thread.sleep(1000)只是让主线程ThreadA睡眠了1秒钟，而并没有释放对象锁，所以在主线程ThreadA睡眠的过程中，ThreadB拿不到对象锁，从而不能执行。</p>
<p>所以我们也就得出了如下的结论：</p>
<p>wait()方法是让线程释放对象锁，让其他线程拿到锁之后去优先执行，当其他全程唤醒wait()中的线程 或者 拿到对象锁的线程都执行完释放了对象锁之后，wait()中的线程才会再次拿到对象锁从而执行。</p>
<p>sleep()方法是让线程睡眠，此时并没有释放对象锁，其他想要拿到睡眠线程的对象锁的线程也就拿不到相应的对象锁，从而不能抢在它前面执行。</p>
<p>补：</p>
<p>wait、notify和notifyAll方法是Object类的final native方法。所以这些方法不能被子类重写，Object类是所有类的超类，因此在程序中有以下三种形式调用wait等方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait();//方式1：</span><br><span class="line">this.wait();//方式2：</span><br><span class="line">super.wait();//方式3</span><br></pre></td></tr></table></figure>
<p>void wait()</p>
<p>导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。</p>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>卖火车票问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Seller implements Runnable &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (Synchronized.ticket &gt; 0) &#123;</span><br><span class="line">                System.out.println(&quot;正在卖票,剩余&quot; + Synchronized.ticket);</span><br><span class="line">                Synchronized.ticket--;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronized &#123;</span><br><span class="line">    static Integer ticket = 100;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Seller s = new Seller();</span><br><span class="line">        Thread t1 = new Thread(s);</span><br><span class="line">        Thread t2 = new Thread(s);</span><br><span class="line">        Thread t3 = new Thread(s);</span><br><span class="line">        Thread t4 = new Thread(s);</span><br><span class="line">        Thread t5 = new Thread(s);</span><br><span class="line">        Thread t6 = new Thread(s);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        t5.start();</span><br><span class="line">        t6.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/wangweiye01/mutiThreading" target="_blank" rel="noopener">源码地址</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/blog/2018/01/20/java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老枪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老枪的世界">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/01/20/java/" itemprop="url">java新特性讲义</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-20T22:03:18+08:00">
                2018-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Predicate操作集合"><a href="#Predicate操作集合" class="headerlink" title="Predicate操作集合"></a>Predicate操作集合</h1><p>Java 8为Collection集合新增一个removeIf(Predicate filter)方法，该方法将会批量删除符合filter条件的所有元素。该方法需要一个Predicate对象作为参数，Predicate也是函数式接口，因此可使用Lamada表达式作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collection books = new HashSet();</span><br><span class="line">books.add(new String(&quot;123&quot;));</span><br><span class="line">books.add(new String(&quot;1234&quot;));</span><br><span class="line">books.add(new String(&quot;12345&quot;));</span><br><span class="line">books.add(new String(&quot;123456&quot;));</span><br><span class="line">// 使用Lamada表达式过滤集合</span><br><span class="line">books.removeIf(ele -&gt; ((String)ele).length() &lt; 3);</span><br><span class="line">System.out.println(books);</span><br></pre></td></tr></table></figure>
<p>上面程序中调用了Collection集合的removeIf()方法批量删除集合中符合条件的元素，程序中传入了一个Lamada表达式作为过滤条件。</p>
<p>Predicate就是一个函数式接口，可以把它当做C语言中函数指针来使用；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void operate(Collection c, Predicate p) &#123; // 满足谓词条件p的元素都打印出来</span><br><span class="line">        for (Object ele: c) &#123;</span><br><span class="line">            if (p.test(ele)) &#123;</span><br><span class="line">                System.out.println(ele);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Collection c = new ArrayList();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123; // 加入0 ~ 9的字符串</span><br><span class="line">            c.add(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        operate(c, ele -&gt; Integer.valueOf((String)ele) &gt; 3); // 大于3的打印出来</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/blog/2018/01/19/blockchain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老枪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老枪的世界">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/01/19/blockchain/" itemprop="url">区块链的理解</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-19T09:49:44+08:00">
                2018-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://s1.wailian.download/2018/01/19/f7a1eb169a2ac8556d241cd7173ca9a5d9ede3cb161fa5-eeMK3M_fw658.jpg" alt="pic"></p>
<blockquote>
<p>最近在各个媒体中出现了区块链的概念，抽时间了解了一下</p>
</blockquote>
<h1 id="区块链的本质"><a href="#区块链的本质" class="headerlink" title="区块链的本质"></a>区块链的本质</h1><p>区块链是什么？它就是一种特殊的分布式数据库。</p>
<p>首先，区块链的主要作用是储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取，所以它是数据库。</p>
<p>其次，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。</p>
<h1 id="区块链的最大特点"><a href="#区块链的最大特点" class="headerlink" title="区块链的最大特点"></a>区块链的最大特点</h1><p>分布式数据库并非新发明，市场上早有此类产品。但是，区块链有一个革命性特点。</p>
<p>区块链没有管理员，它是彻底无中心的。其他的数据库都有管理员，但是区块链没有。如果有人想对区块链添加审核，也实现不了，因为它的设计目标就是防止出现居于中心地位的管理当局。</p>
<p>正是因为无法管理，区块链才能做到无法被控制。否则一旦大公司大集团控制了管理权，他们就会控制整个平台，其他使用者都必须听命于他们了。</p>
<p>但是，没有了管理员，人人都可以往里面写入数据，怎么才能保证数据的可信呢？被坏人改了怎么办？请接着往下读，着就是区块链的奇妙之处。</p>
<h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><p>区块链由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。类似于数据结构当中的链表。</p>
<p><img src="http://s1.wailian.download/2018/01/19/bg2017122703.png" alt="blockchain"></p>
<p>每个区块包含两部分。</p>
<ul>
<li>Head：记录当前区块的元信息</li>
<li>Body：实际数据</li>
</ul>
<p>区块头包含了当前区块的多项元信息。</p>
<ul>
<li>生成时间</li>
<li>实际数据的Hash</li>
<li>上一区块的Hash</li>
<li>…</li>
</ul>
<p>这里，你需要理解什么叫 Hash，这是理解区块链必需的。</p>
<p><img src="http://s1.wailian.download/2018/01/19/bg2017122704.png" alt="hash"></p>
<p>所谓 Hash 就是计算机可以对任意内容，计算出一个长度相同的特征值。区块链的 Hash 长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的 Hash 一定是不同的。</p>
<p>举例来说，字符串123的 Hash 是a8fdc205a9f19cc1c7507a60c4f01b13d11d7fd0（十六进制），转成二进制就是256位，而且只有123能得到这个 Hash。</p>
<p>因此，就有两个重要的推论。</p>
<ul>
<li>每个区块的 Hash 都是不一样的，可以通过 Hash 标识区块。</li>
<li>如果区块的内容变了，它的 Hash 一定会改变。</li>
</ul>
<h1 id="Hash-的不可修改性"><a href="#Hash-的不可修改性" class="headerlink" title="Hash 的不可修改性"></a>Hash 的不可修改性</h1><p>区块与 Hash 是一一对应的，每个区块的 Hash 都是针对”区块头”（Head）计算的。</p>
<blockquote>
<p>Hash = SHA256(区块头)</p>
</blockquote>
<p>上面就是区块 Hash 的计算公式，Hash 由区块头唯一决定，SHA256是区块链的 Hash 算法。</p>
<p>前面说过，区块头包含很多内容，其中有当前区块体的 Hash（注意是”区块体”的 Hash，而不是整个区块），还有上一个区块的 Hash。这意味着，如果当前区块的内容变了，或者上一个区块的 Hash 变了，一定会引起当前区块的 Hash 改变。</p>
<p>这一点对区块链有重大意义。如果有人修改了一个区块，该区块的 Hash 就变了。为了让后面的区块还能连到它，该人必须同时修改后面所有的区块，否则被改掉的区块就脱离区块链了。由于后面要提到的原因，Hash 的计算很耗时，同时修改多个区块几乎不可能发生，除非有人掌握了全网51%以上的计算能力。</p>
<p>正是通过这种联动机制，区块链保证了自身的可靠性，数据一旦写入，就无法被篡改。这就像历史一样，发生了就是发生了，从此再无法改变。</p>
<p><img src="http://s1.wailian.download/2018/01/19/bg2017122705.png" alt=""><br>每个区块都连着上一个区块，这也是”区块链”这个名字的由来。</p>
<h1 id="采矿"><a href="#采矿" class="headerlink" title="采矿"></a>采矿</h1><p>由于必须保证节点之间的同步，所以新区块的添加速度不能太快。试想一下，你刚刚同步了一个区块，准备基于它生成下一个区块，但这时别的节点又有新区块生成，你不得不放弃做了一半的计算，再次去同步。因为每个区块的后面，只能跟着一个区块，你永远只能在最新区块的后面，生成下一个区块。所以，你别无选择，一听到信号，就必须立刻同步。</p>
<p>所以，区块链的发明者中本聪（这是假名，真实身份至今未知）故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个。</p>
<p>这种产出速度不是通过命令达成的，而是故意设置了海量的计算。也就是说，只有通过极其大量的计算，才能得到当前区块的有效 Hash，从而把新区块添加到区块链。由于计算量太大，所以快不起来。</p>
<p>这个过程就叫做采矿（mining），因为计算有效 Hash 的难度，好比在全世界的沙子里面，找到一粒符合条件的沙子。计算 Hash 的机器就叫做矿机，操作矿机的人就叫做矿工。</p>
<h1 id="难度系数"><a href="#难度系数" class="headerlink" title="难度系数"></a>难度系数</h1><p>读到这里，你可能会有一个疑问，人们都说采矿很难，可是采矿不就是用计算机算出一个 Hash 吗，这正是计算机的强项啊，怎么会变得很难，迟迟算不出来呢？</p>
<p>原来不是任意一个 Hash 都可以，只有满足条件的 Hash 才会被区块链接受。这个条件特别苛刻，使得绝大部分 Hash 都不满足要求，必须重算。</p>
<p>原来，区块头包含一个难度系数（difficulty），这个值决定了计算 Hash 的难度。举例来说，第100000个区块的难度系数是 14484.16236122。</p>
<p><img src="http://s1.wailian.download/2018/01/19/bg2017122707.png" alt=""><br>区块链协议规定，使用一个常量除以难度系数，可以得到目标值（target）。显然，难度系数越大，目标值就越小。</p>
<p><img src="http://s1.wailian.download/2018/01/19/bg2017122708.png" alt=""></p>
<p>Hash 的有效性跟目标值密切相关，只有小于目标值的 Hash 才是有效的，否则 Hash 无效，必须重算。由于目标值非常小，Hash 小于该值的机会极其渺茫，可能计算10亿次，才算中一次。这就是采矿如此之慢的根本原因。</p>
<p>区块头里面还有一个 Nonce 值，记录了 Hash 重算的次数。第 100000 个区块的 Nonce 值是274148111，即计算了 2.74 亿次，才得到了一个有效的 Hash，该区块才能加入区块链。</p>
<h1 id="难度系数的动态调节"><a href="#难度系数的动态调节" class="headerlink" title="难度系数的动态调节"></a>难度系数的动态调节</h1><p>就算采矿很难，但也没法保证，正好十分钟产出一个区块，有时一分钟就算出来了，有时几个小时可能也没结果。总体来看，随着硬件设备的提升，以及矿机的数量增长，计算速度一定会越来越快。</p>
<p>为了将产出速率恒定在十分钟，中本聪还设计了难度系数的动态调节机制。他规定，难度系数每两周（2016个区块）调整一次。如果这两周里面，区块的平均生成速度是9分钟，就意味着比法定速度快了10%，因此难度系数就要调高10%；如果平均生成速度是11分钟，就意味着比法定速度慢了10%，因此难度系数就要调低10%。</p>
<p>难度系数越调越高（目标值越来越小），导致了采矿越来越难。</p>
<h1 id="区块链的分叉"><a href="#区块链的分叉" class="headerlink" title="区块链的分叉"></a>区块链的分叉</h1><p>即使区块链是可靠的，现在还有一个问题没有解决：如果两个人同时向区块链写入数据，也就是说，同时有两个区块加入，因为它们都连着前一个区块，就形成了分叉。这时应该采纳哪一个区块呢？</p>
<p><img src="http://s1.wailian.download/2018/01/19/bg2017122709.png" alt=""></p>
<p>现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为”六次确认”）。按照10分钟一个区块计算，一小时就可以确认。</p>
<p><img src="http://s1.wailian.download/2018/01/19/bg2017122710.png" alt=""></p>
<p>由于新区块的生成速度由计算能力决定，所以这条规则就是说，拥有大多数计算能力的那条分支，就是正宗的比特链。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>区块链作为无人管理的分布式数据库，从2009年开始已经运行了8年，没有出现大的问题。这证明它是可行的。</p>
<p>但是，为了保证数据的可靠性，区块链也有自己的代价。一是效率，数据写入区块链，最少要等待十分钟，所有节点都同步数据，则需要更多的时间；二是能耗，区块的生成需要矿工进行无数无意义的计算，这是非常耗费能源的。</p>
<p>因此，区块链的适用场景，其实非常有限。</p>
<ul>
<li>不存在所有成员都信任的管理当局</li>
<li>写入的数据不要求实时使用</li>
<li>挖矿的收益能够弥补本身的成本</li>
</ul>
<p>目前，区块链最大的应用场景（可能也是唯一的应用场景），就是以比特币为代表的加密货币</p>
<blockquote>
<p>参考自<a href="http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html" target="_blank" rel="noopener">阮一峰</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/4/">4</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/blog/images/1.jpg"
                alt="老枪" />
            
              <p class="site-author-name" itemprop="name">老枪</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="mailto:wwyknight@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">老枪</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/blog/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/blog/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
